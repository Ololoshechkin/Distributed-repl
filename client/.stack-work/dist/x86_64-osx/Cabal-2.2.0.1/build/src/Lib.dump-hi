
==================== FINAL INTERFACE ====================
2019-09-26 02:55:13.367665 UTC

interface client-0.1.0.0-2otZ1nLTSSxDNDXeH3pKHr:Lib 8044
  interface hash: 7b0433af2870e5c2b60364ab01eb3af0
  ABI hash: 5d97b3bb67e54750aa0c3231eeff413a
  export-list hash: a0649c695f33bce8ad6abae9720461af
  orphan hash: 59e4c9e8fff9c1a90712e284a30e5068
  flag hash: e15047c0545b6a6b36d1255cf96f55b5
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.parseScript
module dependencies:
package dependencies: array-0.5.2.0 base-4.11.1.0 binary-0.8.5.1
                      bytestring-0.10.8.2 case-insensitive-1.2.0.11 containers-0.5.11.0
                      deepseq-1.4.3.0 ghc-prim-0.5.2.0 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.2 megaparsec-6.5.0
                      mtl-2.2.2 network-transport-0.5.2 parser-combinators-1.0.0
                      primitive-0.6.3.0 scientific-0.3.6.2 text-1.2.3.1
                      transformers-0.5.5.0 utils-0.1.0.0
orphans: transformers-0.5.5.0:Control.Monad.Trans.Error
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal containers-0.5.11.0:Data.Tree
                         megaparsec-6.5.0:Text.Megaparsec.Error
                         megaparsec-6.5.0:Text.Megaparsec.Pos
                         megaparsec-6.5.0:Text.Megaparsec.State
                         megaparsec-6.5.0:Text.Megaparsec.Stream
                         network-transport-0.5.2:Network.Transport
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array text-1.2.3.1:Data.Text
                         text-1.2.3.1:Data.Text.Lazy
import  -/  base-4.11.1.0:Data.Either 39d922b371c4c52d426e9ee66de8371a
import  -/  base-4.11.1.0:Data.Void 4c9c07b3e8b1059587733a690d1fbc93
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  megaparsec-6.5.0:Text.Megaparsec 097a1202ce63f77200fed77881988d00
import  -/  megaparsec-6.5.0:Text.Megaparsec.Char 045e42c32288105835316bd6fb1baf4e
import  -/  megaparsec-6.5.0:Text.Megaparsec.Char.Lexer 2a02799413495cdb54220b50c132ed4a
import  -/  megaparsec-6.5.0:Text.Megaparsec.Class 56f40aab2b51236fabd8a3da895864ff
import  -/  parser-combinators-1.0.0:Control.Monad.Combinators b943dff835ec404d8e5a8d121f3d607c
import  -/  utils-0.1.0.0:Messages d092de2cd317fb3a419e83b1cbab3b00
5e08e026c688279266c4c60b48eaed43
  $s$fAlternativeParsecT ::
    GHC.Base.Alternative
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  (Lib.$s$fAlternativeParsecT_$s$fApplicativeParsecT
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pZero
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Lib.$s$fAlternativeParsecT_$spPlus @ m)
                  (Text.Megaparsec.Internal.$fAlternativeParsecT3
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     Data.Void.$fOrdVoid
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT
                      Data.Void.Void [GHC.Types.Char] m a>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <[a]>_R))
                  (Text.Megaparsec.Internal.$fAlternativeParsecT1
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     Data.Void.$fOrdVoid
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT
                      Data.Void.Void [GHC.Types.Char] m a>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <[a]>_R)) -}
25622e4548f20725b7fe3f17d32c7278
  $s$fAlternativeParsecT1 ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> m b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U(U,U,U),U),U,U)><L,C(U)><L,U><L,C(U)><L,A>,
     Inline: [0],
     Unfolding: InlineRule (6, True, True)
                (\ @ m :: * -> *
                   @ a
                   (w2 :: Text.Megaparsec.Internal.ParsecT
                            Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (w3 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w4 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w5 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (w6 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w7 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 Text.Megaparsec.Internal.$w$cmany
                   @ Data.Void.Void
                   @ [GHC.Types.Char]
                   @ m
                   Text.Megaparsec.Stream.$fStream[]
                   @ a
                   w2
                   @ b
                   w3
                   w4
                   w5
                   w6) -}
afc4b4f2ecb3d681fecd9841c571d537
  $s$fAlternativeParsecT3 ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> ([a]
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> m b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
       -> m b
  {- Arity: 6,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ @ m :: * -> *
                   @ a
                   (w2 :: Text.Megaparsec.Internal.ParsecT
                            Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (w3 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (w4 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w5 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (w6 :: [a]
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (w7 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 Text.Megaparsec.Internal.$w$csome
                   @ Data.Void.Void
                   @ [GHC.Types.Char]
                   @ m
                   Text.Megaparsec.Stream.$fStream[]
                   @ a
                   w2
                   @ b
                   w3
                   w4
                   w5
                   w6
                   w7) -}
9ef87188dcf34626e1b6de7a09309bc9
  $s$fAlternativeParsecT_$s$fApplicativeParsecT ::
    GHC.Base.Applicative
      (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
                  (Text.Megaparsec.Internal.$fFunctorParsecT
                     @ e
                     @ [GHC.Types.Char]
                     @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pPure @ a @ e @ [GHC.Types.Char] @ m)
                  (Lib.$s$fAlternativeParsecT_$spAp @ e @ m)
                  (Text.Megaparsec.Internal.$fAlternativeParsecT2
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <c>_R))
                  (Text.Megaparsec.Internal.$fApplicativeParsecT2
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R))
                  (Text.Megaparsec.Internal.$fApplicativeParsecT1
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
b7a8cbc08f42bb756391f63ab8bfee6c
  $s$fAlternativeParsecT_$spAp ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m (a -> b)
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m25 :: Text.Megaparsec.Internal.ParsecT
                             e [GHC.Types.Char] m (a -> b))
                   (k7 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m25
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a -> b>_R)
                   @ b1
                   s1
                   (\ (x :: a -> b)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs6 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k7
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b1
                      s'
                      (GHC.Base..
                         @ b
                         @ (Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b1)
                         @ a
                         cok
                         x)
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ a
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs6
                         (GHC.Base..
                            @ b
                            @ (Text.Megaparsec.State.State [GHC.Types.Char]
                               -> Text.Megaparsec.Internal.Hints
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> m b1)
                            @ a
                            cok
                            x))
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs6 cerr))
                   cerr
                   (\ (x :: a -> b)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs6 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k7
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b1
                      s'
                      (GHC.Base..
                         @ b
                         @ (Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b1)
                         @ a
                         cok
                         x)
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ a
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs6
                         (GHC.Base..
                            @ b
                            @ (Text.Megaparsec.State.State [GHC.Types.Char]
                               -> Text.Megaparsec.Internal.Hints
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> m b1)
                            @ a
                            eok
                            x))
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs6 eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m (a -> b)>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
0df7cf731b2e26edb74322375806297d
  $s$fAlternativeParsecT_$spPlus ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m a
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,C(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ m :: * -> *
                   @ a
                   (m25 :: Text.Megaparsec.Internal.ParsecT
                             Data.Void.Void [GHC.Types.Char] m a)
                   (n20 :: Text.Megaparsec.Internal.ParsecT
                             Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 m25
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   s1
                   cok
                   cerr
                   eok
                   (\ (err :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void)
                      (ms :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    n20
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b
                      s1
                      cok
                      (\ (err' :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       cerr
                         (let {
                            $j :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                              <join 0>
                            = case err' of wild {
                                Text.Megaparsec.Error.TrivialError s2 u1 p6
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds u2 p7
                                     -> Text.Megaparsec.Error.TrivialError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          s2
                                          (case u1 of wild2 {
                                             GHC.Base.Nothing -> u2
                                             GHC.Base.Just x
                                             -> case u2 of wild3 {
                                                  GHC.Base.Nothing
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       x
                                                  GHC.Base.Just y
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       (case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                                                               @ (Text.Megaparsec.Stream.Token
                                                                    [GHC.Types.Char])
                                                               GHC.Classes.$fOrdChar
                                                                 `cast`
                                                               (GHC.Classes.Ord
                                                                  (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                                                               y
                                                               x of wild4 {
                                                          GHC.Types.False -> y
                                                          GHC.Types.True -> x }) } })
                                          (Lib.$s$fAlternativeParsecT_$sunion1 p6 p7)
                                     Text.Megaparsec.Error.FancyError ds ds1 -> wild1 }
                                Text.Megaparsec.Error.FancyError ds ds1
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds2 ds3 ds4 -> wild
                                     Text.Megaparsec.Error.FancyError ds2 x2
                                     -> Text.Megaparsec.Error.FancyError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          ds
                                          (Lib.$s$fAlternativeParsecT_$sunion ds1 x2) } }
                          } in
                          case err' of wild {
                            Text.Megaparsec.Error.TrivialError p6 ds ds1
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p7 ds2 ds3
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p7 ds2
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } }
                            Text.Megaparsec.Error.FancyError p6 ds
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p7 ds1 ds2
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p7 ds1
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } } })
                         (Text.Megaparsec.Internal.longestMatch @ [GHC.Types.Char] ms s'))
                      (\ (x :: a)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                         (hs6 :: Text.Megaparsec.Internal.Hints
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       eok
                         x
                         s'
                         (GHC.Base.augment
                            @ (Data.Set.Internal.Set
                                 (Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                            (\ @ b1
                               (c :: Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                     -> b1 -> b1)[OneShot]
                               (n21 :: b1)[OneShot] ->
                             case err of wild {
                               Text.Megaparsec.Error.TrivialError errPos ds ps
                               -> case s' of wild1 { Text.Megaparsec.State.State ds1 ds2 dt5 ds3 ->
                                  case GHC.Base.$fEqNonEmpty_$c==
                                         @ Text.Megaparsec.Pos.SourcePos
                                         Text.Megaparsec.Pos.$fEqSourcePos
                                         ds2
                                         errPos of wild2 {
                                    GHC.Types.False -> n21
                                    GHC.Types.True
                                    -> case ps of wild3 {
                                         Data.Set.Internal.Bin dt6 ds4 ds5 ds6 -> c wild3 n21
                                         Data.Set.Internal.Tip -> n21 } } }
                               Text.Megaparsec.Error.FancyError ds ds1 -> n21 })
                            hs6
                              `cast`
                            (Text.Megaparsec.Internal.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                   <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                      (\ (err' :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void)
                         (s' :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                       eerr
                         (let {
                            $j :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                              <join 0>
                            = case err' of wild {
                                Text.Megaparsec.Error.TrivialError s2 u1 p6
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds u2 p7
                                     -> Text.Megaparsec.Error.TrivialError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          s2
                                          (case u1 of wild2 {
                                             GHC.Base.Nothing -> u2
                                             GHC.Base.Just x
                                             -> case u2 of wild3 {
                                                  GHC.Base.Nothing
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       x
                                                  GHC.Base.Just y
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       (case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                                                               @ (Text.Megaparsec.Stream.Token
                                                                    [GHC.Types.Char])
                                                               GHC.Classes.$fOrdChar
                                                                 `cast`
                                                               (GHC.Classes.Ord
                                                                  (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                                                               y
                                                               x of wild4 {
                                                          GHC.Types.False -> y
                                                          GHC.Types.True -> x }) } })
                                          (Lib.$s$fAlternativeParsecT_$sunion1 p6 p7)
                                     Text.Megaparsec.Error.FancyError ds ds1 -> wild1 }
                                Text.Megaparsec.Error.FancyError ds ds1
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds2 ds3 ds4 -> wild
                                     Text.Megaparsec.Error.FancyError ds2 x2
                                     -> Text.Megaparsec.Error.FancyError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          ds
                                          (Lib.$s$fAlternativeParsecT_$sunion ds1 x2) } }
                          } in
                          case err' of wild {
                            Text.Megaparsec.Error.TrivialError p6 ds ds1
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p7 ds2 ds3
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p7 ds2
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } }
                            Text.Megaparsec.Error.FancyError p6 ds
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p7 ds1 ds2
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p7 ds1
                                 -> case GHC.Base.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p6
                                           p7 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } } })
                         (Text.Megaparsec.Internal.longestMatch @ [GHC.Types.Char] ms s'))))
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT
                    Data.Void.Void [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT
                         Data.Void.Void [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
86cdb46c329c1d7c716a8ba3cad100a2
  $s$fAlternativeParsecT_$sunion ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
ed086e404ee6616fe385392355ad51d4
  $s$fAlternativeParsecT_$sunion1 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
d157e73a4fdf41976f840a41f6fdb9a1
  $s$fAlternativeParsecT_$swithHints ::
    Text.Megaparsec.Internal.Hints
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
        -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
    -> Text.Megaparsec.Error.ParseError
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
    -> Text.Megaparsec.State.State [GHC.Types.Char]
    -> m b
  {- Arity: 3, Strictness: <L,U><C(S),1*C1(U)><S,1*U>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ b
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (c :: Text.Megaparsec.Error.ParseError
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                         -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (e1 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e) ->
                 case e1 of wild {
                   Text.Megaparsec.Error.TrivialError pos us ps
                   -> c (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           pos
                           us
                           (Lib.$s$fAlternativeParsecT_go3
                              (Data.Set.Internal.Tip
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                              (GHC.Types.:
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 ps
                                 ds
                                   `cast`
                                 (Text.Megaparsec.Internal.N:Hints[0]
                                      <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))))
                   Text.Megaparsec.Error.FancyError ipv ipv1 -> c wild }) -}
ead9deecd6d44313736f4d6051396c4f
  $s$fAlternativeParsecT_go3 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> [Data.Set.Internal.Set
          (Text.Megaparsec.Error.ErrorItem
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))]
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
9d576f328520ff35749569fe35f0e162
  $s$fEqErrorFancy ::
    GHC.Classes.Eq (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                  (Text.Megaparsec.Error.$fEqErrorFancy_$c==
                     @ Data.Void.Void
                     Data.Void.$fEqVoid)
                  Lib.$s$fEqErrorFancy_$s$fEqErrorFancy_$c/= -}
1e2ad2e4031ecf468829c3fbcc205616
  $s$fEqErrorFancy_$s$fEqErrorFancy_$c/= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fEqErrorFancy_$c==
                        @ Data.Void.Void
                        Data.Void.$fEqVoid
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
70b140876f3bfdda5097d99b43e0ae67
  $s$fEqErrorItem ::
    GHC.Classes.Eq
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorItem
                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                  (Text.Megaparsec.Error.$fEqErrorItem_$c==
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fEqChar
                       `cast`
                     (GHC.Classes.Eq (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  Lib.$s$fEqErrorItem_$s$fEqErrorItem_$c/= -}
be733f73c7230649d179544537169b9f
  $s$fEqErrorItem_$s$fEqErrorItem_$c/= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fEqErrorItem_$c==
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fEqChar
                          `cast`
                        (GHC.Classes.Eq (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
ac06308efcc5209a21a6d554cf86e993
  $s$fMonadParsecT ::
    GHC.Base.Monad
      (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m)
                  (Lib.$s$fAlternativeParsecT_$s$fApplicativeParsecT @ e @ m)
                  (Lib.$s$fMonadParsecT_$spBind @ e @ m)
                  (Lib.$s$fMonadParsecT_$s$fMonadParsecT_$c>> @ e @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pPure @ a @ e @ [GHC.Types.Char] @ m)
                  (Text.Megaparsec.Internal.pFail @ e @ [GHC.Types.Char] @ m) -}
059fd8b7182da634891771afeb4a2089
  $s$fMonadParsecT_$s$fMonadParsecT_$c>> ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m25 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   (k7 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m25
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b1
                   s1
                   (\ (x :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs6 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k7
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs6
                         cok)
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs6 cerr))
                   cerr
                   (\ (x :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs6 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k7
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs6
                         eok)
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs6 eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
12ffec1991e7383611822a20495df8e9
  $s$fMonadParsecT_$spBind ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> (a -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(C1(U))))))><L,U><L,U><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m25 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   (k7 :: a
                          -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b)
                   @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b1) ->
                 m25
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b1
                   s1
                   (\ (x :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs6 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    (k7 x)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs6
                         cok)
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs6 cerr))
                   cerr
                   (\ (x :: a)
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (hs6 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    (k7 x)
                      `cast`
                    (Text.Megaparsec.Internal.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs6
                         eok)
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs6 eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <a
                       -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m b>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
fc95da5e65c159b0db74c88164faa042
  $s$fMonadParsecesParsecT ::
    Text.Megaparsec.Class.MonadParsec
      Data.Void.Void
      [GHC.Types.Char]
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ Data.Void.Void
                  @ [GHC.Types.Char]
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  Text.Megaparsec.Stream.$fStream[]
                  (Lib.$s$fAlternativeParsecT @ m)
                  (Lib.$s$fMonadParsecesParsecT_$s$fMonadPlusParsecT @ m)
                  (Text.Megaparsec.Internal.pFailure
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pFancyFailure
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Text.Megaparsec.Internal.pLabel
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (\ @ a ->
                   Text.Megaparsec.Internal.pLabel
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     @ a
                     (GHC.Types.[] @ GHC.Types.Char))
                  (Text.Megaparsec.Internal.pTry
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Text.Megaparsec.Internal.pLookAhead
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Lib.$s$fMonadParsecesParsecT_$spNotFollowedBy
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pWithRecovery
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.Internal.pObserving
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (\ @ b
                     (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                     (ds :: ()
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b)
                     (ds1 :: Text.Megaparsec.Error.ParseError
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                     (eok :: ()
                             -> Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             -> m b)
                     (eerr :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                              -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                   case s1 of wild { Text.Megaparsec.State.State input ds2 dt5 w ->
                   case ds2 of wild1 { GHC.Base.:| pos z ->
                   case input of wild2 {
                     []
                     -> eok
                          GHC.Tuple.()
                          wild
                          (GHC.Types.[]
                             @ (Data.Set.Internal.Set
                                  (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                            `cast`
                          (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                    <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                     : t ts
                     -> case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                        eerr
                          (Text.Megaparsec.Error.TrivialError
                             @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             @ Data.Void.Void
                             (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                             (GHC.Base.Just
                                @ (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (Text.Megaparsec.Error.Tokens
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                   (Text.Megaparsec.Internal.nes
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      t `cast`
                                      (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))))))
                             (Data.Set.Internal.$WBin
                                @ (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (GHC.Types.I# 1#)
                                (Text.Megaparsec.Error.EndOfInput
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                (Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char])))))
                          (Text.Megaparsec.State.$WState
                             @ [GHC.Types.Char]
                             wild2
                             (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                             (GHC.Types.I# dt5)
                             w) } } } })
                    `cast`
                  (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                            <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <()>_R))
                  (Lib.$s$fMonadParsecesParsecT_$spToken @ Data.Void.Void @ m)
                  (Lib.$s$fMonadParsecesParsecT_$spTokens @ Data.Void.Void @ m)
                  (Lib.$s$fMonadParsecesParsecT_$spTakeWhileP @ Data.Void.Void @ m)
                  (Lib.$s$fMonadParsecesParsecT_$spTakeWhile1P @ Data.Void.Void @ m)
                  (Lib.$s$fMonadParsecesParsecT_$spTakeP @ Data.Void.Void @ m)
                  (\ @ b
                     (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                     (ds :: Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b)
                     (ds1 :: Text.Megaparsec.Error.ParseError
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                     (eok :: Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.State.State [GHC.Types.Char]
                             -> Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             -> m b)
                     (ds2 :: Text.Megaparsec.Error.ParseError
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                             -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                   eok
                     s1
                     s1
                     (GHC.Types.[]
                        @ (Data.Set.Internal.Set
                             (Text.Megaparsec.Error.ErrorItem
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                       `cast`
                     (Sym (Text.Megaparsec.Internal.N:Hints[0]
                               <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                    `cast`
                  (Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                            <Data.Void.Void>_N
                            <[GHC.Types.Char]>_N
                            <m>_R
                            <Text.Megaparsec.State.State [GHC.Types.Char]>_R))
                  (Text.Megaparsec.Internal.pUpdateParserState
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m) -}
82b326706912b149de67d246aac5b692
  $s$fMonadParsecesParsecT_$s$fMonadPlusParsecT ::
    GHC.Base.MonadPlus
      (Text.Megaparsec.Internal.ParsecT
         Data.Void.Void [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ (Text.Megaparsec.Internal.ParsecT
                       Data.Void.Void [GHC.Types.Char] m)
                  (Lib.$s$fAlternativeParsecT @ m)
                  (Lib.$s$fMonadParsecT @ Data.Void.Void @ m)
                  (Text.Megaparsec.Internal.pZero
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Lib.$s$fAlternativeParsecT_$spPlus @ m) -}
1666d73e154309b6b776a01801036568
  $s$fMonadParsecesParsecT_$spNotFollowedBy ::
    Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m ()
  {- Arity: 6, HasNoCafRefs,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><S(LLSL),1*U(U,U,U,U)><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (p6 :: Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (ds :: ()
                          -> Text.Megaparsec.State.State [GHC.Types.Char]
                          -> Text.Megaparsec.Internal.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: ()
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input pos dt5 ds2 ->
                 let {
                   what :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   = case input of wild1 {
                       []
                       -> Text.Megaparsec.Error.EndOfInput
                            @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                       : t ts
                       -> Text.Megaparsec.Error.Tokens
                            @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            (GHC.Base.:|
                               @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               t `cast` (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))
                               (GHC.Types.[] @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) }
                 } in
                 p6
                   `cast`
                 (Text.Megaparsec.Internal.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   wild
                   (\ (ds3 :: a)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (ds5 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    eerr
                      (Text.Megaparsec.Error.TrivialError
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ e
                         pos
                         (GHC.Base.Just
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            what)
                         (Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                      wild)
                   (\ (ds3 :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    eok
                      GHC.Tuple.()
                      wild
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                   (\ (ds3 :: a)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char])
                      (ds5 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    eerr
                      (Text.Megaparsec.Error.TrivialError
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ e
                         pos
                         (GHC.Base.Just
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            what)
                         (Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                      wild)
                   (\ (ds3 :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e)
                      (ds4 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                    eok
                      GHC.Tuple.()
                      wild
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))) })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <()>_R)) -}
bd03d86f556aba9ace9a7c7b883beff5
  $s$fMonadParsecesParsecT_$spTakeP ::
    GHC.Base.Maybe GHC.Base.String
    -> GHC.Types.Int
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7,
     Strictness: <L,1*U><S(S),1*U(U)><S(LSSL),1*U(U,1*U(U(U,U,U),U),U,U(U))><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Base.Maybe GHC.Base.String)
                   (n20 :: GHC.Types.Int)
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds1 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input ds2 dt5 w ->
                 case ds2 of wild1 { GHC.Base.:| pos z ->
                 let {
                   ps :: Data.Set.Internal.Set
                           (Text.Megaparsec.Error.ErrorItem
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   = case ml of wild2 {
                       GHC.Base.Nothing
                       -> Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                       GHC.Base.Just x
                       -> case x of wild3 {
                            []
                            -> Data.Set.Internal.Tip
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            : a1 as3
                            -> Data.Set.Internal.$WBin
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                 (GHC.Types.I# 1#)
                                 (Text.Megaparsec.Error.Label
                                    @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                    (GHC.Base.:| @ GHC.Types.Char a1 as3))
                                 (Data.Set.Internal.Tip
                                    @ (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 (Data.Set.Internal.Tip
                                    @ (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) } }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$ctakeN_
                        n20
                        input of wild2 {
                   GHC.Base.Nothing
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos pos z)
                           (GHC.Base.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.EndOfInput
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                           ps)
                        wild
                   GHC.Base.Just ds3
                   -> case ds3 of wild3 { (,) ts input' ->
                      case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                             (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                             w
                             pos
                             ts of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                      case pos of apos { Text.Megaparsec.Pos.SourcePos ipv3 ipv4 ipv5 ->
                      let {
                        len :: GHC.Types.Int
                        = case GHC.List.$wlenAcc
                                 @ GHC.Types.Char
                                 ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                 0# of ww2 { DEFAULT ->
                          GHC.Types.I# ww2 }
                      } in
                      case GHC.Classes.neInt len n20 of wild4 {
                        GHC.Types.False
                        -> cok
                             ts
                             (case len of wild5 { GHC.Types.I# y ->
                              Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                input'
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                                (GHC.Types.I# (GHC.Prim.+# dt5 y))
                                w })
                             (GHC.Types.[]
                                @ (Data.Set.Internal.Set
                                     (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                               `cast`
                             (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                       <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                        GHC.Types.True
                        -> eerr
                             (Text.Megaparsec.Error.TrivialError
                                @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                @ e
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                                (GHC.Base.Just
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   (Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                ps)
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                input
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                                (GHC.Types.I# dt5)
                                w) } } } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Maybe GHC.Base.String>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
a7a4006f7d067195c96297860bc5c2fd
  $s$fMonadParsecesParsecT_$spTakeWhile1P ::
    GHC.Base.Maybe GHC.Base.String
    -> (Text.Megaparsec.Stream.Token [GHC.Types.Char]
        -> GHC.Types.Bool)
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,1*U><L,C(U)>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Base.Maybe GHC.Base.String)
                   (f :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                         -> GHC.Types.Bool)
                   @ b
                   (ds :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds2 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case ds of wild { Text.Megaparsec.State.State input ds3 dt5 w ->
                 case ds3 of wild1 { GHC.Base.:| pos z ->
                 let {
                   el2 :: GHC.Base.Maybe
                            (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   = case ml of wild2 {
                       GHC.Base.Nothing
                       -> GHC.Base.Nothing
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                       GHC.Base.Just x
                       -> case x of wild3 {
                            []
                            -> GHC.Base.Nothing
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            : a1 as3
                            -> GHC.Base.Just
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                 (Text.Megaparsec.Error.Label
                                    @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                    (GHC.Base.:| @ GHC.Types.Char a1 as3)) } }
                 } in
                 let {
                   ds4 :: ([GHC.Types.Char], [GHC.Types.Char])
                   = GHC.List.span
                       @ GHC.Types.Char
                       f `cast`
                       (Sub (Text.Megaparsec.Stream.D:R:Token[][0])
                        ->_R <GHC.Types.Bool>_R)
                       input
                 } in
                 let {
                   ts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                   = case ds4
                            `cast`
                          ((,)
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                             <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                     ts1 }
                 } in
                 case ds4
                        `cast`
                      ((,)
                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                         <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                 case ts1
                        `cast`
                      (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild4 {
                   []
                   -> case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                      eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                           (GHC.Base.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (case input of wild5 {
                                 []
                                 -> Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                 : t ts2
                                 -> Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.Internal.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         t `cast`
                                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))) }))
                           (case el2 of wild3 {
                              GHC.Base.Nothing
                              -> Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              GHC.Base.Just x
                              -> Data.Set.Internal.singleton
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   x }))
                        (Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                           (GHC.Types.I# dt5)
                           w) }
                   : ds7 ds8
                   -> case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                             (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                             w
                             pos
                             ts of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                      cok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                           (GHC.Types.I# (GHC.Prim.+# dt5 ww2))
                           w })
                        (case el2 of wild3 {
                           GHC.Base.Nothing
                           -> (GHC.Types.[]
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                `cast`
                              (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                        <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           GHC.Base.Just l
                           -> (GHC.Base.build
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 (\ @ a1
                                    (c :: Data.Set.Internal.Set
                                            (Text.Megaparsec.Error.ErrorItem
                                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                          -> a1 -> a1)[OneShot]
                                    (n20 :: a1)[OneShot] ->
                                  c (Data.Set.Internal.singleton
                                       @ (Text.Megaparsec.Error.ErrorItem
                                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                       l)
                                    n20))
                                `cast`
                              (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                        <Text.Megaparsec.Stream.Token
                                           [GHC.Types.Char]>_N)) }) } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Maybe GHC.Base.String>_R
                 ->_R <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                       -> GHC.Types.Bool>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
f7cd41bd2654ff9c95cac04ff928e1ff
  $s$fMonadParsecesParsecT_$spTakeWhileP ::
    GHC.Base.Maybe GHC.Base.String
    -> (Text.Megaparsec.Stream.Token [GHC.Types.Char]
        -> GHC.Types.Bool)
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7,
     Strictness: <L,1*U><L,C(U)><S(SS(S(LSS)L)LL),1*U(1*U,1*U(1*U(U,U,U),U),U,U(U))><L,1*C1(C1(C1(U)))><L,A><L,1*C1(C1(C1(U)))><L,A>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Base.Maybe GHC.Base.String)
                   (f :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                         -> GHC.Types.Bool)
                   @ b
                   (ds :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds2 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case ds of wild { Text.Megaparsec.State.State input ds3 dt5 w ->
                 case ds3 of wild1 { GHC.Base.:| pos z ->
                 let {
                   hs6 :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   = case ml of wild2 {
                       GHC.Base.Nothing
                       -> (GHC.Types.[]
                             @ (Data.Set.Internal.Set
                                  (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                            `cast`
                          (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                    <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                       GHC.Base.Just x
                       -> case x of wild3 {
                            []
                            -> (GHC.Types.[]
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                            : a1 as3
                            -> (GHC.Base.build
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                  (\ @ a2
                                     (c :: Data.Set.Internal.Set
                                             (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                           -> a2 -> a2)[OneShot]
                                     (n20 :: a2)[OneShot] ->
                                   c (Data.Set.Internal.$WBin
                                        @ (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                        (GHC.Types.I# 1#)
                                        (Text.Megaparsec.Error.Label
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           (GHC.Base.:| @ GHC.Types.Char a1 as3))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                     n20))
                                 `cast`
                               (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) } }
                 } in
                 let {
                   ds4 :: ([GHC.Types.Char], [GHC.Types.Char])
                   = GHC.List.span
                       @ GHC.Types.Char
                       f `cast`
                       (Sub (Text.Megaparsec.Stream.D:R:Token[][0])
                        ->_R <GHC.Types.Bool>_R)
                       input
                 } in
                 let {
                   ts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                   = case ds4
                            `cast`
                          ((,)
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                             <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                     ts1 }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                        (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                        w
                        pos
                        ts of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                 case ds4
                        `cast`
                      ((,)
                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                         <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                 case ts1
                        `cast`
                      (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild4 {
                   []
                   -> eok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                           (GHC.Types.I# (GHC.Prim.+# dt5 ww2))
                           w })
                        hs6
                   : ds7 ds8
                   -> cok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.State.$WState
                           @ [GHC.Types.Char]
                           input'
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                           (GHC.Types.I# (GHC.Prim.+# dt5 ww2))
                           w })
                        hs6 } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Maybe GHC.Base.String>_R
                 ->_R <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                       -> GHC.Types.Bool>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
2e2bb7bb21d139ac3fc8d03c9be7b6a7
  $s$fMonadParsecesParsecT_$spToken ::
    (Text.Megaparsec.Stream.Token [GHC.Types.Char]
     -> Data.Either.Either
          (GHC.Base.Maybe
             (Text.Megaparsec.Error.ErrorItem
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])),
           Data.Set.Internal.Set
             (Text.Megaparsec.Error.ErrorItem
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
          a)
    -> GHC.Base.Maybe (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Internal.ParsecT e [GHC.Types.Char] m a
  {- Arity: 2, Strictness: <L,C(U)><L,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (test :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                            -> Data.Either.Either
                                 (GHC.Base.Maybe
                                    (Text.Megaparsec.Error.ErrorItem
                                       (Text.Megaparsec.Stream.Token [GHC.Types.Char])),
                                  Data.Set.Internal.Set
                                    (Text.Megaparsec.Error.ErrorItem
                                       (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 a)
                   (mtoken :: GHC.Base.Maybe
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (ds1 :: a
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input ds2 dt5 w ->
                 case ds2 of wild1 { GHC.Base.:| pos z ->
                 case input of wild2 {
                   []
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos pos z)
                           (GHC.Base.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.EndOfInput
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                           (case mtoken of wild3 {
                              GHC.Base.Nothing
                              -> Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              GHC.Base.Just x
                              -> Data.Set.Internal.$WBin
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   (GHC.Types.I# 1#)
                                   (Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.Internal.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         x))
                                   (Data.Set.Internal.Tip
                                      @ (Text.Megaparsec.Error.ErrorItem
                                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                   (Data.Set.Internal.Tip
                                      @ (Text.Megaparsec.Error.ErrorItem
                                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) }))
                        wild
                   : t ts
                   -> case test
                             t `cast`
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))) of wild4 {
                        Data.Either.Left ds4
                        -> case ds4 of wild5 { (,) us ps ->
                           case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           eerr
                             (Text.Megaparsec.Error.TrivialError
                                @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                @ e
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                                us
                                ps)
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                wild2
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                                (GHC.Types.I# dt5)
                                w) } }
                        Data.Either.Right x
                        -> case Text.Megaparsec.Stream.$fStream[]_$cadvance1
                                  (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                                  w
                                  pos
                                  t `cast`
                                  (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))) of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           cok
                             x
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                ts
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                                (GHC.Types.I# (GHC.Prim.+# dt5 1#))
                                w)
                             (GHC.Types.[]
                                @ (Data.Set.Internal.Set
                                     (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                               `cast`
                             (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                       <Text.Megaparsec.Stream.Token
                                          [GHC.Types.Char]>_N)) } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                  -> Data.Either.Either
                       (GHC.Base.Maybe
                          (Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])),
                        Data.Set.Internal.Set
                          (Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                       a>_R
                 ->_R <GHC.Base.Maybe
                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
e22328e72969c01ba5d71c0ce03fee4f
  $s$fMonadParsecesParsecT_$spTokens ::
    (Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
     -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
     -> GHC.Types.Bool)
    -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> Text.Megaparsec.Internal.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,C(C1(U))><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (f :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                         -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                         -> GHC.Types.Bool)
                   (tts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
                   @ b
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                          -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b)
                   (eok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State.State input ds1 dt5 w ->
                 case ds1 of wild1 { GHC.Base.:| pos z ->
                 let {
                   unexpect :: GHC.Base.NonEmpty Text.Megaparsec.Pos.SourcePos
                               -> Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                     {- Arity: 2 -}
                   = \ (pos' :: GHC.Base.NonEmpty Text.Megaparsec.Pos.SourcePos)
                       (u :: Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                     Text.Megaparsec.Error.TrivialError
                       @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                       @ e
                       pos'
                       (GHC.Base.Just
                          @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          u)
                       (Data.Set.Internal.$WBin
                          @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          (GHC.Types.I# 1#)
                          (Text.Megaparsec.Error.Tokens
                             @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             (case tts
                                     `cast`
                                   (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]) ; ([Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))])_R) of wild2 {
                                []
                                -> Data.List.NonEmpty.cycle1
                                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                : a1 as3
                                -> GHC.Base.:|
                                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                     a1
                                     as3 }))
                          (Data.Set.Internal.Tip
                             @ (Text.Megaparsec.Error.ErrorItem
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                          (Data.Set.Internal.Tip
                             @ (Text.Megaparsec.Error.ErrorItem
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                 } in
                 let {
                   len :: GHC.Types.Int
                   = case GHC.List.$wlenAcc
                            @ GHC.Types.Char
                            tts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                            0# of ww2 { DEFAULT ->
                     GHC.Types.I# ww2 }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$ctakeN_
                        len
                        input of wild2 {
                   GHC.Base.Nothing
                   -> eerr
                        (unexpect
                           (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos pos z)
                           (Text.Megaparsec.Error.EndOfInput
                              @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                        wild
                   GHC.Base.Just ds2
                   -> case ds2 of wild3 { (,) tts' input' ->
                      case f tts tts' of wild4 {
                        GHC.Types.False
                        -> case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           eerr
                             (unexpect
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                                (Text.Megaparsec.Error.Tokens
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                   (case tts'
                                           `cast`
                                         (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]) ; ([Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))])_R) of wild5 {
                                      []
                                      -> Data.List.NonEmpty.cycle1
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      : a1 as3
                                      -> GHC.Base.:|
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           a1
                                           as3 })))
                             (Text.Megaparsec.State.$WState
                                @ [GHC.Types.Char]
                                input
                                (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos apos z)
                                (GHC.Types.I# dt5)
                                w) }
                        GHC.Types.True
                        -> case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                                  (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                                  w
                                  pos
                                  tts' of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           let {
                             st :: Text.Megaparsec.State.State [GHC.Types.Char]
                             = case len of wild5 { GHC.Types.I# y ->
                               Text.Megaparsec.State.$WState
                                 @ [GHC.Types.Char]
                                 input'
                                 (GHC.Base.:| @ Text.Megaparsec.Pos.SourcePos npos z)
                                 (GHC.Types.I# (GHC.Prim.+# dt5 y))
                                 w }
                           } in
                           case tts
                                  `cast`
                                (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild7 {
                             []
                             -> eok
                                  tts'
                                  st
                                  (GHC.Types.[]
                                     @ (Data.Set.Internal.Set
                                          (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                    `cast`
                                  (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                            <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                             : ds4 ds5
                             -> cok
                                  tts'
                                  st
                                  (GHC.Types.[]
                                     @ (Data.Set.Internal.Set
                                          (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                    `cast`
                                  (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                            <Text.Megaparsec.Stream.Token
                                               [GHC.Types.Char]>_N)) } } } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                  -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                  -> GHC.Types.Bool>_R
                 ->_R <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R
                 ->_R Sym (Text.Megaparsec.Internal.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
5908dfb45a8690438b46331a2c1316bd
  $s$fOrdErrorFancy ::
    GHC.Classes.Ord (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                  Lib.$s$fEqErrorFancy
                  (Text.Megaparsec.Error.$fOrdErrorFancy_$ccompare
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid)
                  (Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid)
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          b
                          a of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid
                     b
                     a)
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          y
                          x of wild {
                     GHC.Types.False -> y GHC.Types.True -> x })
                  (\ (x :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          y
                          x of wild {
                     GHC.Types.False -> x GHC.Types.True -> y }) -}
7cd8f89c55814cf2b519454be8e87bef
  $s$fOrdErrorFancy_$c<= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        b
                        a of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e1c61682eb11645c1b242ac959fcb456
  $s$fOrdErrorFancy_$c>= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
29b636d011d7e366fee3d30097c4be7f
  $s$fOrdErrorFancy_$cmax ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        y
                        x of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
340dc9207de0e4ae10aad235bab48027
  $s$fOrdErrorFancy_$cmin ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        y
                        x of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
73fea266b231672456110a60f97376a7
  $s$fOrdErrorItem ::
    GHC.Classes.Ord
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorItem
                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                  Lib.$s$fEqErrorItem
                  (Text.Megaparsec.Error.$fOrdErrorItem_$ccompare
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  (Text.Megaparsec.Error.$fOrdErrorItem_$c<
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          b
                          a of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   Text.Megaparsec.Error.$fOrdErrorItem_$c<
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                     b
                     a)
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (y :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          y
                          x of wild {
                     GHC.Types.False -> y GHC.Types.True -> x })
                  (\ (x :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (y :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          y
                          x of wild {
                     GHC.Types.False -> x GHC.Types.True -> y }) -}
c58fb889ba633a729f005b6e6b31d254
  $s$fOrdErrorItem_$c<= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (b :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        b
                        a of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
aff68cf67a74a040a12235196cb93cf1
  $s$fOrdErrorItem_$c>= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (b :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e4e4a4ceb31ec1be390e69bb9f209e03
  $s$fOrdErrorItem_$cmax ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        y
                        x of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
b2886ab8fb1dcc816e355b7a6737ef0c
  $s$fOrdErrorItem_$cmin ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        y
                        x of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
5d8a753bd65d387519261ffc20a41eb3
  $sinsertR_go3 ::
    GHC.Classes.Ord a1 =>
    a1 -> a1 -> Data.Set.Internal.Set a1 -> Data.Set.Internal.Set a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U><S,1*U> -}
9cdc3a72eb44943a7c1708c04568bebc
  $sinsert_go3 ::
    GHC.Classes.Ord a1 =>
    a1 -> a1 -> Data.Set.Internal.Set a1 -> Data.Set.Internal.Set a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U><S,1*U> -}
2ed2d2162b890ad1474f01967dd01a96
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule3 Lib.$trModule1) -}
d9ba78fbc62bac9a0b72e4d1a292c093
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$trModule2) -}
c54294e38d3820cc5cd5f406f9c2113b
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Lib"#) -}
7781e8b91b5940f0f443f1661cf35859
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$trModule4) -}
bb57f64569bcb184dd46b2ef7ecf5eb4
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("client-0.1.0.0-2otZ1nLTSSxDNDXeH3pKHr"#) -}
1d96f22deca046874aa66f1cde38847f
  $w$sspace ::
    Text.Megaparsec.Internal.ParsecT
      Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> Text.Megaparsec.Internal.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> forall b.
       Text.Megaparsec.State.State GHC.Base.String
       -> (()
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token GHC.Base.String)
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Data.Functor.Identity.Identity b)
       -> (()
           -> Text.Megaparsec.State.State GHC.Base.String
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token GHC.Base.String)
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U(U,U(U(U,U,U),U),U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [0] -}
47014d3cda4ffd84991e7857431ca21f
  $wgo ::
    ([Messages.Statement] -> [Messages.Statement])
    -> forall b.
       [GHC.Types.Char]
       -> GHC.IO.FilePath
       -> GHC.Prim.Int#
       -> GHC.Prim.Int#
       -> [Text.Megaparsec.Pos.SourcePos]
       -> GHC.Prim.Int#
       -> Text.Megaparsec.Pos.Pos
       -> (([Messages.Statement] -> [Messages.Statement])
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (([Messages.Statement] -> [Messages.Statement])
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 10,
     Strictness: <L,U><S,U><L,U><S,U><S,U><L,U><S,U><L,U(U)><L,C(C1(C1(U)))><L,C(C1(C1(U)))>,
     Inline: [0] -}
d38cd00f612b613f26a771ca31d1d8ce
  type Parser =
    Text.Megaparsec.Parsec Data.Void.Void GHC.Base.String :: * -> *
a12bb20eb5f244bebd7be298147dc114
  parseScript ::
    GHC.Base.String
    -> Data.Either.Either GHC.Base.String Messages.Program
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (input :: GHC.Base.String) ->
                 case (Lib.parseScript8
                         @ (Text.Megaparsec.Internal.Reply
                              Data.Void.Void GHC.Base.String Messages.Program)
                         (Text.Megaparsec.State.State
                            @ GHC.Base.String
                            input
                            Lib.parseScript6
                            0#
                            Text.Megaparsec.Pos.defaultTabWidth_a
                              `cast`
                            (Sym (Text.Megaparsec.Pos.N:Pos[0])))
                         Lib.parseScript5
                           `cast`
                         (<Messages.Program>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R <Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token GHC.Base.String)>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void GHC.Base.String Messages.Program>_R))
                         Lib.parseScript4
                           `cast`
                         (<Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void GHC.Base.String Messages.Program>_R))
                         Lib.parseScript3
                           `cast`
                         (<Messages.Program>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R <Text.Megaparsec.Internal.Hints
                                  (Text.Megaparsec.Stream.Token GHC.Base.String)>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void GHC.Base.String Messages.Program>_R))
                         Lib.parseScript2
                           `cast`
                         (<Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void>_R
                          ->_R <Text.Megaparsec.State.State GHC.Base.String>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Internal.Reply
                                           Data.Void.Void GHC.Base.String Messages.Program>_R)))
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Text.Megaparsec.Internal.Reply
                              Data.Void.Void
                              GHC.Base.String
                              Messages.Program>_R) of wild { Text.Megaparsec.Internal.Reply s' ds result ->
                 case result of wild1 {
                   Text.Megaparsec.Internal.OK x
                   -> Data.Either.Right @ GHC.Base.String @ Messages.Program x
                   Text.Megaparsec.Internal.Error e1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ Messages.Program
                        (Lib.parseScript1
                           Text.Megaparsec.Error.$fDataErrorItem3
                           e1
                             `cast`
                           (Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.D:R:Token[][0]) <Data.Void.Void>_N)_R
                           (GHC.Types.[] @ GHC.Types.Char)) } }) -}
6bf031555bc3dbcabf6eb6485db96877
  parseScript1 ::
    GHC.Types.Int
    -> Text.Megaparsec.Error.ParseError GHC.Types.Char Data.Void.Void
    -> GHC.Show.ShowS
  {- Unfolding: (Text.Megaparsec.Error.$fShowParseError_$cshowsPrec
                   @ GHC.Types.Char
                   @ Data.Void.Void
                   GHC.Show.$fShowChar
                   Data.Void.$fShowVoid) -}
bc991116549f3a614de85255e9d8e2d4
  parseScript10 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (Messages.Expression
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> (Messages.Expression
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U(U,U(U(U,U,U),U),U,U(U))><L,C(U)><L,C(C1(U))><L,C(C1(C1(U)))><L,C(C1(U))> -}
81ae46e72f73e5bfd34b9877b0c6bea5
  parseScript11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.parseScript12) -}
78a0f6fb7d1180a3e90c1445b4831222
  parseScript12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("return"#) -}
522edf587e1201a8dabf88f53990d11e
  parseScript13 ::
    GHC.Base.String
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> (()
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> (()
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <S,U><S(SS(S(LSS)L)LL),1*U(1*U,1*U(1*U(U,U,U),U),U,U(U))><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
d90170393645614898e9a9c683d8cf32
  parseScript2 ::
    Text.Megaparsec.Error.ParseError
      (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String Messages.Program
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: (\ (err :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String) ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ Messages.Program
                   s'
                   Text.Megaparsec.Internal.Virgin
                   (Text.Megaparsec.Internal.Error
                      @ (Text.Megaparsec.Stream.Token GHC.Base.String)
                      @ Data.Void.Void
                      @ Messages.Program
                      err)) -}
2162ae69e218795165a2cac4c67ae3fa
  parseScript3 ::
    Messages.Program
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Hints
         (Text.Megaparsec.Stream.Token GHC.Base.String)
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String Messages.Program
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,A>m,
     Unfolding: (\ (a1 :: Messages.Program)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String)[OneShot]
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token GHC.Base.String))[OneShot] ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ Messages.Program
                   s'
                   Text.Megaparsec.Internal.Virgin
                   (Text.Megaparsec.Internal.OK
                      @ (Text.Megaparsec.Stream.Token GHC.Base.String)
                      @ Data.Void.Void
                      @ Messages.Program
                      a1)) -}
67c75160171a6de91fcf7420f8d5dd03
  parseScript4 ::
    Text.Megaparsec.Error.ParseError
      (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String Messages.Program
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: (\ (err :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String) ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ Messages.Program
                   s'
                   Text.Megaparsec.Internal.Consumed
                   (Text.Megaparsec.Internal.Error
                      @ (Text.Megaparsec.Stream.Token GHC.Base.String)
                      @ Data.Void.Void
                      @ Messages.Program
                      err)) -}
4f59b9259d9c514ad1a95d70deda2711
  parseScript5 ::
    Messages.Program
    -> Text.Megaparsec.State.State GHC.Base.String
    -> Text.Megaparsec.Internal.Hints
         (Text.Megaparsec.Stream.Token GHC.Base.String)
    -> Text.Megaparsec.Internal.Reply
         Data.Void.Void GHC.Base.String Messages.Program
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,A>m,
     Unfolding: (\ (a1 :: Messages.Program)
                   (s' :: Text.Megaparsec.State.State GHC.Base.String)[OneShot]
                   (ds :: Text.Megaparsec.Internal.Hints
                            (Text.Megaparsec.Stream.Token GHC.Base.String))[OneShot] ->
                 Text.Megaparsec.Internal.Reply
                   @ Data.Void.Void
                   @ GHC.Base.String
                   @ Messages.Program
                   s'
                   Text.Megaparsec.Internal.Consumed
                   (Text.Megaparsec.Internal.OK
                      @ (Text.Megaparsec.Stream.Token GHC.Base.String)
                      @ Data.Void.Void
                      @ Messages.Program
                      a1)) -}
291b3f93357225c064b9c21bf278af5d
  parseScript6 :: GHC.Base.NonEmpty Text.Megaparsec.Pos.SourcePos
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Base.:|
                   @ Text.Megaparsec.Pos.SourcePos
                   Lib.parseScript7
                   (GHC.Types.[] @ Text.Megaparsec.Pos.SourcePos)) -}
f03c629c12540982a20791b794121334
  parseScript7 :: Text.Megaparsec.Pos.SourcePos
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Text.Megaparsec.Pos.SourcePos
                   (GHC.Types.[] @ GHC.Types.Char)
                   1#
                   1#) -}
4df9777646a5ddce535e06c599fd8fba
  parseScript8 ::
    Text.Megaparsec.State.State [GHC.Types.Char]
    -> (Messages.Program
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (Messages.Program
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Text.Megaparsec.Internal.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <S(SS(S(LSS)L)SL),1*U(U,1*U(1*U(U,U,U),U),U,U(U))><L,C(C1(C1(U)))><L,C(U)><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   (s1 :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (cok :: Messages.Program
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> Data.Functor.Identity.Identity b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Data.Functor.Identity.Identity b1)
                   (eok :: Messages.Program
                           -> Text.Megaparsec.State.State [GHC.Types.Char]
                           -> Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> Data.Functor.Identity.Identity b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Data.Functor.Identity.Identity b1) ->
                 case s1 of ww { Text.Megaparsec.State.State ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { GHC.Base.:| ww6 ww7 ->
                 case ww6 of ww8 { Text.Megaparsec.Pos.SourcePos ww9 ww10 ww11 ->
                 Lib.$wgo
                   (GHC.Base.id @ [Messages.Statement])
                   @ b1
                   ww1
                   ww9
                   ww10
                   ww11
                   ww7
                   ww3
                   ww4
                   (\ (x :: [Messages.Statement] -> [Messages.Statement])
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs6 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    Lib.parseScript9
                      (x (GHC.Types.[] @ Messages.Statement))
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ Messages.Program
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs6
                         cok)
                      (Lib.$s$fAlternativeParsecT_$swithHints
                         @ Data.Void.Void
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs6
                         cerr))
                   (\ (x :: [Messages.Statement] -> [Messages.Statement])
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs6 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    Lib.parseScript9
                      (x (GHC.Types.[] @ Messages.Statement))
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.Internal.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ Messages.Program
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs6
                         eok)
                      (Lib.$s$fAlternativeParsecT_$swithHints
                         @ Data.Void.Void
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs6
                         eerr)) } } }) -}
cccaf1c5199d18befb51cfc27d7f9182
  parseScript9 ::
    [Messages.Statement]
    -> forall b.
       Text.Megaparsec.State.State [GHC.Types.Char]
       -> (Messages.Program
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> (Messages.Program
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Text.Megaparsec.Internal.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><S(SS(S(LSS)L)LL),U(U,U(U(U,U,U),U),U,U(U))><L,C(C1(C1(U)))><L,A><L,C(C1(C1(U)))><L,C(C1(U))>,
     Unfolding: (\ (statement :: [Messages.Statement])
                   @ b
                   (eta :: Text.Megaparsec.State.State [GHC.Types.Char])
                   (eta1 :: Messages.Program
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> Data.Functor.Identity.Identity b)
                   (eta2 :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Messages.Program
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Data.Functor.Identity.Identity b) ->
                 let {
                   eerr' :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Data.Functor.Identity.Identity b
                     {- Arity: 2, Strictness: <L,U><L,A>,
                        Unfolding: InlineRule (2, True, True)
                                   (\ (err :: Text.Megaparsec.Error.ParseError
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                                Data.Void.Void)
                                      (ds1 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                                    eta4 err eta) -}
                   = \ (err :: Text.Megaparsec.Error.ParseError
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void)
                       (ds1 :: Text.Megaparsec.State.State [GHC.Types.Char]) ->
                     eta4 err eta
                 } in
                 let {
                   lvl66 :: Messages.Expression
                            -> Text.Megaparsec.State.State [GHC.Types.Char]
                            -> Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> Data.Functor.Identity.Identity b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ (x :: Messages.Expression)
                       (s' :: Text.Megaparsec.State.State [GHC.Types.Char])
                       (hs6 :: Text.Megaparsec.Internal.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                     eta1
                       (Messages.Program statement (Messages.ReturnStatement x))
                       s'
                       hs6
                 } in
                 Lib.parseScript13
                   Lib.parseScript11
                   @ b
                   eta
                   (\ (x :: ())
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs6 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    Lib.parseScript10
                      @ b
                      s'
                      lvl66
                      eerr'
                      (\ (x1 :: Messages.Expression)
                         (s'1 :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                         (hs7 :: Text.Megaparsec.Internal.Hints
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                       eta1
                         (Messages.Program statement (Messages.ReturnStatement x1))
                         s'1
                         (GHC.Base.++
                            @ (Data.Set.Internal.Set
                                 (Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                            hs6
                              `cast`
                            (Text.Megaparsec.Internal.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)
                            hs7
                              `cast`
                            (Text.Megaparsec.Internal.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                   <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                      (Lib.$s$fAlternativeParsecT_$swithHints
                         @ Data.Void.Void
                         @ Data.Functor.Identity.Identity
                         @ b
                         hs6
                         eerr'))
                   eerr'
                   (\ (x :: ())
                      (s' :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                      (hs6 :: Text.Megaparsec.Internal.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    Lib.parseScript10
                      @ b
                      s'
                      lvl66
                      eerr'
                      (\ (x1 :: Messages.Expression)
                         (s'1 :: Text.Megaparsec.State.State [GHC.Types.Char])[OneShot]
                         (hs7 :: Text.Megaparsec.Internal.Hints
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                       eta3
                         (Messages.Program statement (Messages.ReturnStatement x1))
                         s'1
                         (GHC.Base.++
                            @ (Data.Set.Internal.Set
                                 (Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                            hs6
                              `cast`
                            (Text.Megaparsec.Internal.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)
                            hs7
                              `cast`
                            (Text.Megaparsec.Internal.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           `cast`
                         (Sym (Text.Megaparsec.Internal.N:Hints[0]
                                   <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                      (Lib.$s$fAlternativeParsecT_$swithHints
                         @ Data.Void.Void
                         @ Data.Functor.Identity.Identity
                         @ b
                         hs6
                         eerr'))
                   eerr') -}
"SPEC/Lib $fAlternativeParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                         -> *
                                                                  (v1 :: Text.Megaparsec.Stream.Stream
                                                                           [GHC.Types.Char])
                                                                  (v :: GHC.Classes.Ord
                                                                          Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT @ Data.Void.Void
                                                @ [GHC.Types.Char]
                                                @ m
                                                v
                                                v1
  = Lib.$s$fAlternativeParsecT @ m
"SPEC/Lib $fAlternativeParsecT1 @ Void @ [Char] _" [orphan] [0] forall @ m :: *
                                                                              -> *
                                                                       (w1 :: Text.Megaparsec.Stream.Stream
                                                                                [GHC.Types.Char])
                                                                       (w :: GHC.Classes.Ord
                                                                               Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT1 @ Data.Void.Void
                                                 @ [GHC.Types.Char]
                                                 @ m
                                                 w
                                                 w1
  = Lib.$s$fAlternativeParsecT1 @ m
"SPEC/Lib $fAlternativeParsecT3 @ Void @ [Char] _" [orphan] [0] forall @ m :: *
                                                                              -> *
                                                                       (w1 :: Text.Megaparsec.Stream.Stream
                                                                                [GHC.Types.Char])
                                                                       (w :: GHC.Classes.Ord
                                                                               Data.Void.Void)
  Text.Megaparsec.Internal.$fAlternativeParsecT3 @ Data.Void.Void
                                                 @ [GHC.Types.Char]
                                                 @ m
                                                 w
                                                 w1
  = Lib.$s$fAlternativeParsecT3 @ m
"SPEC/Lib $fApplicativeParsecT @ [Char] _ _" [orphan] forall @ e
                                                             @ m :: * -> *
                                                             (v :: Text.Megaparsec.Stream.Stream
                                                                     [GHC.Types.Char])
  Text.Megaparsec.Internal.$fApplicativeParsecT @ [GHC.Types.Char]
                                                @ e
                                                @ m
                                                v
  = Lib.$s$fAlternativeParsecT_$s$fApplicativeParsecT @ e @ m
"SPEC/Lib $fEqErrorFancy @ Void" [orphan] forall (v :: GHC.Classes.Eq
                                                         Data.Void.Void)
  Text.Megaparsec.Error.$fEqErrorFancy @ Data.Void.Void v
  = Lib.$s$fEqErrorFancy
"SPEC/Lib $fEqErrorFancy_$c/= @ Void" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                 Data.Void.Void)
  Text.Megaparsec.Error.$fEqErrorFancy_$c/= @ Data.Void.Void $dEq
  = Lib.$s$fEqErrorFancy_$s$fEqErrorFancy_$c/=
"SPEC/Lib $fEqErrorItem @ (Token [Char])" [orphan] forall (v :: GHC.Classes.Eq
                                                                  (Text.Megaparsec.Stream.Token
                                                                     [GHC.Types.Char]))
  Text.Megaparsec.Error.$fEqErrorItem @ (Text.Megaparsec.Stream.Token
                                           [GHC.Types.Char])
                                      v
  = Lib.$s$fEqErrorItem
"SPEC/Lib $fEqErrorItem_$c/= @ (Token [Char])" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                          (Text.Megaparsec.Stream.Token
                                                                             [GHC.Types.Char]))
  Text.Megaparsec.Error.$fEqErrorItem_$c/= @ (Text.Megaparsec.Stream.Token
                                                [GHC.Types.Char])
                                           $dEq
  = Lib.$s$fEqErrorItem_$s$fEqErrorItem_$c/=
"SPEC/Lib $fMonadParsecT @ [Char] _ _" [orphan] forall @ e
                                                       @ m :: * -> *
                                                       (v :: Text.Megaparsec.Stream.Stream
                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.$fMonadParsecT @ [GHC.Types.Char]
                                          @ e
                                          @ m
                                          v
  = Lib.$s$fMonadParsecT @ e @ m
"SPEC/Lib $fMonadParsecT_$c>> @ [Char] _ _" [orphan] forall @ e
                                                            @ m :: * -> *
                                                            ($dStream :: Text.Megaparsec.Stream.Stream
                                                                           [GHC.Types.Char])
  Text.Megaparsec.Internal.$fMonadParsecT_$c>> @ [GHC.Types.Char]
                                               @ e
                                               @ m
                                               $dStream
  = Lib.$s$fMonadParsecT_$s$fMonadParsecT_$c>> @ e @ m
"SPEC/Lib $fMonadParsecesParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                           -> *
                                                                    (v1 :: Text.Megaparsec.Stream.Stream
                                                                             [GHC.Types.Char])
                                                                    (v :: GHC.Classes.Ord
                                                                            Data.Void.Void)
  Text.Megaparsec.Internal.$fMonadParsecesParsecT @ Data.Void.Void
                                                  @ [GHC.Types.Char]
                                                  @ m
                                                  v
                                                  v1
  = Lib.$s$fMonadParsecesParsecT @ m
"SPEC/Lib $fMonadPlusParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                       -> *
                                                                (v1 :: Text.Megaparsec.Stream.Stream
                                                                         [GHC.Types.Char])
                                                                (v :: GHC.Classes.Ord
                                                                        Data.Void.Void)
  Text.Megaparsec.Internal.$fMonadPlusParsecT @ Data.Void.Void
                                              @ [GHC.Types.Char]
                                              @ m
                                              v
                                              v1
  = Lib.$s$fMonadParsecesParsecT_$s$fMonadPlusParsecT @ m
"SPEC/Lib $fOrdErrorFancy @ Void" [orphan] forall (v :: GHC.Classes.Ord
                                                          Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy @ Data.Void.Void v
  = Lib.$s$fOrdErrorFancy
"SPEC/Lib $fOrdErrorFancy_$c<= @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                   Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$c<= @ Data.Void.Void $dOrd
  = Lib.$s$fOrdErrorFancy_$c<=
"SPEC/Lib $fOrdErrorFancy_$c>= @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                   Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$c>= @ Data.Void.Void $dOrd
  = Lib.$s$fOrdErrorFancy_$c>=
"SPEC/Lib $fOrdErrorFancy_$cmax @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                    Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$cmax @ Data.Void.Void $dOrd
  = Lib.$s$fOrdErrorFancy_$cmax
"SPEC/Lib $fOrdErrorFancy_$cmin @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                    Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$cmin @ Data.Void.Void $dOrd
  = Lib.$s$fOrdErrorFancy_$cmin
"SPEC/Lib $fOrdErrorItem @ (Token [Char])" [orphan] forall (v :: GHC.Classes.Ord
                                                                   (Text.Megaparsec.Stream.Token
                                                                      [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem @ (Text.Megaparsec.Stream.Token
                                            [GHC.Types.Char])
                                       v
  = Lib.$s$fOrdErrorItem
"SPEC/Lib $fOrdErrorItem_$c<= @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                            (Text.Megaparsec.Stream.Token
                                                                               [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$c<= @ (Text.Megaparsec.Stream.Token
                                                 [GHC.Types.Char])
                                            $dOrd
  = Lib.$s$fOrdErrorItem_$c<=
"SPEC/Lib $fOrdErrorItem_$c>= @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                            (Text.Megaparsec.Stream.Token
                                                                               [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$c>= @ (Text.Megaparsec.Stream.Token
                                                 [GHC.Types.Char])
                                            $dOrd
  = Lib.$s$fOrdErrorItem_$c>=
"SPEC/Lib $fOrdErrorItem_$cmax @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                             (Text.Megaparsec.Stream.Token
                                                                                [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$cmax @ (Text.Megaparsec.Stream.Token
                                                  [GHC.Types.Char])
                                             $dOrd
  = Lib.$s$fOrdErrorItem_$cmax
"SPEC/Lib $fOrdErrorItem_$cmin @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                             (Text.Megaparsec.Stream.Token
                                                                                [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$cmin @ (Text.Megaparsec.Stream.Token
                                                  [GHC.Types.Char])
                                             $dOrd
  = Lib.$s$fOrdErrorItem_$cmin
"SPEC/Lib pAp @ [Char] _ _ _ _" [orphan] forall @ e
                                                @ m :: * -> *
                                                @ a
                                                @ b
                                                ($dStream :: Text.Megaparsec.Stream.Stream
                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.pAp @ [GHC.Types.Char]
                               @ e
                               @ m
                               @ a
                               @ b
                               $dStream
  = Lib.$s$fAlternativeParsecT_$spAp @ e @ m @ a @ b
"SPEC/Lib pBind @ [Char] _ _ _ _" [orphan] forall @ e
                                                  @ m :: * -> *
                                                  @ a
                                                  @ b
                                                  ($dStream :: Text.Megaparsec.Stream.Stream
                                                                 [GHC.Types.Char])
  Text.Megaparsec.Internal.pBind @ [GHC.Types.Char]
                                 @ e
                                 @ m
                                 @ a
                                 @ b
                                 $dStream
  = Lib.$s$fMonadParsecT_$spBind @ e @ m @ a @ b
"SPEC/Lib pNotFollowedBy @ [Char] _ _ _" [orphan] forall @ e
                                                         @ m :: * -> *
                                                         @ a
                                                         ($dStream :: Text.Megaparsec.Stream.Stream
                                                                        [GHC.Types.Char])
  Text.Megaparsec.Internal.pNotFollowedBy @ [GHC.Types.Char]
                                          @ e
                                          @ m
                                          @ a
                                          $dStream
  = Lib.$s$fMonadParsecesParsecT_$spNotFollowedBy @ e @ m @ a
"SPEC/Lib pPlus @ Void @ [Char] _ _" [orphan] forall @ m :: * -> *
                                                     @ a
                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                    [GHC.Types.Char])
                                                     ($dOrd :: GHC.Classes.Ord Data.Void.Void)
  Text.Megaparsec.Internal.pPlus @ Data.Void.Void
                                 @ [GHC.Types.Char]
                                 @ m
                                 @ a
                                 $dOrd
                                 $dStream
  = Lib.$s$fAlternativeParsecT_$spPlus @ m @ a
"SPEC/Lib pTakeP _ @ [Char] _" [orphan] forall @ e
                                               @ m :: * -> *
                                               ($dStream :: Text.Megaparsec.Stream.Stream
                                                              [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeP @ e @ [GHC.Types.Char] @ m $dStream
  = Lib.$s$fMonadParsecesParsecT_$spTakeP @ e @ m
"SPEC/Lib pTakeWhile1P _ @ [Char] _" [orphan] forall @ e
                                                     @ m :: * -> *
                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                    [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeWhile1P @ e
                                        @ [GHC.Types.Char]
                                        @ m
                                        $dStream
  = Lib.$s$fMonadParsecesParsecT_$spTakeWhile1P @ e @ m
"SPEC/Lib pTakeWhileP _ @ [Char] _" [orphan] forall @ e
                                                    @ m :: * -> *
                                                    ($dStream :: Text.Megaparsec.Stream.Stream
                                                                   [GHC.Types.Char])
  Text.Megaparsec.Internal.pTakeWhileP @ e
                                       @ [GHC.Types.Char]
                                       @ m
                                       $dStream
  = Lib.$s$fMonadParsecesParsecT_$spTakeWhileP @ e @ m
"SPEC/Lib pToken _ @ [Char] _ _" [orphan] forall @ e
                                                 @ m :: * -> *
                                                 @ a
                                                 ($dStream :: Text.Megaparsec.Stream.Stream
                                                                [GHC.Types.Char])
  Text.Megaparsec.Internal.pToken @ e
                                  @ [GHC.Types.Char]
                                  @ m
                                  @ a
                                  $dStream
  = Lib.$s$fMonadParsecesParsecT_$spToken @ e @ m @ a
"SPEC/Lib pTokens _ @ [Char] _" [orphan] forall @ e
                                                @ m :: * -> *
                                                ($dStream :: Text.Megaparsec.Stream.Stream
                                                               [GHC.Types.Char])
  Text.Megaparsec.Internal.pTokens @ e
                                   @ [GHC.Types.Char]
                                   @ m
                                   $dStream
  = Lib.$s$fMonadParsecesParsecT_$spTokens @ e @ m
"SPEC/Lib union @ (ErrorFancy Void)" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                 (Text.Megaparsec.Error.ErrorFancy
                                                                    Data.Void.Void))
  Data.Set.Internal.union @ (Text.Megaparsec.Error.ErrorFancy
                               Data.Void.Void)
                          $dOrd
  = Lib.$s$fAlternativeParsecT_$sunion
"SPEC/Lib union @ (ErrorItem (Token [Char]))" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                          (Text.Megaparsec.Error.ErrorItem
                                                                             (Text.Megaparsec.Stream.Token
                                                                                [GHC.Types.Char])))
  Data.Set.Internal.union @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          $dOrd
  = Lib.$s$fAlternativeParsecT_$sunion1
"SPEC/Lib withHints @ [Char] _ _ _" [orphan] forall @ e
                                                    @ m :: * -> *
                                                    @ b
                                                    ($dOrd :: GHC.Classes.Ord
                                                                (Text.Megaparsec.Stream.Token
                                                                   [GHC.Types.Char]))
  Text.Megaparsec.Internal.withHints @ [GHC.Types.Char]
                                     @ e
                                     @ m
                                     @ b
                                     $dOrd
  = Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

