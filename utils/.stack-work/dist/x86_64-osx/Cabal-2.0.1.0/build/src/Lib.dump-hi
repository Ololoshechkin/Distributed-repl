
==================== FINAL INTERFACE ====================
2019-08-17 13:16:13.924039 UTC

interface client-0.1.0.0-3fs91LC6kDPDvpjHZHaccV:Lib 8022
  interface hash: 08f23bb6f44b7099a1be3774e53870ea
  ABI hash: 430f9311683173f881c67da06fa3a581
  export-list hash: 095dfaaa43b9c51b386b95d57dee9da5
  orphan hash: 3dde8126bfa965b308f9593e6897c4a1
  flag hash: 9ada789ae4663dba7493f9c5c4e3eb35
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.runScript
module dependencies:
package dependencies: array-0.5.2.0 base-4.10.1.0 binary-0.8.5.1
                      bytestring-0.10.8.2 case-insensitive-1.2.0.11 containers-0.5.10.2
                      deepseq-1.4.3.0 directory-1.3.0.2 filepath-1.4.1.2 ghc-prim-0.5.1.1
                      hashable-1.2.7.0 integer-gmp-1.0.1.0 integer-logarithms-1.0.2.1
                      megaparsec-6.4.1 mtl-2.2.2 parser-combinators-0.4.0
                      primitive-0.6.4.0 scientific-0.3.6.2 text-1.2.3.0 time-1.8.0.2
                      transformers-0.5.2.0 unix-2.7.2.2
orphans: time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         transformers-0.5.2.0:Control.Monad.Trans.Error
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show base-4.10.1.0:GHC.Float
         base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Complex base-4.10.1.0:Data.Either
                         base-4.10.1.0:Data.Functor.Compose base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats containers-0.5.10.2:Data.IntMap.Internal
                         containers-0.5.10.2:Data.IntSet.Internal
                         containers-0.5.10.2:Data.Map.Internal
                         containers-0.5.10.2:Data.Sequence.Internal
                         containers-0.5.10.2:Data.Set.Internal containers-0.5.10.2:Data.Tree
                         megaparsec-6.4.1:Text.Megaparsec
                         megaparsec-6.4.1:Text.Megaparsec.Error
                         megaparsec-6.4.1:Text.Megaparsec.Pos
                         megaparsec-6.4.1:Text.Megaparsec.Stream
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array text-1.2.3.0:Data.Text
                         text-1.2.3.0:Data.Text.Lazy
import  -/  base-4.10.1.0:Data.Either d7dae5d9bf298dee616e465c14b5d60e
import  -/  base-4.10.1.0:Data.List 4ab7fa2a1b87502b23af891a384f0506
import  -/  base-4.10.1.0:Data.Maybe 07738c5485acb328136bb15596f8b845
import  -/  base-4.10.1.0:Data.Void cda2f5aea4e65f29149a766abed07b25
import  -/  base-4.10.1.0:Data.Word c4e948c409792d945106eb5269810128
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.IO e261d8b68ccf81a359626fa520b57d1d
import  -/  base-4.10.1.0:GHC.IO.Unsafe 0aa7e5adc396c9f651baef415ce018da
import  -/  base-4.10.1.0:GHC.Show 0a8ce2b5e533d1c2cfb7954e6736be45
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  base-4.10.1.0:System.IO 525805ab19df5e4fe6d8de7dde9cb909
import  -/  base-4.10.1.0:System.IO.Unsafe 00b3b8853d06169d9bfd9af46118ba88
import  -/  binary-0.8.5.1:Data.Binary 11e26a59bbec86b189aaaf7a5a771061
import  -/  binary-0.8.5.1:Data.Binary.Class cc740506576db73747c3f56842778d81
import  -/  binary-0.8.5.1:Data.Binary.Get.Internal 145df8398dd2fa8b83735c00802208d8
import  -/  containers-0.5.10.2:Data.Map.Internal 9c57d7e8180b3d401d116f2112d8715d
import  -/  containers-0.5.10.2:Data.Map.Strict 194f5b0a9785a91a43562790aa6787fc
import  -/  directory-1.3.0.2:System.Directory 7efb84e3be22f1e9f9472b628843cd87
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
import  -/  ghc-prim-0.5.1.1:GHC.Types b1fd0716441595db508c1a74387bf394
import  -/  megaparsec-6.4.1:Text.Megaparsec 6f08341d0cb6013b73d6ca8fb5ac7d53
import  -/  megaparsec-6.4.1:Text.Megaparsec.Char c4da94e3f6ed24f27baf3d0473dec192
import  -/  megaparsec-6.4.1:Text.Megaparsec.Char.Lexer 6026d0d65ca6a9054a2aa3835247ae72
import  -/  mtl-2.2.2:Control.Monad.State 4acb2e6037f370fa4b91900d626e6406
import  -/  parser-combinators-0.4.0:Control.Monad.Combinators 52f1917cea2e00904c4ec9029eb5bba1
d2434dc127416df673fccc4dadac7334
  $fBinaryAssignment :: Data.Binary.Class.Binary Lib.Assignment
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Assignment
                  Lib.$fBinaryAssignment_$cput
                  Lib.$fBinaryAssignment1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.Assignment>_R))
                  Lib.$fBinaryAssignment_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryAssignment1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.Assignment r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.Assignment r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget @ r ww1 ww2 ww3 ww4 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryAssignment_$cput :: Lib.Assignment -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Assignment) ->
                 case w of ww { Lib.Assignment ww1 ww2 ->
                 case Lib.$w$cput ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 (Data.Binary.Put.PairS @ () ww4 ww5)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryAssignment_$sdefaultPutList ::
    [Lib.Assignment] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.Assignment]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.Assignment
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.Assignment)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.Assignment
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.Assignment) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryAssignment_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.Assignment]>_R
                 ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
134f098db942ee94766d361f69ca06a8
  $fBinaryConstant :: Data.Binary.Class.Binary Lib.Constant
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Constant
                  Lib.$fBinaryConstant_$cput
                  Lib.$fBinaryConstant1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.Constant>_R))
                  Lib.$fBinaryConstant_$sdefaultPutList -}
134f098db942ee94766d361f69ca06a8
  $fBinaryConstant1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.Constant r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.Constant r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget2 @ r ww1 ww2 ww3 ww4 w1 }) -}
462db096308e2d3d4e8e607978bdda36
  $fBinaryConstant2 ::
    [Data.ByteString.Internal.ByteString]
    -> forall r.
       Data.ByteString.Internal.ByteString
       -> Data.Binary.Get.Internal.Success
            Data.ByteString.Internal.ByteString r
       -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 3, Strictness: <L,U><L,A><L,A>m1,
     Unfolding: (\ (bss :: [Data.ByteString.Internal.ByteString])
                   @ r
                   (ds :: Data.ByteString.Internal.ByteString)[OneShot]
                   (ds1 :: Data.Binary.Get.Internal.Success
                             Data.ByteString.Internal.ByteString r)[OneShot] ->
                 case Data.ByteString.concat
                        bss of dt11 { Data.ByteString.Internal.PS ipv1 ipv2 ipv3 ipv4 ->
                 Data.Binary.Get.Internal.Fail @ r dt11 Lib.$fBinaryConstant3 }) -}
1534ced980d1325e637658632a5ec10b
  $fBinaryConstant3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.$fBinaryConstant4) -}
5397c09277ac197a7e2aff12c4685e94
  $fBinaryConstant4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("not enough bytes"#) -}
16c8ff21507a364626a16c42ea828c9e
  $fBinaryConstant5 ::
    [Data.ByteString.Internal.ByteString]
    -> Data.ByteString.Internal.ByteString
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (x :: [Data.ByteString.Internal.ByteString]) ->
                 Data.ByteString.concat
                   (GHC.List.dropWhile
                      @ Data.ByteString.Internal.ByteString
                      Data.ByteString.null
                      x)) -}
21927f26a710465a53428f3d4c93bcdb
  $fBinaryConstant6 ::
    GHC.Types.Int
    -> Data.ByteString.Internal.ByteString
    -> Data.Either.Either
         GHC.Types.Int
         (Data.ByteString.Internal.ByteString,
          Data.ByteString.Internal.ByteString)
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(LLLS),1*U(U,U,U,U)>,
     Unfolding: (\ (n20 :: GHC.Types.Int)
                   (str2 :: Data.ByteString.Internal.ByteString)[OneShot] ->
                 case str2 of wild { Data.ByteString.Internal.PS dt11 dt12 dt13 dt14 ->
                 case n20 of wild1 { GHC.Types.I# y ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# dt14 y) of wild2 {
                   GHC.Types.False
                   -> Data.Either.Left
                        @ GHC.Types.Int
                        @ (Data.ByteString.Internal.ByteString,
                           Data.ByteString.Internal.ByteString)
                        (GHC.Types.I# (GHC.Prim.-# y dt14))
                   GHC.Types.True
                   -> Data.Either.Right
                        @ GHC.Types.Int
                        @ (Data.ByteString.Internal.ByteString,
                           Data.ByteString.Internal.ByteString)
                        (wild, Data.ByteString.empty) } } }) -}
4881d1e73ae6cd6d0eca29d39c09c656
  $fBinaryConstant7 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
134f098db942ee94766d361f69ca06a8
  $fBinaryConstant8 :: Data.Binary.Get.Internal.Get Lib.Constant
  {- Strictness: x -}
134f098db942ee94766d361f69ca06a8
  $fBinaryConstant_$cput :: Lib.Constant -> Data.Binary.Put.Put
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Constant) ->
                 case Lib.$w$cput2 w of ww { (#,#) ww1 ww2 ->
                 (Data.Binary.Put.PairS @ () ww1 ww2)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }) -}
134f098db942ee94766d361f69ca06a8
  $fBinaryConstant_$sdefaultPutList ::
    [Lib.Constant] -> Data.Binary.Put.Put
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.Constant]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.Constant
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.Constant)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.Constant
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.Constant) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryConstant_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.Constant]>_R ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryDBComand :: Data.Binary.Class.Binary Lib.DBComand
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.DBComand
                  Lib.$fBinaryDBComand_$cput
                  Lib.$fBinaryDBComand1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.DBComand>_R))
                  Lib.$fBinaryDBComand_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryDBComand1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.DBComand r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.DBComand r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget3 @ r ww1 ww2 ww3 ww4 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryDBComand2 :: Data.Binary.Get.Internal.Get Lib.DBComand
  {- Strictness: x -}
d2434dc127416df673fccc4dadac7334
  $fBinaryDBComand_$cput :: Lib.DBComand -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.DBComand) ->
                 case Lib.$w$cput3 w of ww { (#,#) ww1 ww2 ->
                 (Data.Binary.Put.PairS @ () ww1 ww2)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryDBComand_$sdefaultPutList ::
    [Lib.DBComand] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.DBComand]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.DBComand
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.DBComand)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.DBComand
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.DBComand) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryDBComand_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.DBComand]>_R ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryExpression :: Data.Binary.Class.Binary Lib.Expression
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Expression
                  Lib.$fBinaryExpression_$cput
                  Lib.$fBinaryExpression1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.Expression>_R))
                  Lib.$fBinaryExpression_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryExpression1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.Expression r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.Expression r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget1 @ r ww1 ww2 ww3 ww4 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryExpression_$cput :: Lib.Expression -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Expression) ->
                 case Lib.$w$cput1 w of ww { (#,#) ww1 ww2 ->
                 (Data.Binary.Put.PairS @ () ww1 ww2)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryExpression_$sdefaultPutList ::
    [Lib.Expression] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.Expression]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.Expression
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.Expression)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.Expression
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.Expression) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryExpression_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.Expression]>_R
                 ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryIfThenElse :: Data.Binary.Class.Binary Lib.IfThenElse
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.IfThenElse
                  Lib.$fBinaryIfThenElse_$cput
                  Lib.$fBinaryIfThenElse1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.IfThenElse>_R))
                  Lib.$fBinaryIfThenElse_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryIfThenElse1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.IfThenElse r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.IfThenElse r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget5 @ r ww1 ww2 ww3 ww4 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryIfThenElse_$cput :: Lib.IfThenElse -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.IfThenElse) ->
                 case w of ww { Lib.IfThenElse ww1 ww2 ww3 ->
                 case Lib.$w$cput6 ww1 ww2 ww3 of ww4 { (#,#) ww5 ww6 ->
                 (Data.Binary.Put.PairS @ () ww5 ww6)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryIfThenElse_$sdefaultPutList ::
    [Lib.IfThenElse] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.IfThenElse]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.IfThenElse
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.IfThenElse)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.IfThenElse
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.IfThenElse) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryIfThenElse_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.IfThenElse]>_R
                 ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryInvocation :: Data.Binary.Class.Binary Lib.Invocation
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Invocation
                  Lib.$fBinaryInvocation_$cput
                  Lib.$fBinaryInvocation1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.Invocation>_R))
                  Lib.$fBinaryInvocation_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryInvocation1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.Invocation r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.Invocation r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget6 @ r ww1 ww2 ww3 ww4 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryInvocation_$cput :: Lib.Invocation -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U(U,U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Invocation) ->
                 case w of ww { Lib.Invocation ww1 ww2 ->
                 case Lib.$w$cput7 ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 (Data.Binary.Put.PairS @ () ww4 ww5)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryInvocation_$sdefaultPutList ::
    [Lib.Invocation] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.Invocation]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.Invocation
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.Invocation)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.Invocation
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.Invocation) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryInvocation_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.Invocation]>_R
                 ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryInvocation_go ::
    [Lib.Expression] -> Data.Binary.Put.PutM ()
  {- Arity: 1, Strictness: <S,1*U>m -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLambdaDef :: Data.Binary.Class.Binary Lib.LambdaDef
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.LambdaDef
                  Lib.$fBinaryLambdaDef_$cput
                  Lib.$fBinaryLambdaDef1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.LambdaDef>_R))
                  Lib.$fBinaryLambdaDef_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLambdaDef1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.LambdaDef r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.LambdaDef r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget7 @ r ww1 ww2 ww3 ww4 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLambdaDef_$cput :: Lib.LambdaDef -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U(U,1*U(U,1*U(1*U)))>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.LambdaDef) ->
                 case w of ww { Lib.LambdaDef ww1 ww2 ->
                 case Lib.$w$cput8 ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 (Data.Binary.Put.PairS @ () ww4 ww5)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLambdaDef_$sdefaultPutList ::
    [Lib.LambdaDef] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.LambdaDef]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.LambdaDef
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.LambdaDef)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.LambdaDef
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.LambdaDef) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryLambdaDef_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.LambdaDef]>_R
                 ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLambdaDef_go :: [Lib.Statement] -> Data.Binary.Put.PutM ()
  {- Arity: 1, Strictness: <S,1*U>m -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLoadComand :: Data.Binary.Class.Binary Lib.LoadComand
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.LoadComand
                  Lib.$fBinaryLoadComand_$cput
                  Lib.$fBinaryLoadComand1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.LoadComand>_R))
                  Lib.$fBinaryLoadComand_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLoadComand1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.LoadComand r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.LoadComand r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget10 @ r ww1 ww2 ww3 ww4 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLoadComand_$cput :: Lib.LoadComand -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U(1*U,U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.LoadComand) ->
                 case w of ww { Lib.LoadComand ww1 ww2 ->
                 case Lib.$w$cput4 ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 (Data.Binary.Put.PairS @ () ww4 ww5)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLoadComand_$sdefaultPutList ::
    [Lib.LoadComand] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.LoadComand]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.LoadComand
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.LoadComand)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.LoadComand
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.LoadComand) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryLoadComand_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.LoadComand]>_R
                 ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLoop :: Data.Binary.Class.Binary Lib.Loop
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Loop
                  Lib.$fBinaryLoop_$cput
                  Lib.$fBinaryLoop1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.Loop>_R))
                  Lib.$fBinaryLoop_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLoop1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.Loop r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.Loop r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget11 @ r ww1 ww2 ww3 ww4 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLoop_$cput :: Lib.Loop -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U(1*U,U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Loop) ->
                 case w of ww { Lib.While ww1 ww2 ->
                 case Lib.$w$cput11 ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 (Data.Binary.Put.PairS @ () ww4 ww5)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLoop_$sdefaultPutList :: [Lib.Loop] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.Loop]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.Loop
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.Loop)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.Loop
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.Loop) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryLoop_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.Loop]>_R ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryLoop_go :: [Lib.Statement] -> Data.Binary.Put.PutM ()
  {- Arity: 1, Strictness: <S,1*U>m -}
d2434dc127416df673fccc4dadac7334
  $fBinaryOperator :: Data.Binary.Class.Binary Lib.Operator
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Operator
                  Lib.$fBinaryOperator_$cput
                  Lib.$fBinaryOperator1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.Operator>_R))
                  Lib.$fBinaryOperator_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryOperator1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.Operator r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.Operator r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget12 @ r ww1 ww2 ww3 ww4 w1 }) -}
e9c0f629e94b1f09f2a96f8603ed9c1b
  $fBinaryOperatorType :: Data.Binary.Class.Binary Lib.OperatorType
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.OperatorType
                  Lib.$fBinaryOperatorType_$cput
                  Lib.$fBinaryOperatorType7
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.OperatorType>_R))
                  Lib.$fBinaryOperatorType_$sdefaultPutList -}
cae57f2d4aacbbd2a705262152036c6f
  $fBinaryOperatorType1 :: Data.Binary.Put.PairS ()
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Data.Binary.Put.PairS
                   @ ()
                   GHC.Tuple.()
                   Lib.$fBinaryOperatorType2
                     `cast`
                   (Trans
                        (forall (r :: <*>_N).
                         <Data.ByteString.Builder.Internal.BuildStep r>_R
                         ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <Data.ByteString.Builder.Internal.BuildSignal r>_R))
                        (Sym (Data.ByteString.Builder.Internal.N:Builder[0])))) -}
a032eabb7bf9bb488aa768f3ff21421b
  $fBinaryOperatorType2 ::
    Data.ByteString.Builder.Internal.BuildStep r
    -> Data.ByteString.Builder.Internal.BufferRange
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.ByteString.Builder.Internal.BuildSignal r #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U(U,U)))><S(SS),1*U(U,U)><S,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ r
                   (w :: Data.ByteString.Builder.Internal.BuildStep r)
                   (w1 :: Data.ByteString.Builder.Internal.BufferRange)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w1 of ww { Data.ByteString.Builder.Internal.BufferRange ww1 ww2 ->
                 Lib.$wdt @ r w ww1 ww2 w2 }) -}
7faecfca5c23564ac43d9b851ac1b4eb
  $fBinaryOperatorType3 :: Data.Binary.Put.PairS ()
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Data.Binary.Put.PairS
                   @ ()
                   GHC.Tuple.()
                   Lib.$fBinaryOperatorType4
                     `cast`
                   (Trans
                        (forall (r :: <*>_N).
                         <Data.ByteString.Builder.Internal.BuildStep r>_R
                         ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <Data.ByteString.Builder.Internal.BuildSignal r>_R))
                        (Sym (Data.ByteString.Builder.Internal.N:Builder[0])))) -}
d50848c4fa36f1078f19e63eba238f74
  $fBinaryOperatorType4 ::
    Data.ByteString.Builder.Internal.BuildStep r
    -> Data.ByteString.Builder.Internal.BufferRange
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.ByteString.Builder.Internal.BuildSignal r #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U(U,U)))><S(SS),1*U(U,U)><S,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ r
                   (w :: Data.ByteString.Builder.Internal.BuildStep r)
                   (w1 :: Data.ByteString.Builder.Internal.BufferRange)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w1 of ww { Data.ByteString.Builder.Internal.BufferRange ww1 ww2 ->
                 Lib.$wdt1 @ r w ww1 ww2 w2 }) -}
d5ea96fa1ac09c94cdca14f06aa45a9e
  $fBinaryOperatorType5 :: Data.Binary.Put.PairS ()
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Data.Binary.Put.PairS
                   @ ()
                   GHC.Tuple.()
                   Lib.$fBinaryOperatorType6
                     `cast`
                   (Trans
                        (forall (r :: <*>_N).
                         <Data.ByteString.Builder.Internal.BuildStep r>_R
                         ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <Data.ByteString.Builder.Internal.BuildSignal r>_R))
                        (Sym (Data.ByteString.Builder.Internal.N:Builder[0])))) -}
a6643864df19fd31a733fb4844e3f40a
  $fBinaryOperatorType6 ::
    Data.ByteString.Builder.Internal.BuildStep r
    -> Data.ByteString.Builder.Internal.BufferRange
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.ByteString.Builder.Internal.BuildSignal r #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U(U,U)))><S(SS),1*U(U,U)><S,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ r
                   (w :: Data.ByteString.Builder.Internal.BuildStep r)
                   (w1 :: Data.ByteString.Builder.Internal.BufferRange)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w1 of ww { Data.ByteString.Builder.Internal.BufferRange ww1 ww2 ->
                 Lib.$wdt2 @ r w ww1 ww2 w2 }) -}
e9c0f629e94b1f09f2a96f8603ed9c1b
  $fBinaryOperatorType7 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.OperatorType r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.OperatorType r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget13 @ r ww1 ww2 ww3 ww4 w1 }) -}
e9c0f629e94b1f09f2a96f8603ed9c1b
  $fBinaryOperatorType8 ::
    Data.Binary.Get.Internal.Get Lib.OperatorType
  {- Strictness: x -}
e9c0f629e94b1f09f2a96f8603ed9c1b
  $fBinaryOperatorType_$cput ::
    Lib.OperatorType -> Data.Binary.Put.Put
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.OperatorType) ->
                 case ds of wild {
                   Lib.IntType
                   -> Lib.$fBinaryOperatorType5
                        `cast`
                      (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                   Lib.StringType
                   -> Lib.$fBinaryOperatorType3
                        `cast`
                      (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                   Lib.BoolType
                   -> Lib.$fBinaryOperatorType1
                        `cast`
                      (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }) -}
e9c0f629e94b1f09f2a96f8603ed9c1b
  $fBinaryOperatorType_$sdefaultPutList ::
    [Lib.OperatorType] -> Data.Binary.Put.Put
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.OperatorType]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.OperatorType
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.OperatorType)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.OperatorType
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.OperatorType) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryOperatorType_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.OperatorType]>_R
                 ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryOperator_$cput :: Lib.Operator -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Operator) ->
                 case Lib.$w$cput12 w of ww { (#,#) ww1 ww2 ->
                 (Data.Binary.Put.PairS @ () ww1 ww2)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryOperator_$sdefaultPutList ::
    [Lib.Operator] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.Operator]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.Operator
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.Operator)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.Operator
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.Operator) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryOperator_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.Operator]>_R ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryProgram :: Data.Binary.Class.Binary Lib.Program
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Program
                  Lib.$fBinaryProgram_$cput
                  Lib.$fBinaryProgram1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.Program>_R))
                  Lib.$fBinaryProgram_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryProgram1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.Program r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.Program r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget8 @ r ww1 ww2 ww3 ww4 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryProgram_$cput :: Lib.Program -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U(U,1*U(1*U))>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Program) ->
                 case w of ww { Lib.Program ww1 ww2 ->
                 case Lib.$w$cput9 ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 (Data.Binary.Put.PairS @ () ww4 ww5)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryProgram_$sdefaultPutList ::
    [Lib.Program] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.Program]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.Program
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.Program)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.Program
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.Program) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryProgram_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.Program]>_R ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryPublishComand :: Data.Binary.Class.Binary Lib.PublishComand
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.PublishComand
                  Lib.$fBinaryPublishComand_$cput
                  Lib.$fBinaryPublishComand1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.PublishComand>_R))
                  Lib.$fBinaryPublishComand_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryPublishComand1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.PublishComand r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.PublishComand r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget4 @ r ww1 ww2 ww3 ww4 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryPublishComand_$cput ::
    Lib.PublishComand -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,U(U))>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.PublishComand) ->
                 case w of ww { Lib.PublishComand ww1 ww2 ww3 ->
                 case Lib.$w$cput5 ww1 ww2 ww3 of ww4 { (#,#) ww5 ww6 ->
                 (Data.Binary.Put.PairS @ () ww5 ww6)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryPublishComand_$sdefaultPutList ::
    [Lib.PublishComand] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.PublishComand]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.PublishComand
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.PublishComand)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.PublishComand
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.PublishComand) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryPublishComand_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.PublishComand]>_R
                 ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryReturnStatement ::
    Data.Binary.Class.Binary Lib.ReturnStatement
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.ReturnStatement
                  Lib.$fBinaryReturnStatement_$cput
                  Lib.$fBinaryReturnStatement1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.ReturnStatement>_R))
                  Lib.$fBinaryReturnStatement_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryReturnStatement1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.ReturnStatement r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (i :: Data.ByteString.Internal.ByteString)
                   (ks :: Data.Binary.Get.Internal.Success Lib.ReturnStatement r) ->
                 Lib.$fBinaryExpression1
                   @ r
                   i
                   (\ (i' :: Data.ByteString.Internal.ByteString)
                      (a1 :: Lib.Expression)[OneShot] ->
                    ks i' (Lib.ReturnStatement a1))) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryReturnStatement_$cput ::
    Lib.ReturnStatement -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.ReturnStatement) ->
                 case ds of wild { Lib.ReturnStatement e ->
                 Lib.$fBinaryExpression_$cput e }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryReturnStatement_$sdefaultPutList ::
    [Lib.ReturnStatement] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.ReturnStatement]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.ReturnStatement
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.ReturnStatement)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.ReturnStatement
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.ReturnStatement) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryReturnStatement_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.ReturnStatement]>_R
                 ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryStatement :: Data.Binary.Class.Binary Lib.Statement
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Statement
                  Lib.$fBinaryStatement_$cput
                  Lib.$fBinaryStatement1
                    `cast`
                  (Sym (Data.Binary.Get.Internal.N:Get[0] <Lib.Statement>_R))
                  Lib.$fBinaryStatement_$sdefaultPutList -}
d2434dc127416df673fccc4dadac7334
  $fBinaryStatement1 ::
    Data.ByteString.Internal.ByteString
    -> Data.Binary.Get.Internal.Success Lib.Statement r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,C(C1(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ r
                   (w :: Data.ByteString.Internal.ByteString)
                   (w1 :: Data.Binary.Get.Internal.Success Lib.Statement r) ->
                 case w of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget9 @ r ww1 ww2 ww3 ww4 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryStatement_$cput :: Lib.Statement -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Statement) ->
                 case Lib.$w$cput10 w of ww { (#,#) ww1 ww2 ->
                 (Data.Binary.Put.PairS @ () ww1 ww2)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }) -}
d2434dc127416df673fccc4dadac7334
  $fBinaryStatement_$sdefaultPutList ::
    [Lib.Statement] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U>m, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ (xs :: [Lib.Statement]) ->
                 Data.Binary.Put.$WPairS
                   @ ()
                   GHC.Tuple.()
                   (Data.ByteString.Builder.Internal.append
                      (Data.ByteString.Builder.Prim.primBounded
                         @ GHC.Int.Int64
                         Data.Binary.Class.$dmputList1
                         (case GHC.Base.foldr
                                 @ Lib.Statement
                                 @ (GHC.Types.Int -> GHC.Types.Int)
                                 (GHC.List.lengthFB @ Lib.Statement)
                                 GHC.List.idLength
                                 xs
                                 (GHC.Types.I# 0#) of wild { GHC.Types.I# x# ->
                          GHC.Int.I64# x# }))
                      (case (GHC.Base.foldr
                               @ Lib.Statement
                               @ (Data.Binary.Put.PutM ())
                               (\ (x :: Lib.Statement) ->
                                Data.Binary.Put.$fApplicativePutM_$c*>
                                  @ ()
                                  @ ()
                                  (Lib.$fBinaryStatement_$cput x))
                               (Data.Binary.Put.$WPairS
                                  @ ()
                                  GHC.Tuple.()
                                  Data.ByteString.Builder.Internal.empty)
                                 `cast`
                               (Sym (Data.Binary.Put.N:PutM[0]) <()>_N)
                               xs)
                              `cast`
                            (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                       w' })))
                  `cast`
                (<[Lib.Statement]>_R
                 ->_R Sym (Data.Binary.Put.N:PutM[0]) <()>_N) -}
d2434dc127416df673fccc4dadac7334
  $fShowAssignment :: GHC.Show.Show Lib.Assignment
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Assignment
                  Lib.$fShowAssignment_$cshowsPrec
                  Lib.$fShowAssignment_$cshow
                  Lib.$fShowAssignment_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowAssignment1 :: Lib.Assignment -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>,
     Unfolding: (\ (w :: Lib.Assignment) ->
                 case w of ww { Lib.Assignment ww1 ww2 ->
                 Lib.$w$cshowsPrec 0# ww1 ww2 }) -}
b9322e19ddf4a38b7450c9dc464258a9
  $fShowAssignment2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Assignment "#) -}
7bbf19f198490a71cf90ac3d3818eddb
  $fShowAssignment3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
d2434dc127416df673fccc4dadac7334
  $fShowAssignment_$cshow :: Lib.Assignment -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.Assignment) ->
                 Lib.$fShowAssignment_$cshowsPrec
                   Lib.$fShowAssignment3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2434dc127416df673fccc4dadac7334
  $fShowAssignment_$cshowList :: [Lib.Assignment] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Assignment
                   Lib.$fShowAssignment1) -}
d2434dc127416df673fccc4dadac7334
  $fShowAssignment_$cshowsPrec ::
    GHC.Types.Int -> Lib.Assignment -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.Assignment) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.Assignment ww3 ww4 ->
                 Lib.$w$cshowsPrec ww1 ww3 ww4 } }) -}
134f098db942ee94766d361f69ca06a8
  $fShowConstant :: GHC.Show.Show Lib.Constant
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Constant
                  Lib.$fShowConstant_$cshowsPrec
                  Lib.$fShowConstant_$cshow
                  Lib.$fShowConstant_$cshowList -}
134f098db942ee94766d361f69ca06a8
  $fShowConstant1 :: Lib.Constant -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (w :: Lib.Constant) (w1 :: GHC.Base.String) ->
                 Lib.$w$cshowsPrec2 0# w w1) -}
5beb199c185942211c37ff82cfcecd06
  $fShowConstant2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BoolConstant "#) -}
0626c971a445131493d1b98441581331
  $fShowConstant3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("StringConstant "#) -}
eda0a27f428f40db621a026d2efc1970
  $fShowConstant4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("IntConstant "#) -}
66963be00309a0652b1db99384350a24
  $fShowConstant5 :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.$fShow(,)3
                   (GHC.Types.[] @ GHC.Types.Char)) -}
134f098db942ee94766d361f69ca06a8
  $fShowConstant_$cshow :: Lib.Constant -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Lib.Constant) ->
                 case x of wild {
                   Lib.IntConstant b1
                   -> GHC.CString.unpackAppendCString#
                        Lib.$fShowConstant4
                        (case b1 of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt
                                11#
                                ww3
                                (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                         GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                   Lib.StringConstant b1
                   -> GHC.CString.unpackAppendCString#
                        Lib.$fShowConstant3
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.$fShow(,)3
                           (GHC.Show.showLitString b1 Lib.$fShowConstant5))
                   Lib.BoolConstant b1
                   -> GHC.CString.unpackAppendCString#
                        Lib.$fShowConstant2
                        (case b1 of wild1 {
                           GHC.Types.False -> GHC.Show.$fShowBool3
                           GHC.Types.True -> GHC.Show.$fShowBool1 }) }) -}
134f098db942ee94766d361f69ca06a8
  $fShowConstant_$cshowList :: [Lib.Constant] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Constant
                   Lib.$fShowConstant1) -}
134f098db942ee94766d361f69ca06a8
  $fShowConstant_$cshowsPrec ::
    GHC.Types.Int -> Lib.Constant -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Lib.Constant)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Lib.$w$cshowsPrec2 ww1 w1 w2 }) -}
d2434dc127416df673fccc4dadac7334
  $fShowDBComand :: GHC.Show.Show Lib.DBComand
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.DBComand
                  Lib.$fShowDBComand_$cshowsPrec
                  Lib.$fShowDBComand_$cshow
                  Lib.$fShowDBComand_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowDBComand1 :: Lib.DBComand -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (w :: Lib.DBComand) -> Lib.$w$cshowsPrec3 0# w) -}
1cfade805536c0977d446823c016808a
  $fShowDBComand2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.$fShowDBComand3) -}
04e1d98bfad351c754fcf1279911f07b
  $fShowDBComand3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LoadDBComand "#) -}
6e55bd2363791219d28e225fcdb1dd4e
  $fShowDBComand4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LoadComand "#) -}
4f57306bff9ecf20d4e074b1cd6e86c1
  $fShowDBComand5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.$fShowDBComand6) -}
39f2f20ec22c92ab8a14222c0a55e62b
  $fShowDBComand6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("PublishDBComand "#) -}
2ff10f765145d478b1bffb9c2b513de9
  $fShowDBComand7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.$fShowDBComand8) -}
1d893219e06123ff0f7e48ba0f9a2c83
  $fShowDBComand8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("PublishComand "#) -}
d2434dc127416df673fccc4dadac7334
  $fShowDBComand_$cshow :: Lib.DBComand -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Lib.DBComand) ->
                 case x of wild {
                   Lib.PublishDBComand b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lib.$fShowDBComand5
                        (case b1 of ww { Lib.PublishComand ww1 ww2 ww3 ->
                         Lib.$w$cshowsPrec5
                           11#
                           ww1
                           ww2
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) })
                   Lib.LoadDBComand b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lib.$fShowDBComand2
                        (case b1 of ww { Lib.LoadComand ww1 ww2 ->
                         Lib.$w$cshowsPrec4
                           11#
                           ww1
                           ww2
                           (GHC.Types.[] @ GHC.Types.Char) }) }) -}
d2434dc127416df673fccc4dadac7334
  $fShowDBComand_$cshowList :: [Lib.DBComand] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.DBComand
                   Lib.$fShowDBComand1) -}
d2434dc127416df673fccc4dadac7334
  $fShowDBComand_$cshowsPrec ::
    GHC.Types.Int -> Lib.DBComand -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.DBComand) ->
                 case w of ww { GHC.Types.I# ww1 -> Lib.$w$cshowsPrec3 ww1 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fShowExpression :: GHC.Show.Show Lib.Expression
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Expression
                  Lib.$fShowExpression_$cshowsPrec
                  Lib.$fShowExpression_$cshow
                  Lib.$fShowExpression_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowExpression1 :: Lib.Expression -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (w :: Lib.Expression) -> Lib.$w$cshowsPrec1 0# w) -}
d2434dc127416df673fccc4dadac7334
  $fShowExpression_$cshow :: Lib.Expression -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.Expression) ->
                 Lib.$fShowExpression_$cshowsPrec
                   Lib.$fShowAssignment3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2434dc127416df673fccc4dadac7334
  $fShowExpression_$cshowList :: [Lib.Expression] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Expression
                   Lib.$fShowExpression1) -}
d2434dc127416df673fccc4dadac7334
  $fShowExpression_$cshowsPrec ::
    GHC.Types.Int -> Lib.Expression -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.Expression) ->
                 case w of ww { GHC.Types.I# ww1 -> Lib.$w$cshowsPrec1 ww1 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fShowIfThenElse :: GHC.Show.Show Lib.IfThenElse
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.IfThenElse
                  Lib.$fShowIfThenElse_$cshowsPrec
                  Lib.$fShowIfThenElse_$cshow
                  Lib.$fShowIfThenElse_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowIfThenElse1 :: Lib.IfThenElse -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U)>,
     Unfolding: (\ (w :: Lib.IfThenElse) ->
                 case w of ww { Lib.IfThenElse ww1 ww2 ww3 ->
                 Lib.$w$cshowsPrec6 0# ww1 ww2 ww3 }) -}
098489fff44a3e0be56e04833372b4b3
  $fShowIfThenElse2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("IfThenElse "#) -}
d2434dc127416df673fccc4dadac7334
  $fShowIfThenElse_$cshow :: Lib.IfThenElse -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.IfThenElse) ->
                 Lib.$fShowIfThenElse_$cshowsPrec
                   Lib.$fShowAssignment3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2434dc127416df673fccc4dadac7334
  $fShowIfThenElse_$cshowList :: [Lib.IfThenElse] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.IfThenElse
                   Lib.$fShowIfThenElse1) -}
d2434dc127416df673fccc4dadac7334
  $fShowIfThenElse_$cshowsPrec ::
    GHC.Types.Int -> Lib.IfThenElse -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.IfThenElse) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.IfThenElse ww3 ww4 ww5 ->
                 Lib.$w$cshowsPrec6 ww1 ww3 ww4 ww5 } }) -}
d2434dc127416df673fccc4dadac7334
  $fShowInvocation :: GHC.Show.Show Lib.Invocation
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Invocation
                  Lib.$fShowInvocation_$cshowsPrec
                  Lib.$fShowInvocation_$cshow
                  Lib.$fShowInvocation_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowInvocation1 :: Lib.Invocation -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(1*U,1*U)><L,U>,
     Unfolding: (\ (w :: Lib.Invocation) (w1 :: GHC.Base.String) ->
                 case w of ww { Lib.Invocation ww1 ww2 ->
                 Lib.$w$cshowsPrec7 0# ww1 ww2 w1 }) -}
400a0ba8de03e22dc836436b04cfcda9
  $fShowInvocation2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invocation "#) -}
d2434dc127416df673fccc4dadac7334
  $fShowInvocation_$cshow :: Lib.Invocation -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.Invocation) ->
                 Lib.$fShowInvocation_$cshowsPrec
                   Lib.$fShowAssignment3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2434dc127416df673fccc4dadac7334
  $fShowInvocation_$cshowList :: [Lib.Invocation] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Invocation
                   Lib.$fShowInvocation1) -}
d2434dc127416df673fccc4dadac7334
  $fShowInvocation_$cshowsPrec ::
    GHC.Types.Int -> Lib.Invocation -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Lib.Invocation)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.Invocation ww3 ww4 ->
                 Lib.$w$cshowsPrec7 ww1 ww3 ww4 w2 } }) -}
d2434dc127416df673fccc4dadac7334
  $fShowLambdaDef :: GHC.Show.Show Lib.LambdaDef
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.LambdaDef
                  Lib.$fShowLambdaDef_$cshowsPrec
                  Lib.$fShowLambdaDef_$cshow
                  Lib.$fShowLambdaDef_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowLambdaDef1 :: Lib.LambdaDef -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(U,1*U(U,1*U(1*U)))>,
     Unfolding: (\ (w :: Lib.LambdaDef) ->
                 case w of ww { Lib.LambdaDef ww1 ww2 ->
                 Lib.$w$cshowsPrec8 0# ww1 ww2 }) -}
83770cfa55238840a16b156705bf4e4b
  $fShowLambdaDef2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LambdaDef "#) -}
08cbb35972bb99fb9711b355704be0f3
  $fShowLambdaDef3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Program "#) -}
47042606c2798dd2e6a810566136b97a
  $fShowLambdaDef4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.$fShowLambdaDef5) -}
84056ee88a132bb1032411fdb11c6206
  $fShowLambdaDef5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ReturnStatement "#) -}
d2434dc127416df673fccc4dadac7334
  $fShowLambdaDef_$cshow :: Lib.LambdaDef -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U(U,1*U(1*U)))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.LambdaDef) ->
                 Lib.$fShowLambdaDef_$cshowsPrec
                   Lib.$fShowAssignment3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2434dc127416df673fccc4dadac7334
  $fShowLambdaDef_$cshowList :: [Lib.LambdaDef] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.LambdaDef
                   Lib.$fShowLambdaDef1) -}
d2434dc127416df673fccc4dadac7334
  $fShowLambdaDef_$cshowsPrec ::
    GHC.Types.Int -> Lib.LambdaDef -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U,1*U(U,1*U(1*U)))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.LambdaDef) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.LambdaDef ww3 ww4 ->
                 Lib.$w$cshowsPrec8 ww1 ww3 ww4 } }) -}
d2434dc127416df673fccc4dadac7334
  $fShowLoadComand :: GHC.Show.Show Lib.LoadComand
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.LoadComand
                  Lib.$fShowLoadComand_$cshowsPrec
                  Lib.$fShowLoadComand_$cshow
                  Lib.$fShowLoadComand_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowLoadComand1 :: Lib.LoadComand -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(1*U,U)>,
     Unfolding: (\ (w :: Lib.LoadComand) ->
                 case w of ww { Lib.LoadComand ww1 ww2 ->
                 Lib.$w$cshowsPrec4 0# ww1 ww2 }) -}
d2434dc127416df673fccc4dadac7334
  $fShowLoadComand_$cshow :: Lib.LoadComand -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.LoadComand) ->
                 Lib.$fShowLoadComand_$cshowsPrec
                   Lib.$fShowAssignment3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2434dc127416df673fccc4dadac7334
  $fShowLoadComand_$cshowList :: [Lib.LoadComand] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.LoadComand
                   Lib.$fShowLoadComand1) -}
d2434dc127416df673fccc4dadac7334
  $fShowLoadComand_$cshowsPrec ::
    GHC.Types.Int -> Lib.LoadComand -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(1*U,U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.LoadComand) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.LoadComand ww3 ww4 ->
                 Lib.$w$cshowsPrec4 ww1 ww3 ww4 } }) -}
d2434dc127416df673fccc4dadac7334
  $fShowLoop :: GHC.Show.Show Lib.Loop
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Loop
                  Lib.$fShowLoop_$cshowsPrec
                  Lib.$fShowLoop_$cshow
                  Lib.$fShowLoop_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowLoop1 :: Lib.Loop -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(1*U,U)>,
     Unfolding: (\ (w :: Lib.Loop) ->
                 case w of ww { Lib.While ww1 ww2 ->
                 Lib.$w$cshowsPrec12 0# ww1 ww2 }) -}
dbdfdee9391048ceceb79db3a1c00469
  $fShowLoop2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("While "#) -}
d2434dc127416df673fccc4dadac7334
  $fShowLoop_$cshow :: Lib.Loop -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.Loop) ->
                 Lib.$fShowLoop_$cshowsPrec
                   Lib.$fShowAssignment3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2434dc127416df673fccc4dadac7334
  $fShowLoop_$cshowList :: [Lib.Loop] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Lib.Loop Lib.$fShowLoop1) -}
d2434dc127416df673fccc4dadac7334
  $fShowLoop_$cshowsPrec ::
    GHC.Types.Int -> Lib.Loop -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(1*U,U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.Loop) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.While ww3 ww4 ->
                 Lib.$w$cshowsPrec12 ww1 ww3 ww4 } }) -}
d2434dc127416df673fccc4dadac7334
  $fShowOperator :: GHC.Show.Show Lib.Operator
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Operator
                  Lib.$fShowOperator_$cshowsPrec
                  Lib.$fShowOperator_$cshow
                  Lib.$fShowOperator_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowOperator1 :: Lib.Operator -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (w :: Lib.Operator) -> Lib.$w$cshowsPrec13 0# w) -}
9fb3e7c34117da1c6c27836ab710b115
  $fShowOperator2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BinaryOperator "#) -}
75583afcc369c23dd435ab4d8eef2d35
  $fShowOperator3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.$fShowOperator4) -}
d29d70a2211aef967706f4db7532d3dd
  $fShowOperator4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BoolType"#) -}
b9928e95c708fd362fb0bb410c4fe6ed
  $fShowOperator5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.$fShowOperator6) -}
a15882d9346f021cf0037d0786786c3d
  $fShowOperator6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("StringType"#) -}
0296a9b695b00ee971e1140296b31946
  $fShowOperator7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.$fShowOperator8) -}
b9df3b7b2f283b38c482fa3b5115f7d1
  $fShowOperator8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("IntType"#) -}
7cd17334023c6606197ed4a6190a2191
  $fShowOperator9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("UnaryOperator "#) -}
e9c0f629e94b1f09f2a96f8603ed9c1b
  $fShowOperatorType :: GHC.Show.Show Lib.OperatorType
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.OperatorType
                  Lib.$fShowOperatorType_$cshowsPrec
                  Lib.$fShowOperatorType_$cshow
                  Lib.$fShowOperatorType_$cshowList -}
e9c0f629e94b1f09f2a96f8603ed9c1b
  $fShowOperatorType_$cshow :: Lib.OperatorType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.OperatorType) ->
                 case x of wild {
                   Lib.IntType -> Lib.$fShowOperator7
                   Lib.StringType -> Lib.$fShowOperator5
                   Lib.BoolType -> Lib.$fShowOperator3 }) -}
e9c0f629e94b1f09f2a96f8603ed9c1b
  $fShowOperatorType_$cshowList ::
    [Lib.OperatorType] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.OperatorType
                   Lib.$w$cshowsPrec14) -}
e9c0f629e94b1f09f2a96f8603ed9c1b
  $fShowOperatorType_$cshowsPrec ::
    GHC.Types.Int -> Lib.OperatorType -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Lib.OperatorType)
                   (w2 :: GHC.Base.String) ->
                 Lib.$w$cshowsPrec14 w1 w2) -}
d2434dc127416df673fccc4dadac7334
  $fShowOperator_$cshow :: Lib.Operator -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.Operator) ->
                 Lib.$fShowOperator_$cshowsPrec
                   Lib.$fShowAssignment3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2434dc127416df673fccc4dadac7334
  $fShowOperator_$cshowList :: [Lib.Operator] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Operator
                   Lib.$fShowOperator1) -}
d2434dc127416df673fccc4dadac7334
  $fShowOperator_$cshowsPrec ::
    GHC.Types.Int -> Lib.Operator -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.Operator) ->
                 case w of ww { GHC.Types.I# ww1 -> Lib.$w$cshowsPrec13 ww1 w1 }) -}
d2434dc127416df673fccc4dadac7334
  $fShowProgram :: GHC.Show.Show Lib.Program
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Program
                  Lib.$fShowProgram_$cshowsPrec
                  Lib.$fShowProgram_$cshow
                  Lib.$fShowProgram_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowProgram1 :: Lib.Program -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(U,1*U(1*U))>,
     Unfolding: (\ (w :: Lib.Program) ->
                 case w of ww { Lib.Program ww1 ww2 ->
                 Lib.$w$cshowsPrec9 0# ww1 ww2 }) -}
d2434dc127416df673fccc4dadac7334
  $fShowProgram_$cshow :: Lib.Program -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,1*U(1*U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.Program) ->
                 Lib.$fShowProgram_$cshowsPrec
                   Lib.$fShowAssignment3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2434dc127416df673fccc4dadac7334
  $fShowProgram_$cshowList :: [Lib.Program] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Program
                   Lib.$fShowProgram1) -}
d2434dc127416df673fccc4dadac7334
  $fShowProgram_$cshowsPrec ::
    GHC.Types.Int -> Lib.Program -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U,1*U(1*U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.Program) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.Program ww3 ww4 ->
                 Lib.$w$cshowsPrec9 ww1 ww3 ww4 } }) -}
d2434dc127416df673fccc4dadac7334
  $fShowPublishComand :: GHC.Show.Show Lib.PublishComand
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.PublishComand
                  Lib.$fShowPublishComand_$cshowsPrec
                  Lib.$fShowPublishComand_$cshow
                  Lib.$fShowPublishComand_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowPublishComand1 :: Lib.PublishComand -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,U(U))>,
     Unfolding: (\ (w :: Lib.PublishComand) ->
                 case w of ww { Lib.PublishComand ww1 ww2 ww3 ->
                 Lib.$w$cshowsPrec5 0# ww1 ww2 ww3 }) -}
d2434dc127416df673fccc4dadac7334
  $fShowPublishComand_$cshow :: Lib.PublishComand -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.PublishComand) ->
                 Lib.$fShowPublishComand_$cshowsPrec
                   Lib.$fShowAssignment3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2434dc127416df673fccc4dadac7334
  $fShowPublishComand_$cshowList ::
    [Lib.PublishComand] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.PublishComand
                   Lib.$fShowPublishComand1) -}
d2434dc127416df673fccc4dadac7334
  $fShowPublishComand_$cshowsPrec ::
    GHC.Types.Int -> Lib.PublishComand -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U,U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.PublishComand) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.PublishComand ww3 ww4 ww5 ->
                 Lib.$w$cshowsPrec5 ww1 ww3 ww4 ww5 } }) -}
d2434dc127416df673fccc4dadac7334
  $fShowReturnStatement :: GHC.Show.Show Lib.ReturnStatement
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.ReturnStatement
                  Lib.$fShowReturnStatement_$cshowsPrec
                  Lib.$fShowReturnStatement_$cshow
                  Lib.$fShowReturnStatement_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowReturnStatement1 :: Lib.ReturnStatement -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: (\ (w :: Lib.ReturnStatement) ->
                 case w of ww { Lib.ReturnStatement ww1 ->
                 Lib.$w$cshowsPrec11 0# ww1 }) -}
676d53886c16baa1be3975f8ed5f0d2b
  $fShowReturnStatement2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
d2434dc127416df673fccc4dadac7334
  $fShowReturnStatement_$cshow ::
    Lib.ReturnStatement -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.ReturnStatement) ->
                 case x of wild { Lib.ReturnStatement b1 ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n20 :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c n20 Lib.$fShowLambdaDef4)
                   (Lib.$fShowExpression_$cshowsPrec
                      Lib.$fShowReturnStatement2
                      b1
                      (GHC.Types.[] @ GHC.Types.Char)) }) -}
d2434dc127416df673fccc4dadac7334
  $fShowReturnStatement_$cshowList ::
    [Lib.ReturnStatement] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.ReturnStatement
                   Lib.$fShowReturnStatement1) -}
d2434dc127416df673fccc4dadac7334
  $fShowReturnStatement_$cshowsPrec ::
    GHC.Types.Int -> Lib.ReturnStatement -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.ReturnStatement) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.ReturnStatement ww3 ->
                 Lib.$w$cshowsPrec11 ww1 ww3 } }) -}
d2434dc127416df673fccc4dadac7334
  $fShowStatement :: GHC.Show.Show Lib.Statement
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Statement
                  Lib.$fShowStatement_$cshowsPrec
                  Lib.$fShowStatement_$cshow
                  Lib.$fShowStatement_$cshowList -}
d2434dc127416df673fccc4dadac7334
  $fShowStatement1 :: Lib.Statement -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (w :: Lib.Statement) -> Lib.$w$cshowsPrec10 0# w) -}
d2434dc127416df673fccc4dadac7334
  $fShowStatement_$cshow :: Lib.Statement -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lib.Statement) ->
                 Lib.$fShowStatement_$cshowsPrec
                   Lib.$fShowAssignment3
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2434dc127416df673fccc4dadac7334
  $fShowStatement_$cshowList :: [Lib.Statement] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Statement
                   Lib.$fShowStatement1) -}
d2434dc127416df673fccc4dadac7334
  $fShowStatement_$cshowsPrec ::
    GHC.Types.Int -> Lib.Statement -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.Statement) ->
                 case w of ww { GHC.Types.I# ww1 -> Lib.$w$cshowsPrec10 ww1 w1 }) -}
bfdb46fae913044c645d74278ca45b03
  $s$fAlternativeParsecT ::
    GHC.Base.Alternative
      (Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ (Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m)
                  (Lib.$s$fAlternativeParsecT_$s$fApplicativeParsecT
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.pZero @ Data.Void.Void @ [GHC.Types.Char] @ m)
                  (Lib.$s$fAlternativeParsecT_$spPlus @ m)
                  (Text.Megaparsec.$fAlternativeParsecT3
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     Data.Void.$fOrdVoid
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N).
                   <Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m a>_R
                   ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                                 <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <[a]>_R))
                  (Text.Megaparsec.$fAlternativeParsecT1
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     Data.Void.$fOrdVoid
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N).
                   <Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m a>_R
                   ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                                 <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <[a]>_R)) -}
f765e61f7eccaeb969c64b2df25f5916
  $s$fAlternativeParsecT_$s$fApplicativeParsecT ::
    GHC.Base.Applicative (Text.Megaparsec.ParsecT e [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e @ m :: * -> *.
                  @ (Text.Megaparsec.ParsecT e [GHC.Types.Char] m)
                  (Text.Megaparsec.$fFunctorParsecT @ e @ [GHC.Types.Char] @ m)
                  (\ @ a -> Text.Megaparsec.pPure @ a @ e @ [GHC.Types.Char] @ m)
                  (Lib.$s$fAlternativeParsecT_$spAp @ e @ m)
                  (Text.Megaparsec.$fAlternativeParsecT2
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Text.Megaparsec.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <c>_R))
                  (Text.Megaparsec.$fApplicativeParsecT2
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Text.Megaparsec.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R))
                  (Text.Megaparsec.$fApplicativeParsecT1
                     @ [GHC.Types.Char]
                     @ e
                     @ m
                     Text.Megaparsec.Stream.$fStream[])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Text.Megaparsec.ParsecT e [GHC.Types.Char] m a>_R
                   ->_R <Text.Megaparsec.ParsecT e [GHC.Types.Char] m b>_R
                   ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                                 <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
09c9e95a92d901afecbbf7ea2f99cd39
  $s$fAlternativeParsecT_$spAp ::
    Text.Megaparsec.ParsecT e [GHC.Types.Char] m (a -> b)
    -> Text.Megaparsec.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,C(U)><L,U><L,C(U)><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m16 :: Text.Megaparsec.ParsecT e [GHC.Types.Char] m (a -> b))
                   (k6 :: Text.Megaparsec.ParsecT e [GHC.Types.Char] m a)
                   @ b1
                   (s1 :: Text.Megaparsec.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b1) ->
                 m16
                   `cast`
                 (Text.Megaparsec.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a -> b>_R)
                   @ b1
                   s1
                   (\ (x :: a -> b)
                      (s' :: Text.Megaparsec.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k6
                      `cast`
                    (Text.Megaparsec.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b1
                      s'
                      (GHC.Base..
                         @ b
                         @ (Text.Megaparsec.State [GHC.Types.Char]
                            -> Text.Megaparsec.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b1)
                         @ a
                         cok
                         x)
                      cerr
                      (Text.Megaparsec.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ a
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         (GHC.Base..
                            @ b
                            @ (Text.Megaparsec.State [GHC.Types.Char]
                               -> Text.Megaparsec.Hints
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> m b1)
                            @ a
                            cok
                            x))
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs cerr))
                   cerr
                   (\ (x :: a -> b)
                      (s' :: Text.Megaparsec.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k6
                      `cast`
                    (Text.Megaparsec.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b1
                      s'
                      (GHC.Base..
                         @ b
                         @ (Text.Megaparsec.State [GHC.Types.Char]
                            -> Text.Megaparsec.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b1)
                         @ a
                         cok
                         x)
                      cerr
                      (Text.Megaparsec.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ a
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         (GHC.Base..
                            @ b
                            @ (Text.Megaparsec.State [GHC.Types.Char]
                               -> Text.Megaparsec.Hints
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> m b1)
                            @ a
                            eok
                            x))
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.ParsecT e [GHC.Types.Char] m (a -> b)>_R
                 ->_R <Text.Megaparsec.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
ef93b2e7a1fda4fd3387224db3a2b326
  $s$fAlternativeParsecT_$spPlus ::
    Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m a
    -> Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m a
    -> Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m a
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,C(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ m :: * -> *
                   @ a
                   (m16 :: Text.Megaparsec.ParsecT
                             Data.Void.Void [GHC.Types.Char] m a)
                   (n20 :: Text.Megaparsec.ParsecT
                             Data.Void.Void [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b)
                   (eok :: a
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b) ->
                 m16
                   `cast`
                 (Text.Megaparsec.N:ParsecT[0]
                      <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   s1
                   cok
                   cerr
                   eok
                   (\ (err :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void)
                      (ms :: Text.Megaparsec.State [GHC.Types.Char]) ->
                    n20
                      `cast`
                    (Text.Megaparsec.N:ParsecT[0]
                         <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                      @ b
                      s1
                      cok
                      (\ (err' :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void)
                         (s' :: Text.Megaparsec.State [GHC.Types.Char]) ->
                       cerr
                         (let {
                            $j :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                              <join 0>
                            = case err' of wild {
                                Text.Megaparsec.Error.TrivialError s2 u1 p11
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds2 u2 p12
                                     -> Text.Megaparsec.Error.TrivialError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          s2
                                          (case u1 of wild2 {
                                             GHC.Base.Nothing -> u2
                                             GHC.Base.Just x
                                             -> case u2 of wild3 {
                                                  GHC.Base.Nothing
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       x
                                                  GHC.Base.Just y
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       (case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                                                               @ (Text.Megaparsec.Stream.Token
                                                                    [GHC.Types.Char])
                                                               GHC.Classes.$fOrdChar
                                                                 `cast`
                                                               (GHC.Classes.Ord
                                                                  (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                                                               y
                                                               x of wild4 {
                                                          GHC.Types.False -> y
                                                          GHC.Types.True -> x }) } })
                                          (Lib.$s$fAlternativeParsecT_$sunion1 p11 p12)
                                     Text.Megaparsec.Error.FancyError ds2 ds3 -> wild1 }
                                Text.Megaparsec.Error.FancyError ds2 ds3
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds4 ds5 ds6 -> wild
                                     Text.Megaparsec.Error.FancyError ds4 x2
                                     -> Text.Megaparsec.Error.FancyError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          ds2
                                          (Lib.$s$fAlternativeParsecT_$sunion ds3 x2) } }
                          } in
                          case err' of wild {
                            Text.Megaparsec.Error.TrivialError p11 ds2 ds3
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p12 ds4 ds5
                                 -> case Data.List.NonEmpty.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p11
                                           p12 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p12 ds4
                                 -> case Data.List.NonEmpty.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p11
                                           p12 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } }
                            Text.Megaparsec.Error.FancyError p11 ds2
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p12 ds3 ds4
                                 -> case Data.List.NonEmpty.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p11
                                           p12 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p12 ds3
                                 -> case Data.List.NonEmpty.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p11
                                           p12 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } } })
                         (Text.Megaparsec.longestMatch @ [GHC.Types.Char] ms s'))
                      (\ (x :: a)
                         (s' :: Text.Megaparsec.State [GHC.Types.Char])
                         (hs :: Text.Megaparsec.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       eok
                         x
                         s'
                         (GHC.Base.augment
                            @ (Data.Set.Internal.Set
                                 (Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                            (\ @ b1
                               (c :: Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                     -> b1 -> b1)[OneShot]
                               (n21 :: b1)[OneShot] ->
                             case err of wild {
                               Text.Megaparsec.Error.TrivialError errPos ds ps
                               -> case s' of wild1 { Text.Megaparsec.State ds1 ds2 dt11 ds3 ->
                                  case Data.List.NonEmpty.$fEqNonEmpty_$c==
                                         @ Text.Megaparsec.Pos.SourcePos
                                         Text.Megaparsec.Pos.$fEqSourcePos
                                         ds2
                                         errPos of wild2 {
                                    GHC.Types.False -> n21
                                    GHC.Types.True
                                    -> case ps of wild3 {
                                         Data.Set.Internal.Bin dt12 ds4 ds5 ds6 -> c wild3 n21
                                         Data.Set.Internal.Tip -> n21 } } }
                               Text.Megaparsec.Error.FancyError ds ds1 -> n21 })
                            hs
                              `cast`
                            (Text.Megaparsec.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           `cast`
                         (Sym (Text.Megaparsec.N:Hints[0]
                                   <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                      (\ (err' :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void)
                         (s' :: Text.Megaparsec.State [GHC.Types.Char]) ->
                       eerr
                         (let {
                            $j :: Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                              <join 0>
                            = case err' of wild {
                                Text.Megaparsec.Error.TrivialError s2 u1 p11
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds2 u2 p12
                                     -> Text.Megaparsec.Error.TrivialError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          s2
                                          (case u1 of wild2 {
                                             GHC.Base.Nothing -> u2
                                             GHC.Base.Just x
                                             -> case u2 of wild3 {
                                                  GHC.Base.Nothing
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       x
                                                  GHC.Base.Just y
                                                  -> GHC.Base.Just
                                                       @ (Text.Megaparsec.Error.ErrorItem
                                                            (Text.Megaparsec.Stream.Token
                                                               [GHC.Types.Char]))
                                                       (case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                                                               @ (Text.Megaparsec.Stream.Token
                                                                    [GHC.Types.Char])
                                                               GHC.Classes.$fOrdChar
                                                                 `cast`
                                                               (GHC.Classes.Ord
                                                                  (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                                                               y
                                                               x of wild4 {
                                                          GHC.Types.False -> y
                                                          GHC.Types.True -> x }) } })
                                          (Lib.$s$fAlternativeParsecT_$sunion1 p11 p12)
                                     Text.Megaparsec.Error.FancyError ds2 ds3 -> wild1 }
                                Text.Megaparsec.Error.FancyError ds2 ds3
                                -> case err of wild1 {
                                     Text.Megaparsec.Error.TrivialError ds4 ds5 ds6 -> wild
                                     Text.Megaparsec.Error.FancyError ds4 x2
                                     -> Text.Megaparsec.Error.FancyError
                                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                          @ Data.Void.Void
                                          ds2
                                          (Lib.$s$fAlternativeParsecT_$sunion ds3 x2) } }
                          } in
                          case err' of wild {
                            Text.Megaparsec.Error.TrivialError p11 ds2 ds3
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p12 ds4 ds5
                                 -> case Data.List.NonEmpty.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p11
                                           p12 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p12 ds4
                                 -> case Data.List.NonEmpty.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p11
                                           p12 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } }
                            Text.Megaparsec.Error.FancyError p11 ds2
                            -> case err of wild1 {
                                 Text.Megaparsec.Error.TrivialError p12 ds3 ds4
                                 -> case Data.List.NonEmpty.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p11
                                           p12 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild }
                                 Text.Megaparsec.Error.FancyError p12 ds3
                                 -> case Data.List.NonEmpty.$fOrdNonEmpty_$ccompare
                                           @ Text.Megaparsec.Pos.SourcePos
                                           Text.Megaparsec.Pos.$fOrdSourcePos
                                           p11
                                           p12 of wild2 {
                                      GHC.Types.LT -> wild1
                                      GHC.Types.EQ -> $j
                                      GHC.Types.GT -> wild } } })
                         (Text.Megaparsec.longestMatch @ [GHC.Types.Char] ms s'))))
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.ParsecT
                         Data.Void.Void [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                               <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
f2932b1a76addbb5f38c05351758a081
  $s$fAlternativeParsecT_$sunion ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
588c8a2220cef9506c806315353afd70
  $s$fAlternativeParsecT_$sunion1 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
e75aff549c9c41d00118fea0abec7126
  $s$fAlternativeParsecT_$swithHints ::
    Text.Megaparsec.Hints
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
        -> Text.Megaparsec.State [GHC.Types.Char] -> m b)
    -> Text.Megaparsec.Error.ParseError
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
    -> Text.Megaparsec.State [GHC.Types.Char]
    -> m b
  {- Arity: 3, Strictness: <L,U><C(S),1*C1(U)><S,1*U>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ b
                   (ds :: Text.Megaparsec.Hints
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (c :: Text.Megaparsec.Error.ParseError
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                         -> Text.Megaparsec.State [GHC.Types.Char] -> m b)
                   (e1 :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e) ->
                 case e1 of wild {
                   Text.Megaparsec.Error.TrivialError pos us ps
                   -> c (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           pos
                           us
                           (Lib.$s$fAlternativeParsecT_go3
                              (Data.Set.Internal.Tip
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                              (GHC.Types.:
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 ps
                                 ds
                                   `cast`
                                 (Text.Megaparsec.N:Hints[0]
                                      <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))))
                   Text.Megaparsec.Error.FancyError ipv ipv1 -> c wild }) -}
8495dd9b66b5d8f736714cd21969ec41
  $s$fAlternativeParsecT_go3 ::
    Data.Set.Internal.Set
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
    -> [Data.Set.Internal.Set
          (Text.Megaparsec.Error.ErrorItem
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))]
    -> Data.Set.Internal.Set
         (Text.Megaparsec.Error.ErrorItem
            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
62e74a27a8e740de834ffad27c110532
  $s$fEqErrorFancy ::
    GHC.Classes.Eq (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                  (Text.Megaparsec.Error.$fEqErrorFancy_$c==
                     @ Data.Void.Void
                     Data.Void.$fEqVoid)
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fEqErrorFancy_$c==
                          @ Data.Void.Void
                          Data.Void.$fEqVoid
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False }) -}
28406ea3ece388cd3442b1b2e22b2c8a
  $s$fEqErrorItem ::
    GHC.Classes.Eq
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorItem
                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                  (Text.Megaparsec.Error.$fEqErrorItem_$c==
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fEqChar
                       `cast`
                     (GHC.Classes.Eq (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fEqErrorItem_$c==
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fEqChar
                            `cast`
                          (GHC.Classes.Eq (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False }) -}
59e711277e224ac1fbd6a243a5bed046
  $s$fMonadParsecT ::
    GHC.Base.Monad (Text.Megaparsec.ParsecT e [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e @ m :: * -> *.
                  @ (Text.Megaparsec.ParsecT e [GHC.Types.Char] m)
                  (Lib.$s$fAlternativeParsecT_$s$fApplicativeParsecT @ e @ m)
                  (Lib.$s$fMonadParsecT_$spBind @ e @ m)
                  (Lib.$s$fMonadParsecT_$s$fMonadParsecT_$c>> @ e @ m)
                  (\ @ a -> Text.Megaparsec.pPure @ a @ e @ [GHC.Types.Char] @ m)
                  (Text.Megaparsec.pFail @ e @ [GHC.Types.Char] @ m) -}
a35ea3ee1a31f2dee8d97463f2d5128e
  $s$fMonadParsecT_$s$fMonadParsecT_$c>> ::
    Text.Megaparsec.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.ParsecT e [GHC.Types.Char] m b
    -> Text.Megaparsec.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m16 :: Text.Megaparsec.ParsecT e [GHC.Types.Char] m a)
                   (k6 :: Text.Megaparsec.ParsecT e [GHC.Types.Char] m b)
                   @ b1
                   (s1 :: Text.Megaparsec.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b1) ->
                 m16
                   `cast`
                 (Text.Megaparsec.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b1
                   s1
                   (\ (x :: a)
                      (s' :: Text.Megaparsec.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k6
                      `cast`
                    (Text.Megaparsec.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         cok)
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs cerr))
                   cerr
                   (\ (x :: a)
                      (s' :: Text.Megaparsec.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    k6
                      `cast`
                    (Text.Megaparsec.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         eok)
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <Text.Megaparsec.ParsecT e [GHC.Types.Char] m b>_R
                 ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
9589884ca19a042df73e88daa9a2eed8
  $s$fMonadParsecT_$spBind ::
    Text.Megaparsec.ParsecT e [GHC.Types.Char] m a
    -> (a -> Text.Megaparsec.ParsecT e [GHC.Types.Char] m b)
    -> Text.Megaparsec.ParsecT e [GHC.Types.Char] m b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(C1(U))))))><L,U><L,U><L,U><L,C(C1(C1(U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   @ b
                   (m16 :: Text.Megaparsec.ParsecT e [GHC.Types.Char] m a)
                   (k6 :: a -> Text.Megaparsec.ParsecT e [GHC.Types.Char] m b)
                   @ b1
                   (s1 :: Text.Megaparsec.State [GHC.Types.Char])
                   (cok :: b
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b1)
                   (eok :: b
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b1) ->
                 m16
                   `cast`
                 (Text.Megaparsec.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b1
                   s1
                   (\ (x :: a)
                      (s' :: Text.Megaparsec.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    (k6 x)
                      `cast`
                    (Text.Megaparsec.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         cok)
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs cerr))
                   cerr
                   (\ (x :: a)
                      (s' :: Text.Megaparsec.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    (k6 x)
                      `cast`
                    (Text.Megaparsec.N:ParsecT[0]
                         <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ b
                         @ [GHC.Types.Char]
                         @ m
                         @ b1
                         hs
                         eok)
                      (Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b1 hs eerr))
                   eerr)
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <Text.Megaparsec.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R <a -> Text.Megaparsec.ParsecT e [GHC.Types.Char] m b>_R
                 ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <b>_R)) -}
ddecd05515da0680705d4cf7adf32611
  $s$fMonadParsecesParsecT ::
    Text.Megaparsec.MonadParsec
      Data.Void.Void
      [GHC.Types.Char]
      (Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m)
  {- Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ Data.Void.Void
                  @ [GHC.Types.Char]
                  @ (Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m)
                  Text.Megaparsec.Stream.$fStream[]
                  (Lib.$s$fAlternativeParsecT @ m)
                  (Lib.$s$fMonadParsecesParsecT_$s$fMonadPlusParsecT @ m)
                  (Text.Megaparsec.pFailure @ [GHC.Types.Char] @ Data.Void.Void @ m)
                  (Text.Megaparsec.pFancyFailure
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Text.Megaparsec.pLabel @ Data.Void.Void @ [GHC.Types.Char] @ m)
                  (\ @ a ->
                   Text.Megaparsec.pLabel
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m
                     @ a
                     (GHC.Types.[] @ GHC.Types.Char))
                  (Text.Megaparsec.pTry @ Data.Void.Void @ [GHC.Types.Char] @ m)
                  (Text.Megaparsec.pLookAhead
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (Lib.$s$fMonadParsecesParsecT_$spNotFollowedBy
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.pWithRecovery
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m)
                  (Text.Megaparsec.pObserving
                     @ Data.Void.Void
                     @ [GHC.Types.Char]
                     @ m)
                  (\ @ b
                     (s1 :: Text.Megaparsec.State [GHC.Types.Char])
                     (ds :: ()
                            -> Text.Megaparsec.State [GHC.Types.Char]
                            -> Text.Megaparsec.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b)
                     (ds1 :: Text.Megaparsec.Error.ParseError
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                             -> Text.Megaparsec.State [GHC.Types.Char] -> m b)
                     (eok :: ()
                             -> Text.Megaparsec.State [GHC.Types.Char]
                             -> Text.Megaparsec.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             -> m b)
                     (eerr :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                              -> Text.Megaparsec.State [GHC.Types.Char] -> m b) ->
                   case s1 of wild { Text.Megaparsec.State input ds2 dt11 w ->
                   case ds2 of wild1 { Data.List.NonEmpty.:| pos z1 ->
                   case input of wild2 {
                     []
                     -> eok
                          GHC.Tuple.()
                          wild
                          (GHC.Types.[]
                             @ (Data.Set.Internal.Set
                                  (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                            `cast`
                          (Sym (Text.Megaparsec.N:Hints[0]
                                    <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                     : t ts
                     -> case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                        eerr
                          (Text.Megaparsec.Error.TrivialError
                             @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             @ Data.Void.Void
                             (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos apos z1)
                             (GHC.Base.Just
                                @ (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (Text.Megaparsec.Error.Tokens
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                   (Text.Megaparsec.nes
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      t `cast`
                                      (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))))))
                             (Data.Set.Internal.$WBin
                                @ (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (GHC.Types.I# 1#)
                                (Text.Megaparsec.Error.EndOfInput
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                (Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                (Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char])))))
                          (Text.Megaparsec.$WState
                             @ [GHC.Types.Char]
                             wild2
                             (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos apos z1)
                             (GHC.Types.I# dt11)
                             w) } } } })
                    `cast`
                  (Sym (Text.Megaparsec.N:ParsecT[0]
                            <Data.Void.Void>_N <[GHC.Types.Char]>_N <m>_R <()>_R))
                  (Lib.$s$fMonadParsecesParsecT_$spToken @ Data.Void.Void @ m)
                  (Lib.$s$fMonadParsecesParsecT_$spTokens @ Data.Void.Void @ m)
                  (Lib.$s$fMonadParsecesParsecT_$spTakeWhileP @ Data.Void.Void @ m)
                  (Lib.$s$fMonadParsecesParsecT_$spTakeWhile1P @ Data.Void.Void @ m)
                  (Lib.$s$fMonadParsecesParsecT_$spTakeP @ Data.Void.Void @ m)
                  (\ @ b
                     (s1 :: Text.Megaparsec.State [GHC.Types.Char])
                     (ds :: Text.Megaparsec.State [GHC.Types.Char]
                            -> Text.Megaparsec.State [GHC.Types.Char]
                            -> Text.Megaparsec.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> m b)
                     (ds1 :: Text.Megaparsec.Error.ParseError
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                             -> Text.Megaparsec.State [GHC.Types.Char] -> m b)
                     (eok :: Text.Megaparsec.State [GHC.Types.Char]
                             -> Text.Megaparsec.State [GHC.Types.Char]
                             -> Text.Megaparsec.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             -> m b)
                     (ds2 :: Text.Megaparsec.Error.ParseError
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                             -> Text.Megaparsec.State [GHC.Types.Char] -> m b) ->
                   eok
                     s1
                     s1
                     (GHC.Types.[]
                        @ (Data.Set.Internal.Set
                             (Text.Megaparsec.Error.ErrorItem
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                       `cast`
                     (Sym (Text.Megaparsec.N:Hints[0]
                               <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                    `cast`
                  (Sym (Text.Megaparsec.N:ParsecT[0]
                            <Data.Void.Void>_N
                            <[GHC.Types.Char]>_N
                            <m>_R
                            <Text.Megaparsec.State [GHC.Types.Char]>_R))
                  (Text.Megaparsec.pUpdateParserState
                     @ [GHC.Types.Char]
                     @ Data.Void.Void
                     @ m) -}
350c42d9186d2d649ef4be690f82d78f
  $s$fMonadParsecesParsecT_$s$fMonadPlusParsecT ::
    GHC.Base.MonadPlus
      (Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ m :: * -> *.
                  @ (Text.Megaparsec.ParsecT Data.Void.Void [GHC.Types.Char] m)
                  (Lib.$s$fAlternativeParsecT @ m)
                  (Lib.$s$fMonadParsecT @ Data.Void.Void @ m)
                  (Text.Megaparsec.pZero @ Data.Void.Void @ [GHC.Types.Char] @ m)
                  (Lib.$s$fAlternativeParsecT_$spPlus @ m) -}
ef45c87ea7cbafbd70503b8a89849061
  $s$fMonadParsecesParsecT_$spNotFollowedBy ::
    Text.Megaparsec.ParsecT e [GHC.Types.Char] m a
    -> Text.Megaparsec.ParsecT e [GHC.Types.Char] m ()
  {- Arity: 6, HasNoCafRefs,
     Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><S(LLSL),1*U(U,U,U,U)><L,A><L,A><L,1*C1(C1(C1(U)))><L,1*C1(C1(U))>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (p11 :: Text.Megaparsec.ParsecT e [GHC.Types.Char] m a)
                   @ b
                   (s1 :: Text.Megaparsec.State [GHC.Types.Char])
                   (ds :: ()
                          -> Text.Megaparsec.State [GHC.Types.Char]
                          -> Text.Megaparsec.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State [GHC.Types.Char] -> m b)
                   (eok :: ()
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State input pos dt11 ds2 ->
                 let {
                   what :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   = case input of wild1 {
                       []
                       -> Text.Megaparsec.Error.EndOfInput
                            @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                       : t ts
                       -> Text.Megaparsec.Error.Tokens
                            @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            (Data.List.NonEmpty.:|
                               @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               t `cast` (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))
                               (GHC.Types.[] @ (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) }
                 } in
                 p11
                   `cast`
                 (Text.Megaparsec.N:ParsecT[0]
                      <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)
                   @ b
                   wild
                   (\ (ds3 :: a)
                      (ds4 :: Text.Megaparsec.State [GHC.Types.Char])
                      (ds5 :: Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    eerr
                      (Text.Megaparsec.Error.TrivialError
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ e
                         pos
                         (GHC.Base.Just
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            what)
                         (Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                      wild)
                   (\ (ds3 :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e)
                      (ds4 :: Text.Megaparsec.State [GHC.Types.Char]) ->
                    eok
                      GHC.Tuple.()
                      wild
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                   (\ (ds3 :: a)
                      (ds4 :: Text.Megaparsec.State [GHC.Types.Char])
                      (ds5 :: Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    eerr
                      (Text.Megaparsec.Error.TrivialError
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ e
                         pos
                         (GHC.Base.Just
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            what)
                         (Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                      wild)
                   (\ (ds3 :: Text.Megaparsec.Error.ParseError
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e)
                      (ds4 :: Text.Megaparsec.State [GHC.Types.Char]) ->
                    eok
                      GHC.Tuple.()
                      wild
                      (GHC.Types.[]
                         @ (Data.Set.Internal.Set
                              (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                        `cast`
                      (Sym (Text.Megaparsec.N:Hints[0]
                                <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))) })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.ParsecT e [GHC.Types.Char] m a>_R
                 ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <()>_R)) -}
939112d8e85d55a39ff6e0ff37cf7688
  $s$fMonadParsecesParsecT_$spTakeP ::
    GHC.Base.Maybe GHC.Base.String
    -> GHC.Types.Int
    -> Text.Megaparsec.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7,
     Strictness: <L,1*U><S(S),1*U(U)><S(LSSL),1*U(U,1*U(U(U,U,U),U),U,U(U))><L,1*C1(C1(C1(U)))><L,A><L,A><L,1*C1(C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Base.Maybe GHC.Base.String)
                   (n20 :: GHC.Types.Int)
                   @ b
                   (s1 :: Text.Megaparsec.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                          -> Text.Megaparsec.State [GHC.Types.Char] -> m b)
                   (ds1 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State input ds2 dt11 w ->
                 case ds2 of wild1 { Data.List.NonEmpty.:| pos z1 ->
                 let {
                   ps :: Data.Set.Internal.Set
                           (Text.Megaparsec.Error.ErrorItem
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   = case ml of wild2 {
                       GHC.Base.Nothing
                       -> Data.Set.Internal.Tip
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                       GHC.Base.Just x
                       -> case x of wild3 {
                            []
                            -> Data.Set.Internal.Tip
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            : a1 as2
                            -> Data.Set.Internal.$WBin
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                 (GHC.Types.I# 1#)
                                 (Text.Megaparsec.Error.Label
                                    @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                    (Data.List.NonEmpty.:| @ GHC.Types.Char a1 as2))
                                 (Data.Set.Internal.Tip
                                    @ (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 (Data.Set.Internal.Tip
                                    @ (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) } }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$ctakeN_
                        n20
                        input of wild2 {
                   GHC.Base.Nothing
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos pos z1)
                           (GHC.Base.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.EndOfInput
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                           ps)
                        wild
                   GHC.Base.Just ds3
                   -> case ds3 of wild3 { (,) ts input' ->
                      case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                             (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                             w
                             pos
                             ts of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                      case pos of apos { Text.Megaparsec.Pos.SourcePos ipv3 ipv4 ipv5 ->
                      let {
                        len :: GHC.Types.Int
                        = case GHC.List.$wlenAcc
                                 @ GHC.Types.Char
                                 ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                 0# of ww2 { DEFAULT ->
                          GHC.Types.I# ww2 }
                      } in
                      case GHC.Classes.neInt len n20 of wild4 {
                        GHC.Types.False
                        -> cok
                             ts
                             (case len of wild5 { GHC.Types.I# y ->
                              Text.Megaparsec.$WState
                                @ [GHC.Types.Char]
                                input'
                                (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos npos z1)
                                (GHC.Types.I# (GHC.Prim.+# dt11 y))
                                w })
                             (GHC.Types.[]
                                @ (Data.Set.Internal.Set
                                     (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                               `cast`
                             (Sym (Text.Megaparsec.N:Hints[0]
                                       <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                        GHC.Types.True
                        -> eerr
                             (Text.Megaparsec.Error.TrivialError
                                @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                @ e
                                (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos npos z1)
                                (GHC.Base.Just
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   (Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                ps)
                             (Text.Megaparsec.$WState
                                @ [GHC.Types.Char]
                                input
                                (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos apos z1)
                                (GHC.Types.I# dt11)
                                w) } } } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Maybe GHC.Base.String>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
f9bd74cafad15372e92f4f49cc3731b1
  $s$fMonadParsecesParsecT_$spTakeWhile1P ::
    GHC.Base.Maybe GHC.Base.String
    -> (Text.Megaparsec.Stream.Token [GHC.Types.Char]
        -> GHC.Types.Bool)
    -> Text.Megaparsec.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,1*U><L,C(U)>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Base.Maybe GHC.Base.String)
                   (f20 :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                           -> GHC.Types.Bool)
                   @ b
                   (ds :: Text.Megaparsec.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State [GHC.Types.Char] -> m b)
                   (ds2 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b) ->
                 case ds of wild { Text.Megaparsec.State input ds3 dt11 w ->
                 case ds3 of wild1 { Data.List.NonEmpty.:| pos z1 ->
                 let {
                   el2 :: GHC.Base.Maybe
                            (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   = case ml of wild2 {
                       GHC.Base.Nothing
                       -> GHC.Base.Nothing
                            @ (Text.Megaparsec.Error.ErrorItem
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                       GHC.Base.Just x
                       -> case x of wild3 {
                            []
                            -> GHC.Base.Nothing
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                            : a1 as2
                            -> GHC.Base.Just
                                 @ (Text.Megaparsec.Error.ErrorItem
                                      (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                 (Text.Megaparsec.Error.Label
                                    @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                    (Data.List.NonEmpty.:| @ GHC.Types.Char a1 as2)) } }
                 } in
                 let {
                   ds4 :: ([GHC.Types.Char], [GHC.Types.Char])
                   = GHC.List.span
                       @ GHC.Types.Char
                       f20
                         `cast`
                       (Sub (Text.Megaparsec.Stream.D:R:Token[][0])
                        ->_R <GHC.Types.Bool>_R)
                       input
                 } in
                 let {
                   ts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                   = case ds4
                            `cast`
                          ((,)
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                             <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                     ts1 }
                 } in
                 case ds4
                        `cast`
                      ((,)
                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                         <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                 case ts1
                        `cast`
                      (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild4 {
                   []
                   -> case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                      eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos apos z1)
                           (GHC.Base.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (case input of wild5 {
                                 []
                                 -> Text.Megaparsec.Error.EndOfInput
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                 : t ts2
                                 -> Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         t `cast`
                                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))) }))
                           (case el2 of wild3 {
                              GHC.Base.Nothing
                              -> Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              GHC.Base.Just x
                              -> Data.Set.Internal.singleton
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   x }))
                        (Text.Megaparsec.$WState
                           @ [GHC.Types.Char]
                           input
                           (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos apos z1)
                           (GHC.Types.I# dt11)
                           w) }
                   : ds7 ds8
                   -> case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                             (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                             w
                             pos
                             ts of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                      cok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.$WState
                           @ [GHC.Types.Char]
                           input'
                           (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos npos z1)
                           (GHC.Types.I# (GHC.Prim.+# dt11 ww2))
                           w })
                        (case el2 of wild3 {
                           GHC.Base.Nothing
                           -> (GHC.Types.[]
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                `cast`
                              (Sym (Text.Megaparsec.N:Hints[0]
                                        <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           GHC.Base.Just l
                           -> (GHC.Base.build
                                 @ (Data.Set.Internal.Set
                                      (Text.Megaparsec.Error.ErrorItem
                                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 (\ @ a1
                                    (c :: Data.Set.Internal.Set
                                            (Text.Megaparsec.Error.ErrorItem
                                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                          -> a1 -> a1)[OneShot]
                                    (n20 :: a1)[OneShot] ->
                                  c (Data.Set.Internal.singleton
                                       @ (Text.Megaparsec.Error.ErrorItem
                                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                       l)
                                    n20))
                                `cast`
                              (Sym (Text.Megaparsec.N:Hints[0]
                                        <Text.Megaparsec.Stream.Token
                                           [GHC.Types.Char]>_N)) }) } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Maybe GHC.Base.String>_R
                 ->_R <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                       -> GHC.Types.Bool>_R
                 ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
9460de6f12edb66330ff3e2f9b201782
  $s$fMonadParsecesParsecT_$spTakeWhileP ::
    GHC.Base.Maybe GHC.Base.String
    -> (Text.Megaparsec.Stream.Token [GHC.Types.Char]
        -> GHC.Types.Bool)
    -> Text.Megaparsec.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 7,
     Strictness: <L,1*U><L,C(U)><S(SS(S(LSS)L)LL),1*U(1*U,1*U(1*U(U,U,U),U),U,U(U))><L,1*C1(C1(C1(U)))><L,A><L,1*C1(C1(C1(U)))><L,A>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (ml :: GHC.Base.Maybe GHC.Base.String)
                   (f20 :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                           -> GHC.Types.Bool)
                   @ b
                   (ds :: Text.Megaparsec.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds1 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State [GHC.Types.Char] -> m b)
                   (eok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds2 :: Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                           -> Text.Megaparsec.State [GHC.Types.Char] -> m b) ->
                 case ds of wild { Text.Megaparsec.State input ds3 dt11 w ->
                 case ds3 of wild1 { Data.List.NonEmpty.:| pos z1 ->
                 let {
                   hs :: Text.Megaparsec.Hints
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                   = case ml of wild2 {
                       GHC.Base.Nothing
                       -> (GHC.Types.[]
                             @ (Data.Set.Internal.Set
                                  (Text.Megaparsec.Error.ErrorItem
                                     (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                            `cast`
                          (Sym (Text.Megaparsec.N:Hints[0]
                                    <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                       GHC.Base.Just x
                       -> case x of wild3 {
                            []
                            -> (GHC.Types.[]
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                 `cast`
                               (Sym (Text.Megaparsec.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                            : a1 as2
                            -> (GHC.Base.build
                                  @ (Data.Set.Internal.Set
                                       (Text.Megaparsec.Error.ErrorItem
                                          (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                  (\ @ a2
                                     (c :: Data.Set.Internal.Set
                                             (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                           -> a2 -> a2)[OneShot]
                                     (n20 :: a2)[OneShot] ->
                                   c (Data.Set.Internal.$WBin
                                        @ (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                        (GHC.Types.I# 1#)
                                        (Text.Megaparsec.Error.Label
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           (Data.List.NonEmpty.:| @ GHC.Types.Char a1 as2))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                        (Data.Set.Internal.Tip
                                           @ (Text.Megaparsec.Error.ErrorItem
                                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                     n20))
                                 `cast`
                               (Sym (Text.Megaparsec.N:Hints[0]
                                         <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)) } }
                 } in
                 let {
                   ds4 :: ([GHC.Types.Char], [GHC.Types.Char])
                   = GHC.List.span
                       @ GHC.Types.Char
                       f20
                         `cast`
                       (Sub (Text.Megaparsec.Stream.D:R:Token[][0])
                        ->_R <GHC.Types.Bool>_R)
                       input
                 } in
                 let {
                   ts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                   = case ds4
                            `cast`
                          ((,)
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                             <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                     ts1 }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                        (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                        w
                        pos
                        ts of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                 case ds4
                        `cast`
                      ((,)
                         (Sub (Sym (Text.Megaparsec.Stream.D:R:Tokens[][0])))
                         <[GHC.Types.Char]>_R)_R of wild2 { (,) ts1 input' ->
                 case ts1
                        `cast`
                      (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild4 {
                   []
                   -> eok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.$WState
                           @ [GHC.Types.Char]
                           input'
                           (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos npos z1)
                           (GHC.Types.I# (GHC.Prim.+# dt11 ww2))
                           w })
                        hs
                   : ds7 ds8
                   -> cok
                        ts
                        (case GHC.List.$wlenAcc
                                @ GHC.Types.Char
                                ts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                0# of ww2 { DEFAULT ->
                         Text.Megaparsec.$WState
                           @ [GHC.Types.Char]
                           input'
                           (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos npos z1)
                           (GHC.Types.I# (GHC.Prim.+# dt11 ww2))
                           w })
                        hs } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <GHC.Base.Maybe GHC.Base.String>_R
                 ->_R <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                       -> GHC.Types.Bool>_R
                 ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
1d97bc8a8fe2fc8dd4784512f35f920c
  $s$fMonadParsecesParsecT_$spToken ::
    (Text.Megaparsec.Stream.Token [GHC.Types.Char]
     -> Data.Either.Either
          (GHC.Base.Maybe
             (Text.Megaparsec.Error.ErrorItem
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])),
           Data.Set.Internal.Set
             (Text.Megaparsec.Error.ErrorItem
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
          a)
    -> GHC.Base.Maybe (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.ParsecT e [GHC.Types.Char] m a
  {- Arity: 2, Strictness: <L,C(U)><L,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   @ a
                   (test :: Text.Megaparsec.Stream.Token [GHC.Types.Char]
                            -> Data.Either.Either
                                 (GHC.Base.Maybe
                                    (Text.Megaparsec.Error.ErrorItem
                                       (Text.Megaparsec.Stream.Token [GHC.Types.Char])),
                                  Data.Set.Internal.Set
                                    (Text.Megaparsec.Error.ErrorItem
                                       (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                 a)
                   (mtoken :: GHC.Base.Maybe
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   @ b
                   (s1 :: Text.Megaparsec.State [GHC.Types.Char])
                   (cok :: a
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                          -> Text.Megaparsec.State [GHC.Types.Char] -> m b)
                   (ds1 :: a
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State input ds2 dt11 w ->
                 case ds2 of wild1 { Data.List.NonEmpty.:| pos z1 ->
                 case input of wild2 {
                   []
                   -> eerr
                        (Text.Megaparsec.Error.TrivialError
                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           @ e
                           (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos pos z1)
                           (GHC.Base.Just
                              @ (Text.Megaparsec.Error.ErrorItem
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              (Text.Megaparsec.Error.EndOfInput
                                 @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                           (case mtoken of wild3 {
                              GHC.Base.Nothing
                              -> Data.Set.Internal.Tip
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                              GHC.Base.Just x
                              -> Data.Set.Internal.$WBin
                                   @ (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                                   (GHC.Types.I# 1#)
                                   (Text.Megaparsec.Error.Tokens
                                      @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      (Text.Megaparsec.nes
                                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                         x))
                                   (Data.Set.Internal.Tip
                                      @ (Text.Megaparsec.Error.ErrorItem
                                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                                   (Data.Set.Internal.Tip
                                      @ (Text.Megaparsec.Error.ErrorItem
                                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))) }))
                        wild
                   : t ts
                   -> case test
                             t `cast`
                             (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))) of wild4 {
                        Data.Either.Left ds4
                        -> case ds4 of wild5 { (,) us ps ->
                           case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           eerr
                             (Text.Megaparsec.Error.TrivialError
                                @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                @ e
                                (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos apos z1)
                                us
                                ps)
                             (Text.Megaparsec.$WState
                                @ [GHC.Types.Char]
                                wild2
                                (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos apos z1)
                                (GHC.Types.I# dt11)
                                w) } }
                        Data.Either.Right x
                        -> case Text.Megaparsec.Stream.$fStream[]_$cadvance1
                                  (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                                  w
                                  pos
                                  t `cast`
                                  (Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))) of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           cok
                             x
                             (Text.Megaparsec.$WState
                                @ [GHC.Types.Char]
                                ts
                                (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos npos z1)
                                (GHC.Types.I# (GHC.Prim.+# dt11 1#))
                                w)
                             (GHC.Types.[]
                                @ (Data.Set.Internal.Set
                                     (Text.Megaparsec.Error.ErrorItem
                                        (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                               `cast`
                             (Sym (Text.Megaparsec.N:Hints[0]
                                       <Text.Megaparsec.Stream.Token
                                          [GHC.Types.Char]>_N)) } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N) (a :: <*>_N).
                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]
                  -> Data.Either.Either
                       (GHC.Base.Maybe
                          (Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])),
                        Data.Set.Internal.Set
                          (Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                       a>_R
                 ->_R <GHC.Base.Maybe
                         (Text.Megaparsec.Stream.Token [GHC.Types.Char])>_R
                 ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                               <e>_N <[GHC.Types.Char]>_N <m>_R <a>_R)) -}
ca35a11c1eb287c6ab0604017e4d1362
  $s$fMonadParsecesParsecT_$spTokens ::
    (Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
     -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
     -> GHC.Types.Bool)
    -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
    -> Text.Megaparsec.ParsecT
         e
         [GHC.Types.Char]
         m
         (Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
  {- Arity: 2, Strictness: <L,C(C1(U))><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ e
                   @ m :: * -> *
                   (f20 :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> GHC.Types.Bool)
                   (tts :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char])
                   @ b
                   (s1 :: Text.Megaparsec.State [GHC.Types.Char])
                   (cok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (ds :: Text.Megaparsec.Error.ParseError
                            (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                          -> Text.Megaparsec.State [GHC.Types.Char] -> m b)
                   (eok :: Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> m b)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                            -> Text.Megaparsec.State [GHC.Types.Char] -> m b) ->
                 case s1 of wild { Text.Megaparsec.State input ds1 dt11 w ->
                 case ds1 of wild1 { Data.List.NonEmpty.:| pos z1 ->
                 let {
                   unexpect :: Data.List.NonEmpty.NonEmpty
                                 Text.Megaparsec.Pos.SourcePos
                               -> Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                               -> Text.Megaparsec.Error.ParseError
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char]) e
                     {- Arity: 2 -}
                   = \ (pos' :: Data.List.NonEmpty.NonEmpty
                                  Text.Megaparsec.Pos.SourcePos)
                       (u :: Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                     Text.Megaparsec.Error.TrivialError
                       @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                       @ e
                       pos'
                       (GHC.Base.Just
                          @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          u)
                       (Data.Set.Internal.$WBin
                          @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          (GHC.Types.I# 1#)
                          (Text.Megaparsec.Error.Tokens
                             @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             (case tts
                                     `cast`
                                   (Trans
                                        (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                        ([Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))])_R) of wild2 {
                                []
                                -> Data.List.NonEmpty.fromList1
                                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                : a1 as2
                                -> Data.List.NonEmpty.:|
                                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                     a1
                                     as2 }))
                          (Data.Set.Internal.Tip
                             @ (Text.Megaparsec.Error.ErrorItem
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                          (Data.Set.Internal.Tip
                             @ (Text.Megaparsec.Error.ErrorItem
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                 } in
                 let {
                   len :: GHC.Types.Int
                   = case GHC.List.$wlenAcc
                            @ GHC.Types.Char
                            tts `cast` (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                            0# of ww2 { DEFAULT ->
                     GHC.Types.I# ww2 }
                 } in
                 case Text.Megaparsec.Stream.$fStream[]_$ctakeN_
                        len
                        input of wild2 {
                   GHC.Base.Nothing
                   -> eerr
                        (unexpect
                           (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos pos z1)
                           (Text.Megaparsec.Error.EndOfInput
                              @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                        wild
                   GHC.Base.Just ds2
                   -> case ds2 of wild3 { (,) tts' input' ->
                      case f20 tts tts' of wild4 {
                        GHC.Types.False
                        -> case pos of apos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           eerr
                             (unexpect
                                (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos apos z1)
                                (Text.Megaparsec.Error.Tokens
                                   @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                   (case tts'
                                           `cast`
                                         (Trans
                                              (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0]))
                                              ([Sub (Sym (Text.Megaparsec.Stream.D:R:Token[][0]))])_R) of wild5 {
                                      []
                                      -> Data.List.NonEmpty.fromList1
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                      : a1 as2
                                      -> Data.List.NonEmpty.:|
                                           @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                                           a1
                                           as2 })))
                             (Text.Megaparsec.$WState
                                @ [GHC.Types.Char]
                                input
                                (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos apos z1)
                                (GHC.Types.I# dt11)
                                w) }
                        GHC.Types.True
                        -> case Text.Megaparsec.Stream.$fStream[]_$cadvanceN
                                  (Data.Proxy.Proxy @ * @ [GHC.Types.Char])
                                  w
                                  pos
                                  tts' of npos { Text.Megaparsec.Pos.SourcePos ipv ipv1 ipv2 ->
                           let {
                             st :: Text.Megaparsec.State [GHC.Types.Char]
                             = case len of wild5 { GHC.Types.I# y ->
                               Text.Megaparsec.$WState
                                 @ [GHC.Types.Char]
                                 input'
                                 (Data.List.NonEmpty.:| @ Text.Megaparsec.Pos.SourcePos npos z1)
                                 (GHC.Types.I# (GHC.Prim.+# dt11 y))
                                 w }
                           } in
                           case tts
                                  `cast`
                                (Sub (Text.Megaparsec.Stream.D:R:Tokens[][0])) of wild7 {
                             []
                             -> eok
                                  tts'
                                  st
                                  (GHC.Types.[]
                                     @ (Data.Set.Internal.Set
                                          (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                    `cast`
                                  (Sym (Text.Megaparsec.N:Hints[0]
                                            <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                             : ds4 ds5
                             -> cok
                                  tts'
                                  st
                                  (GHC.Types.[]
                                     @ (Data.Set.Internal.Set
                                          (Text.Megaparsec.Error.ErrorItem
                                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))))
                                    `cast`
                                  (Sym (Text.Megaparsec.N:Hints[0]
                                            <Text.Megaparsec.Stream.Token
                                               [GHC.Types.Char]>_N)) } } } } } } })
                  `cast`
                (forall (e :: <*>_N) (m :: <* -> *>_N).
                 <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                  -> Text.Megaparsec.Stream.Tokens [GHC.Types.Char]
                  -> GHC.Types.Bool>_R
                 ->_R <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R
                 ->_R Sym (Text.Megaparsec.N:ParsecT[0]
                               <e>_N
                               <[GHC.Types.Char]>_N
                               <m>_R
                               <Text.Megaparsec.Stream.Tokens [GHC.Types.Char]>_R)) -}
2255fed38542bf2b78bfcbac37fb2791
  $s$fOrdErrorFancy ::
    GHC.Classes.Ord (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                  Lib.$s$fEqErrorFancy
                  (Text.Megaparsec.Error.$fOrdErrorFancy_$ccompare
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid)
                  (Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid)
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          b
                          a of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                     @ Data.Void.Void
                     Data.Void.$fOrdVoid
                     b
                     a)
                  (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          y
                          x of wild {
                     GHC.Types.False -> y GHC.Types.True -> x })
                  (\ (x :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                     (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                   case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                          @ Data.Void.Void
                          Data.Void.$fOrdVoid
                          y
                          x of wild {
                     GHC.Types.False -> x GHC.Types.True -> y }) -}
ab8499bfd3eb20f9a48fdf704327bd2e
  $s$fOrdErrorFancy_$c<= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        b
                        a of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
17ff2cc759ae631a6b06db66efb94785
  $s$fOrdErrorFancy_$c>= ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (b :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
589cb848ca73098ca8a3a692e052241d
  $s$fOrdErrorFancy_$cmax ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        y
                        x of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
2db423194b8541f610037ec6d7cfb251
  $s$fOrdErrorFancy_$cmin ::
    Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
    -> Text.Megaparsec.Error.ErrorFancy Data.Void.Void
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void)
                   (y :: Text.Megaparsec.Error.ErrorFancy Data.Void.Void) ->
                 case Text.Megaparsec.Error.$fOrdErrorFancy_$c<
                        @ Data.Void.Void
                        Data.Void.$fOrdVoid
                        y
                        x of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
a223906f83faf96a756662f9459268ee
  $s$fOrdErrorItem ::
    GHC.Classes.Ord
      (Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Text.Megaparsec.Error.ErrorItem
                       (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                  Lib.$s$fEqErrorItem
                  (Text.Megaparsec.Error.$fOrdErrorItem_$ccompare
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  (Text.Megaparsec.Error.$fOrdErrorItem_$c<
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R)
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          b
                          a of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   Text.Megaparsec.Error.$fOrdErrorItem_$c<
                     @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                     GHC.Classes.$fOrdChar
                       `cast`
                     (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                     b
                     a)
                  (\ (a :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (b :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          a
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (y :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          y
                          x of wild {
                     GHC.Types.False -> y GHC.Types.True -> x })
                  (\ (x :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                     (y :: Text.Megaparsec.Error.ErrorItem
                             (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                   case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                          @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                          GHC.Classes.$fOrdChar
                            `cast`
                          (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                          y
                          x of wild {
                     GHC.Types.False -> x GHC.Types.True -> y }) -}
55b30a43f73528ce7163fa30ba488bd3
  $s$fOrdErrorItem_$c<= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (b :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        b
                        a of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
c482316aeea85c3be1cca8d24b991b99
  $s$fOrdErrorItem_$c>= ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (b :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        a
                        b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
de54b6b70e3e6506b58c6ec932c2b0b4
  $s$fOrdErrorItem_$cmax ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        y
                        x of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
c2fa4e6857a4fa81b0ff5f8afa774ccc
  $s$fOrdErrorItem_$cmin ::
    Text.Megaparsec.Error.ErrorItem
      (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
    -> Text.Megaparsec.Error.ErrorItem
         (Text.Megaparsec.Stream.Token [GHC.Types.Char])
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                   (y :: Text.Megaparsec.Error.ErrorItem
                           (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                 case Text.Megaparsec.Error.$fOrdErrorItem_$c<
                        @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                        GHC.Classes.$fOrdChar
                          `cast`
                        (GHC.Classes.Ord (Sym (Text.Megaparsec.Stream.D:R:Token[][0])))_R
                        y
                        x of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
ba476aaefc2fe693ab4aca883b721e69
  $sinsertR_go3 ::
    GHC.Classes.Ord a1 =>
    a1 -> a1 -> Data.Set.Internal.Set a1 -> Data.Set.Internal.Set a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U><S,1*U> -}
ea501560d2e2604d38e54b04675121f0
  $sinsert_go3 ::
    GHC.Classes.Ord a1 =>
    a1 -> a1 -> Data.Set.Internal.Set a1 -> Data.Set.Internal.Set a1
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U><S,1*U> -}
6c622125e3255a823fb388fc1b3c4271
  $tc'Assignment :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11415007780013723055##
                   17637614066049871672##
                   Lib.$trModule
                   Lib.$tc'Assignment2
                   0#
                   Lib.$tc'Assignment1) -}
f33aff57d3573a8a4dbbdb80f8ebeb22
  $tc'Assignment1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c236d62d89d40c1e7a4298dfd8d2761c
  $tc'Assignment2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'Assignment3) -}
843740d5ec9205ba1a6dc5e7dec92372
  $tc'Assignment3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Assignment"#) -}
53a98a9a603f85a3e990629396148212
  $tc'AssignmentStatement :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18025616141591102594##
                   7989879102116291818##
                   Lib.$trModule
                   Lib.$tc'AssignmentStatement2
                   0#
                   Lib.$tc'AssignmentStatement1) -}
81c34af2fbb96a9437cbe6366209b39d
  $tc'AssignmentStatement1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
cef9d2f900c3cf84b78d6ab48c0b0788
  $tc'AssignmentStatement2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'AssignmentStatement3) -}
1f77e747ca34d82e0741025122d7999f
  $tc'AssignmentStatement3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'AssignmentStatement"#) -}
30b8dee2f2e583926bcf1c58a35119f9
  $tc'BinaryOperator :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8038046841591552006##
                   8654885755015499574##
                   Lib.$trModule
                   Lib.$tc'BinaryOperator2
                   0#
                   Lib.$tc'BinaryOperator1) -}
a49543793f26de46c87a10ab15c5592d
  $tc'BinaryOperator1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
38cd7f05e198bc863f558a2b52ac2cac
  $tc'BinaryOperator2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'BinaryOperator3) -}
be481f12b8bdbcbc1e127e167de337f9
  $tc'BinaryOperator3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BinaryOperator"#) -}
037d1bc30974ff918ee9d01eb0fdbec2
  $tc'BoolConstant :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9063560862444369774##
                   8104844535497585004##
                   Lib.$trModule
                   Lib.$tc'BoolConstant2
                   0#
                   Lib.$tc'BoolConstant1) -}
4e7376156b2a9fedcc1a5a2641ba8bcf
  $tc'BoolConstant1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a3b295e47a9cda37dd2082f04076d862
  $tc'BoolConstant2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'BoolConstant3) -}
55ff92a4d555c97a0a1ecd0764467631
  $tc'BoolConstant3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BoolConstant"#) -}
eb2c09e6e75e9188f4292ad2a771d31b
  $tc'BoolType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5523660036067477180##
                   5528517098856430988##
                   Lib.$trModule
                   Lib.$tc'BoolType2
                   0#
                   Lib.$tc'BoolType1) -}
2ad771264db65e82c4458a93aaec44d8
  $tc'BoolType1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
9a88285621263e5fdd34477c03bf3364
  $tc'BoolType2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'BoolType3) -}
370cfcd77ac2dc86dfe4ba7ba2e333f8
  $tc'BoolType3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BoolType"#) -}
1e5f58ea7752515592e718e813f80e76
  $tc'BracesExpression :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6067872990311680482##
                   17029228171878977729##
                   Lib.$trModule
                   Lib.$tc'BracesExpression2
                   0#
                   Lib.$tc'BracesExpression1) -}
268536747b9fca5518df653ad25d8cba
  $tc'BracesExpression1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ec073833c5788843e88854293a387ea8
  $tc'BracesExpression2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'BracesExpression3) -}
5306259c53d9e8a24ba0f23f710f8840
  $tc'BracesExpression3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BracesExpression"#) -}
ead7d277c1115af9b7f6bedf3d2b46b9
  $tc'ConstantExpression :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6516016573184137982##
                   15133517363727791327##
                   Lib.$trModule
                   Lib.$tc'ConstantExpression2
                   0#
                   Lib.$tc'ConstantExpression1) -}
eb680aeea9cabf30b56feaca416579c4
  $tc'ConstantExpression1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
73898118e0c8f15e3bcde9ce845fde93
  $tc'ConstantExpression2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'ConstantExpression3) -}
f5dcbb14f08cd03e96c6d12c74fd55e9
  $tc'ConstantExpression3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ConstantExpression"#) -}
55410c2db3083b4cd2de5b4d71a54d48
  $tc'DBComandStatement :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11391677870279846977##
                   2617506898151578210##
                   Lib.$trModule
                   Lib.$tc'DBComandStatement2
                   0#
                   Lib.$tc'DBComandStatement1) -}
d018fa41270b580aeffb96bacb26b099
  $tc'DBComandStatement1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c995fc55004d9ebd74b1e0f269402a77
  $tc'DBComandStatement2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'DBComandStatement3) -}
7ab54ace373be8084e5cb6c0c903d2be
  $tc'DBComandStatement3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DBComandStatement"#) -}
58d51e452173ba236be265fa27bb1067
  $tc'IfThenElse :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6869448035709189991##
                   12512491459920617705##
                   Lib.$trModule
                   Lib.$tc'IfThenElse2
                   0#
                   Lib.$tc'IfThenElse1) -}
d17c5a551cde0cd2de7d0e7ddcf2201b
  $tc'IfThenElse1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ee852bfd19bef694c2adfb1b2f8d54a2
  $tc'IfThenElse2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'IfThenElse3) -}
f2ca64fbabcd6427efb16bd4443a1090
  $tc'IfThenElse3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IfThenElse"#) -}
c197e3a85c8848e8e993b832595c660d
  $tc'IfThenElseExpression :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1109116277580446316##
                   5404980941311183785##
                   Lib.$trModule
                   Lib.$tc'IfThenElseExpression2
                   0#
                   Lib.$tc'IfThenElseExpression1) -}
daafdee515af8bc056b7c3122152384c
  $tc'IfThenElseExpression1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
2e0c0aa4b734987d16dc6b7f24c6d36d
  $tc'IfThenElseExpression2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'IfThenElseExpression3) -}
357e7f3f5b2bbfefb1c647e3632e4798
  $tc'IfThenElseExpression3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IfThenElseExpression"#) -}
83a0a5c536921019ee8087fe38818e4a
  $tc'IntConstant :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16541687171024787734##
                   1358578195373928751##
                   Lib.$trModule
                   Lib.$tc'IntConstant2
                   0#
                   Lib.$tc'IntConstant1) -}
81c26626606775ec864e0573ed9071ad
  $tc'IntConstant1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
60f8261fae823dc2059da80d5577e765
  $tc'IntConstant2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'IntConstant3) -}
40910e69d1f84ac664abded411649cda
  $tc'IntConstant3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IntConstant"#) -}
c57fe88d249bbb9e8ac9ad9f88c7f5ff
  $tc'IntType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9276084411913021784##
                   4404310810788998075##
                   Lib.$trModule
                   Lib.$tc'IntType1
                   0#
                   Lib.$tc'BoolType1) -}
ba19bf878c548e959e4dbbc1c22bb7e4
  $tc'IntType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'IntType2) -}
42a1b6c70807bc2a8b7349ebad96c47c
  $tc'IntType2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'IntType"#) -}
866d3a68a75492355ef71a57a7ab9879
  $tc'Invocation :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11672656191873637568##
                   4400760720784876836##
                   Lib.$trModule
                   Lib.$tc'Invocation2
                   0#
                   Lib.$tc'Invocation1) -}
4525451ec554722743dd0e7f3af9aaba
  $tc'Invocation1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
31a3d179dbdc70e5ce0e37ee360f28d0
  $tc'Invocation2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'Invocation3) -}
e63ba2d355bd9ad2d8214794fcdbab0a
  $tc'Invocation3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Invocation"#) -}
08ea47cb7898b1250aba6289b6775387
  $tc'InvocationExpression :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1550659569901230828##
                   4082095773169721781##
                   Lib.$trModule
                   Lib.$tc'InvocationExpression2
                   0#
                   Lib.$tc'InvocationExpression1) -}
ac3f133453e91b4942ef938541880d32
  $tc'InvocationExpression1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
fcef32b3b246567c07e516d2b6b0a488
  $tc'InvocationExpression2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'InvocationExpression3) -}
dddc946cb6d59e491ce43bd88b228593
  $tc'InvocationExpression3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'InvocationExpression"#) -}
decb6c9d4e3f84f3b2bfd816ae093efe
  $tc'InvocationStatement :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12091442648201272021##
                   2740119101772412070##
                   Lib.$trModule
                   Lib.$tc'InvocationStatement2
                   0#
                   Lib.$tc'InvocationStatement1) -}
f224dd59e04e2443967bb042fcc7984a
  $tc'InvocationStatement1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
4c32a8230238156cf404da9ea4e7d7b7
  $tc'InvocationStatement2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'InvocationStatement3) -}
cf90eda7584fbfe50a682c799b6d3326
  $tc'InvocationStatement3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'InvocationStatement"#) -}
e589cd6cb52c5247be9b30abba603cb6
  $tc'LambdaDef :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10429874755432717336##
                   7592185593586089170##
                   Lib.$trModule
                   Lib.$tc'LambdaDef2
                   0#
                   Lib.$tc'LambdaDef1) -}
ee557d02d58678c0585d879014cdbff9
  $tc'LambdaDef1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7c791633fa7207af8745a6966220d849
  $tc'LambdaDef2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'LambdaDef3) -}
525bdbc4538442fe6491ab1a1fc72173
  $tc'LambdaDef3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LambdaDef"#) -}
d0eae5209d2342a36ad044a6461f8477
  $tc'LambdaDefExpression :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10189275514069284708##
                   14004905160799907854##
                   Lib.$trModule
                   Lib.$tc'LambdaDefExpression2
                   0#
                   Lib.$tc'LambdaDefExpression1) -}
937b731c630e8ce7f8c08089395aef02
  $tc'LambdaDefExpression1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ffbc4720b77a3af5812c8292665d1b4c
  $tc'LambdaDefExpression2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'LambdaDefExpression3) -}
a8b06c04e58d5fd5a70bdd554d02a54f
  $tc'LambdaDefExpression3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LambdaDefExpression"#) -}
8b6e2908682c53a7d0d06c36a3c74be2
  $tc'LoadComand :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12923086563506934206##
                   430839780732966054##
                   Lib.$trModule
                   Lib.$tc'LoadComand2
                   0#
                   Lib.$tc'LoadComand1) -}
130d797fe9acd9a98d37c8ff4a64b11e
  $tc'LoadComand1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a9d46cfadd3381e9a26459d4bae5de8d
  $tc'LoadComand2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'LoadComand3) -}
f71cec838d18f95cd434452c085ed614
  $tc'LoadComand3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LoadComand"#) -}
58e5c5d38a3fbae3fa26c316f1e0dd3b
  $tc'LoadDBComand :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1013546446994746982##
                   15321024899483523847##
                   Lib.$trModule
                   Lib.$tc'LoadDBComand2
                   0#
                   Lib.$tc'LoadDBComand1) -}
5b47d1d1b5d07368807303c97e943c45
  $tc'LoadDBComand1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
14b7d903e4a03266f5dc2a14b8b97465
  $tc'LoadDBComand2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'LoadDBComand3) -}
a0c3f214097ba77ff36665fdd1a538f0
  $tc'LoadDBComand3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LoadDBComand"#) -}
2129d789a9ba02460bee2c82139905eb
  $tc'LoopStatement :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17005619847606089554##
                   16701516927803109174##
                   Lib.$trModule
                   Lib.$tc'LoopStatement2
                   0#
                   Lib.$tc'LoopStatement1) -}
611fe074d8a759d5769dea83480656c2
  $tc'LoopStatement1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
74e389dfa6c888347615775d4c2aeb58
  $tc'LoopStatement2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'LoopStatement3) -}
98d0521bc4efd304b2357a400c52106d
  $tc'LoopStatement3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LoopStatement"#) -}
1829a89b85f047b3be490ea9d81cc893
  $tc'OperatorExpression :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4446331864137195844##
                   11091423838076093542##
                   Lib.$trModule
                   Lib.$tc'OperatorExpression2
                   0#
                   Lib.$tc'OperatorExpression1) -}
db87523511e4147d97c4b730483fdb42
  $tc'OperatorExpression1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f6867308f5889f0486ea78d5bf943d34
  $tc'OperatorExpression2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'OperatorExpression3) -}
b2c46101f7c2f0e1a8c68dc61a064086
  $tc'OperatorExpression3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'OperatorExpression"#) -}
761f76fe4281e17a88dddafe44334ca0
  $tc'Program :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1227328107344755845##
                   1923723848824518998##
                   Lib.$trModule
                   Lib.$tc'Program2
                   0#
                   Lib.$tc'Program1) -}
b15cb1f4b83c303a5f401ba3f5b21f36
  $tc'Program1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
9d0a7313048ed77a982d2455af0d7cbc
  $tc'Program2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'Program3) -}
3c001f728f5caaee1ab991e141c011ad
  $tc'Program3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Program"#) -}
7806473e91121beb09e85f80beafe73e
  $tc'PublishComand :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13393522063314092131##
                   389785359478024979##
                   Lib.$trModule
                   Lib.$tc'PublishComand2
                   0#
                   Lib.$tc'PublishComand1) -}
080306e0a198654b6f758f52a5ca4477
  $tc'PublishComand1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0586b4ee8d8f3f617b956bd82f325555
  $tc'PublishComand2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'PublishComand3) -}
c254529ef20048ac21d9cf43b72ad4b8
  $tc'PublishComand3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PublishComand"#) -}
4f3b5accdd263be090a45419c2b588fd
  $tc'PublishDBComand :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15475999201372879562##
                   15496077895504313498##
                   Lib.$trModule
                   Lib.$tc'PublishDBComand2
                   0#
                   Lib.$tc'PublishDBComand1) -}
6642b9f8d293732dc0191efbdd9820d4
  $tc'PublishDBComand1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
eb7c81b73b321269b5f5c2514db9913e
  $tc'PublishDBComand2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'PublishDBComand3) -}
e89abc38223ac537c426dbdaafda20f2
  $tc'PublishDBComand3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'PublishDBComand"#) -}
44d8bcfb1167bf2a94a59025137ff1c7
  $tc'ReturnStatement :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6157511120815373038##
                   11067203875099284545##
                   Lib.$trModule
                   Lib.$tc'ReturnStatement2
                   0#
                   Lib.$tc'ReturnStatement1) -}
4f88dd9cb64cc16cb9b60ff7d711bf0f
  $tc'ReturnStatement1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
74c5b377b45cc567b9c5e61e3a979c27
  $tc'ReturnStatement2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'ReturnStatement3) -}
7068f9f42c10dc37ea90c635238dc6f9
  $tc'ReturnStatement3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ReturnStatement"#) -}
2d11b976075e6efce7097c149e1d9e0f
  $tc'StringConstant :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10982150992939445301##
                   443565574504768464##
                   Lib.$trModule
                   Lib.$tc'StringConstant2
                   0#
                   Lib.$tc'StringConstant1) -}
edda270d8d953ced2d4c1a0deba79089
  $tc'StringConstant1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
fc1941bf09b4559ff37f73b489e6569d
  $tc'StringConstant2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'StringConstant3) -}
1b1ccf9c6b0cab6c2e828b2e8a18dffb
  $tc'StringConstant3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'StringConstant"#) -}
3d37fd1c4b9cb9728d7c890b10c843eb
  $tc'StringType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11162252310352827215##
                   13955087709222106956##
                   Lib.$trModule
                   Lib.$tc'StringType1
                   0#
                   Lib.$tc'BoolType1) -}
62bef5427910bf85275b84514f144037
  $tc'StringType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'StringType2) -}
8bb499db7322141f776d444797d5db05
  $tc'StringType2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'StringType"#) -}
d4de71c21b4e062c24ec595bbd4bba1c
  $tc'UnaryOperator :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10192850654055016568##
                   7280319935641540518##
                   Lib.$trModule
                   Lib.$tc'UnaryOperator2
                   0#
                   Lib.$tc'UnaryOperator1) -}
7a5d2a724a60ed549097a65f55fcf87b
  $tc'UnaryOperator1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
75a59e4acd072e57c51e5e49a317fe86
  $tc'UnaryOperator2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'UnaryOperator3) -}
510c983cd508ba329cb88ac1b4937f25
  $tc'UnaryOperator3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'UnaryOperator"#) -}
de0b16a65aa27eb1021e4af14009ea78
  $tc'VariableExpression :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2841285438177465534##
                   2042293388773516084##
                   Lib.$trModule
                   Lib.$tc'VariableExpression2
                   0#
                   Lib.$tc'VariableExpression1) -}
1d33d4eff2101495427ffaf3dbc81be3
  $tc'VariableExpression1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8050c700a7f7380ac8dd80852a75caf1
  $tc'VariableExpression2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'VariableExpression3) -}
8582ed83dd2337227dc58d2cd0eb1204
  $tc'VariableExpression3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'VariableExpression"#) -}
4f84c5d01a580abbfb65c355048842f5
  $tc'While :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14228230881381601138##
                   7538401730212779439##
                   Lib.$trModule
                   Lib.$tc'While2
                   0#
                   Lib.$tc'While1) -}
bf93558d3bf284857357b7c64cda7417
  $tc'While1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f6f02cb073fa8a1ddaef61b08d0aaa4d
  $tc'While2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tc'While3) -}
380c5bf5fc67abe85af168ba640aac71
  $tc'While3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'While"#) -}
272c7bfc6b4f933827abb532b9c5343a
  $tcAssignment :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7539723951273190001##
                   10305262341479791288##
                   Lib.$trModule
                   Lib.$tcAssignment1
                   0#
                   GHC.Types.krep$*) -}
c18983fc8b0bf68a030d9c992c83b4ee
  $tcAssignment1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcAssignment2) -}
fcd1466ed65863d7cdab5f29b37da498
  $tcAssignment2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Assignment"#) -}
670698709e7465e9222b48451276afee
  $tcConstant :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9002824498238023646##
                   13396786781331301202##
                   Lib.$trModule
                   Lib.$tcConstant1
                   0#
                   GHC.Types.krep$*) -}
6dd4288ba079806f02c8e64b9a2c4432
  $tcConstant1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcConstant2) -}
8dd2735bba759a2f2c4ce3f9db61892f
  $tcConstant2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Constant"#) -}
f95c230916cb5a997c9957121810ef56
  $tcDBComand :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10012701890283845785##
                   5192203430377359392##
                   Lib.$trModule
                   Lib.$tcDBComand1
                   0#
                   GHC.Types.krep$*) -}
8c037c069fd9da7dd51eadb769a7cc72
  $tcDBComand1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcDBComand2) -}
471f9182b9b35156109542a156751258
  $tcDBComand2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("DBComand"#) -}
c7b4624f804db8ad5b22e004c0bb947d
  $tcExpression :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4733573778524790493##
                   5544253796911783828##
                   Lib.$trModule
                   Lib.$tcExpression1
                   0#
                   GHC.Types.krep$*) -}
277cf73e852c01af9600f118cd5e7293
  $tcExpression1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcExpression2) -}
ff49b7432251705baf3b1f92f590bb10
  $tcExpression2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Expression"#) -}
c917c401b0c3e5d7b3224c3dec002bea
  $tcIfThenElse :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5902832124797784396##
                   2364105122979847616##
                   Lib.$trModule
                   Lib.$tcIfThenElse1
                   0#
                   GHC.Types.krep$*) -}
0f2fb3387956257ebd348d1b1262c70e
  $tcIfThenElse1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcIfThenElse2) -}
445c366de4b343e75ae2c59b96770f21
  $tcIfThenElse2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("IfThenElse"#) -}
d5a7511dd6e80db6cc2097e5a2cc7ac3
  $tcInvocation :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4549096041627909819##
                   6955232520056858328##
                   Lib.$trModule
                   Lib.$tcInvocation1
                   0#
                   GHC.Types.krep$*) -}
06bdccbefb859f10ec73f8677e573523
  $tcInvocation1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcInvocation2) -}
0aee5752ada783e808b8614c5b4fc450
  $tcInvocation2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Invocation"#) -}
0c592801f0289734861869ba559df2f4
  $tcLambdaDef :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13781696080713289403##
                   9600625062303962233##
                   Lib.$trModule
                   Lib.$tcLambdaDef1
                   0#
                   GHC.Types.krep$*) -}
5b43068de83cea00ae1f8ba22b055ec0
  $tcLambdaDef1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcLambdaDef2) -}
818f42f2a06af6cff8106caf12d8145c
  $tcLambdaDef2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LambdaDef"#) -}
a13aa2e0e03a01ac1d32586f61217a59
  $tcLoadComand :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15269023772907194834##
                   7311913918234364773##
                   Lib.$trModule
                   Lib.$tcLoadComand1
                   0#
                   GHC.Types.krep$*) -}
ba98019f829bc4fa1dde56bc17845776
  $tcLoadComand1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcLoadComand2) -}
9e00d8ea8d7d4be7da41a7c7dfb7df82
  $tcLoadComand2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LoadComand"#) -}
d11c9ea3f20685b7a81d69a6038b39d2
  $tcLoop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12001627092632787074##
                   7010507802761231416##
                   Lib.$trModule
                   Lib.$tcLoop1
                   0#
                   GHC.Types.krep$*) -}
21d0c350d6a0ed6e6162a94e040307c7
  $tcLoop1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcLoop2) -}
48fd67648a7e3e96a92ec2129e0fdb5a
  $tcLoop2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Loop"#) -}
2542f1e265a8170e0e048550d379cb51
  $tcOperator :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1364660370653043682##
                   17085817858684868001##
                   Lib.$trModule
                   Lib.$tcOperator1
                   0#
                   GHC.Types.krep$*) -}
73cee45fd7031e72f9f039984dc6c26f
  $tcOperator1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcOperator2) -}
b990875c9bbf48c7623170875910774e
  $tcOperator2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Operator"#) -}
2f763bc8c3f992031e57df1744043587
  $tcOperatorType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8233619935953455282##
                   8850648870321802156##
                   Lib.$trModule
                   Lib.$tcOperatorType1
                   0#
                   GHC.Types.krep$*) -}
a7f3b583c9a4520ba963fd4bf73fe510
  $tcOperatorType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcOperatorType2) -}
40f5f7b3fc83f0aa35e8ecb56e623dd2
  $tcOperatorType2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("OperatorType"#) -}
e1429563f02cdd1e88f0ac78ccecbe08
  $tcProgram :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12239930328235946868##
                   14005215639816513921##
                   Lib.$trModule
                   Lib.$tcProgram1
                   0#
                   GHC.Types.krep$*) -}
60e3c39bd49b0f3257c4c39de017a861
  $tcProgram1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcProgram2) -}
894c6c97775fb1f9e8dd3c85fbbf3624
  $tcProgram2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Program"#) -}
934630e6abe21ef58506f4e3b3f325e1
  $tcPublishComand :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17153126347181655241##
                   2271897474873879213##
                   Lib.$trModule
                   Lib.$tcPublishComand1
                   0#
                   GHC.Types.krep$*) -}
3407b9b4d8070ff3a10bb2efc1c9f16c
  $tcPublishComand1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcPublishComand2) -}
7031525f4410fbb65cf52c017b34578f
  $tcPublishComand2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("PublishComand"#) -}
3bf112fd3ba4f304809a447016642169
  $tcReturnStatement :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5953052251430819236##
                   15123448321236858468##
                   Lib.$trModule
                   Lib.$tcReturnStatement1
                   0#
                   GHC.Types.krep$*) -}
f0f140415da6c0ea37f844ea467dc1bb
  $tcReturnStatement1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcReturnStatement2) -}
23fef5eb267644cbdc86eb4c23bcd67f
  $tcReturnStatement2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ReturnStatement"#) -}
893f2c1b06753448448784f38f753e2d
  $tcStatement :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15887215765346819517##
                   4646916083042093702##
                   Lib.$trModule
                   Lib.$tcStatement1
                   0#
                   GHC.Types.krep$*) -}
4d8354085bf94b26904b0535afe6015f
  $tcStatement1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$tcStatement2) -}
cb178b8d262dd18fa5058f1c36075949
  $tcStatement2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Statement"#) -}
e501a5bcc514c586f78fe10e51febb31
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule3 Lib.$trModule1) -}
45f183dc9b0867c01c8b0954409f9ea0
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$trModule2) -}
4d147f0fbe486f2316112f0089a0c413
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Lib"#) -}
425b6d0295ce1bf23785f4a01ec97b73
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lib.$trModule4) -}
0f2326c8d8bd240e685f99980b90d2a5
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("client-0.1.0.0-3fs91LC6kDPDvpjHZHaccV"#) -}
d2434dc127416df673fccc4dadac7334
  $w$cget ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.Assignment r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <S,U><L,U><S,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success Lib.Assignment r) ->
                 Data.Binary.Class.$w$s$cget2
                   @ r
                   ww
                   ww1
                   ww2
                   ww3
                   (\ (i' :: Data.ByteString.Internal.ByteString)
                      (a1 :: GHC.Base.String)[OneShot] ->
                    case i' of ww4 { Data.ByteString.Internal.PS ww5 ww6 ww7 ww8 ->
                    Lib.$w$cget1
                      @ r
                      ww5
                      ww6
                      ww7
                      ww8
                      (\ (i'1 :: Data.ByteString.Internal.ByteString)
                         (a2 :: Lib.Expression)[OneShot] ->
                       w i'1 (Lib.Assignment a1 a2)) })) -}
d2434dc127416df673fccc4dadac7334
  $w$cget1 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.Expression r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><L,C(C1(U))>,
     Inline: [0] -}
d2434dc127416df673fccc4dadac7334
  $w$cget10 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.LoadComand r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <S,U><L,U><S,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success Lib.LoadComand r) ->
                 Lib.$w$cget1
                   @ r
                   ww
                   ww1
                   ww2
                   ww3
                   (\ (i' :: Data.ByteString.Internal.ByteString)
                      (a1 :: Lib.Expression)[OneShot] ->
                    case i' of ww4 { Data.ByteString.Internal.PS ww5 ww6 ww7 ww8 ->
                    Data.Binary.Class.$w$s$cget2
                      @ r
                      ww5
                      ww6
                      ww7
                      ww8
                      (\ (i'1 :: Data.ByteString.Internal.ByteString)
                         (a2 :: GHC.Base.String)[OneShot] ->
                       w i'1 (Lib.LoadComand a1 a2)) })) -}
d2434dc127416df673fccc4dadac7334
  $w$cget11 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.Loop r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <S,U><L,U><S,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success Lib.Loop r) ->
                 Lib.$w$cget1
                   @ r
                   ww
                   ww1
                   ww2
                   ww3
                   (\ (i' :: Data.ByteString.Internal.ByteString)
                      (a1 :: Lib.Expression)[OneShot] ->
                    case i' of ww4 { Data.ByteString.Internal.PS ww5 ww6 ww7 ww8 ->
                    Data.Binary.Class.$w$cget11
                      @ Lib.Statement
                      Lib.$fBinaryStatement
                      @ r
                      ww5
                      ww6
                      ww7
                      ww8
                      (\ (i'1 :: Data.ByteString.Internal.ByteString)
                         (a2 :: [Lib.Statement])[OneShot] ->
                       w i'1 (Lib.While a1 a2)) })) -}
d2434dc127416df673fccc4dadac7334
  $w$cget12 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.Operator r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><L,C(C1(U))>,
     Inline: [0] -}
e9c0f629e94b1f09f2a96f8603ed9c1b
  $w$cget13 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.OperatorType r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success Lib.OperatorType r) ->
                 let {
                   $wks :: Data.ByteString.Internal.ByteString
                           -> GHC.Prim.Word# -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
                   = \ (w1 :: Data.ByteString.Internal.ByteString)
                       (ww4 :: GHC.Prim.Word#)[OneShot] ->
                     case ww4 of wild {
                       DEFAULT
                       -> case Lib.$fBinaryOperatorType8
                          ret_ty (Data.Binary.Get.Internal.Decoder r)
                          of {}
                       0## -> w w1 Lib.IntType
                       1## -> w w1 Lib.StringType
                       2## -> w w1 Lib.BoolType }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww3 1#) of wild1 {
                   GHC.Types.False
                   -> Data.Binary.Get.Internal.readN1
                        @ GHC.Types.Int
                        @ Data.ByteString.Internal.ByteString
                        Lib.$fBinaryConstant7
                        Lib.$fBinaryConstant6
                        Lib.$fBinaryConstant5
                        Lib.$fBinaryConstant2
                          `cast`
                        (<[Data.ByteString.Internal.ByteString]>_R
                         ->_R Sym (Data.Binary.Get.Internal.N:Get[0]
                                       <Data.ByteString.Internal.ByteString>_R))
                        @ r
                        (Data.ByteString.Internal.PS ww ww1 ww2 ww3)
                        (\ (i' :: Data.ByteString.Internal.ByteString)
                           (a1 :: Data.ByteString.Internal.ByteString) ->
                         case a1 of wild { Data.ByteString.Internal.PS dt11 dt12 dt13 dt14 ->
                         case GHC.Prim.readWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# dt11 dt13)
                                0#
                                GHC.Prim.realWorld# of ds2 { (#,#) ipv ipv1 ->
                         case GHC.Prim.touch#
                                @ 'GHC.Types.LiftedRep
                                @ GHC.ForeignPtr.ForeignPtrContents
                                dt12
                                ipv of s' { DEFAULT ->
                         $wks
                           (Data.ByteString.Internal.PS
                              dt11
                              dt12
                              (GHC.Prim.+# dt13 1#)
                              (GHC.Prim.-# dt14 1#))
                           ipv1 } } })
                   GHC.Types.True
                   -> case GHC.Prim.readWord8OffAddr#
                             @ GHC.Prim.RealWorld
                             (GHC.Prim.plusAddr# ww ww2)
                             0#
                             GHC.Prim.realWorld# of ds2 { (#,#) ipv ipv1 ->
                      case GHC.Prim.touch#
                             @ 'GHC.Types.LiftedRep
                             @ GHC.ForeignPtr.ForeignPtrContents
                             ww1
                             ipv of s' { DEFAULT ->
                      $wks
                        (Data.ByteString.Internal.PS
                           ww
                           ww1
                           (GHC.Prim.+# ww2 1#)
                           (GHC.Prim.-# ww3 1#))
                        ipv1 } } }) -}
134f098db942ee94766d361f69ca06a8
  $w$cget2 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.Constant r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success Lib.Constant r) ->
                 let {
                   lvl136 :: Data.ByteString.Internal.ByteString
                             -> GHC.Types.Bool -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 2, Strictness: <L,U><L,U> -}
                   = \ (i' :: Data.ByteString.Internal.ByteString)
                       (a1 :: GHC.Types.Bool)[OneShot] ->
                     w i' (Lib.BoolConstant a1)
                 } in
                 let {
                   lvl137 :: Data.ByteString.Internal.ByteString
                             -> GHC.Base.String -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 2, Strictness: <L,U><L,U> -}
                   = \ (i' :: Data.ByteString.Internal.ByteString)
                       (a1 :: GHC.Base.String)[OneShot] ->
                     w i' (Lib.StringConstant a1)
                 } in
                 let {
                   lvl138 :: Data.ByteString.Internal.ByteString
                             -> GHC.Types.Int -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 2, Strictness: <L,U><L,U> -}
                   = \ (i' :: Data.ByteString.Internal.ByteString)
                       (a1 :: GHC.Types.Int)[OneShot] ->
                     w i' (Lib.IntConstant a1)
                 } in
                 let {
                   $wks :: GHC.Prim.Addr#
                           -> GHC.ForeignPtr.ForeignPtrContents
                           -> GHC.Prim.Int#
                           -> GHC.Prim.Int#
                           -> GHC.Prim.Word#
                           -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 5, Strictness: <S,U><L,U><S,U><S,U><S,1*U>,
                        Inline: [0] -}
                   = \ (ww4 :: GHC.Prim.Addr#)
                       (ww5 :: GHC.ForeignPtr.ForeignPtrContents)[OneShot]
                       (ww6 :: GHC.Prim.Int#)[OneShot]
                       (ww7 :: GHC.Prim.Int#)[OneShot]
                       (ww8 :: GHC.Prim.Word#)[OneShot] ->
                     case ww8 of wild {
                       DEFAULT
                       -> case Lib.$fBinaryConstant8
                          ret_ty (Data.Binary.Get.Internal.Decoder r)
                          of {}
                       0## -> Data.Binary.Class.$w$cget3 @ r ww4 ww5 ww6 ww7 lvl138
                       1## -> Data.Binary.Class.$w$s$cget2 @ r ww4 ww5 ww6 ww7 lvl137
                       2## -> Data.Binary.Class.$w$cget @ r ww4 ww5 ww6 ww7 lvl136 }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww3 1#) of wild1 {
                   GHC.Types.False
                   -> Data.Binary.Get.Internal.readN1
                        @ GHC.Types.Int
                        @ Data.ByteString.Internal.ByteString
                        Lib.$fBinaryConstant7
                        Lib.$fBinaryConstant6
                        Lib.$fBinaryConstant5
                        Lib.$fBinaryConstant2
                          `cast`
                        (<[Data.ByteString.Internal.ByteString]>_R
                         ->_R Sym (Data.Binary.Get.Internal.N:Get[0]
                                       <Data.ByteString.Internal.ByteString>_R))
                        @ r
                        (Data.ByteString.Internal.PS ww ww1 ww2 ww3)
                        (\ (i' :: Data.ByteString.Internal.ByteString)
                           (a1 :: Data.ByteString.Internal.ByteString) ->
                         case a1 of wild { Data.ByteString.Internal.PS dt11 dt12 dt13 dt14 ->
                         case GHC.Prim.readWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# dt11 dt13)
                                0#
                                GHC.Prim.realWorld# of ds2 { (#,#) ipv ipv1 ->
                         case GHC.Prim.touch#
                                @ 'GHC.Types.LiftedRep
                                @ GHC.ForeignPtr.ForeignPtrContents
                                dt12
                                ipv of s' { DEFAULT ->
                         $wks
                           dt11
                           dt12
                           (GHC.Prim.+# dt13 1#)
                           (GHC.Prim.-# dt14 1#)
                           ipv1 } } })
                   GHC.Types.True
                   -> case GHC.Prim.readWord8OffAddr#
                             @ GHC.Prim.RealWorld
                             (GHC.Prim.plusAddr# ww ww2)
                             0#
                             GHC.Prim.realWorld# of ds2 { (#,#) ipv ipv1 ->
                      case GHC.Prim.touch#
                             @ 'GHC.Types.LiftedRep
                             @ GHC.ForeignPtr.ForeignPtrContents
                             ww1
                             ipv of s' { DEFAULT ->
                      $wks
                        ww
                        ww1
                        (GHC.Prim.+# ww2 1#)
                        (GHC.Prim.-# ww3 1#)
                        ipv1 } } }) -}
d2434dc127416df673fccc4dadac7334
  $w$cget3 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.DBComand r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success Lib.DBComand r) ->
                 let {
                   lvl136 :: Data.ByteString.Internal.ByteString
                             -> Lib.Expression -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,U> -}
                   = \ (i' :: Data.ByteString.Internal.ByteString)
                       (a1 :: Lib.Expression)[OneShot] ->
                     case i' of ww4 { Data.ByteString.Internal.PS ww5 ww6 ww7 ww8 ->
                     Data.Binary.Class.$w$s$cget2
                       @ r
                       ww5
                       ww6
                       ww7
                       ww8
                       (\ (i'1 :: Data.ByteString.Internal.ByteString)
                          (a2 :: GHC.Base.String)[OneShot] ->
                        w i'1 (Lib.LoadDBComand (Lib.LoadComand a1 a2))) }
                 } in
                 let {
                   lvl137 :: Data.ByteString.Internal.ByteString
                             -> Lib.PublishComand -> Data.Binary.Get.Internal.Decoder r
                     {- Arity: 2, Strictness: <L,U><L,U> -}
                   = \ (i' :: Data.ByteString.Internal.ByteString)
                       (a1 :: Lib.PublishComand)[OneShot] ->
                     w i' (Lib.PublishDBComand a1)
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww3 1#) of wild1 {
                   GHC.Types.False
                   -> Data.Binary.Get.Internal.readN1
                        @ GHC.Types.Int
                        @ Data.ByteString.Internal.ByteString
                        Lib.$fBinaryConstant7
                        Lib.$fBinaryConstant6
                        Lib.$fBinaryConstant5
                        Lib.$fBinaryConstant2
                          `cast`
                        (<[Data.ByteString.Internal.ByteString]>_R
                         ->_R Sym (Data.Binary.Get.Internal.N:Get[0]
                                       <Data.ByteString.Internal.ByteString>_R))
                        @ r
                        (Data.ByteString.Internal.PS ww ww1 ww2 ww3)
                        (\ (i' :: Data.ByteString.Internal.ByteString)
                           (a1 :: Data.ByteString.Internal.ByteString) ->
                         case a1 of wild { Data.ByteString.Internal.PS dt11 dt12 dt13 dt14 ->
                         case GHC.Prim.readWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# dt11 dt13)
                                0#
                                GHC.Prim.realWorld# of ds2 { (#,#) ipv ipv1 ->
                         case GHC.Prim.touch#
                                @ 'GHC.Types.LiftedRep
                                @ GHC.ForeignPtr.ForeignPtrContents
                                dt12
                                ipv of s' { DEFAULT ->
                         case ipv1 of wild2 {
                           DEFAULT
                           -> case Lib.$fBinaryDBComand2
                              ret_ty (Data.Binary.Get.Internal.Decoder r)
                              of {}
                           0##
                           -> Lib.$w$cget4
                                @ r
                                dt11
                                dt12
                                (GHC.Prim.+# dt13 1#)
                                (GHC.Prim.-# dt14 1#)
                                lvl137
                           1##
                           -> Lib.$w$cget1
                                @ r
                                dt11
                                dt12
                                (GHC.Prim.+# dt13 1#)
                                (GHC.Prim.-# dt14 1#)
                                lvl136 } } } })
                   GHC.Types.True
                   -> case GHC.Prim.readWord8OffAddr#
                             @ GHC.Prim.RealWorld
                             (GHC.Prim.plusAddr# ww ww2)
                             0#
                             GHC.Prim.realWorld# of ds2 { (#,#) ipv ipv1 ->
                      case GHC.Prim.touch#
                             @ 'GHC.Types.LiftedRep
                             @ GHC.ForeignPtr.ForeignPtrContents
                             ww1
                             ipv of s' { DEFAULT ->
                      case ipv1 of wild {
                        DEFAULT
                        -> case Lib.$fBinaryDBComand2
                           ret_ty (Data.Binary.Get.Internal.Decoder r)
                           of {}
                        0##
                        -> Lib.$w$cget4
                             @ r
                             ww
                             ww1
                             (GHC.Prim.+# ww2 1#)
                             (GHC.Prim.-# ww3 1#)
                             lvl137
                        1##
                        -> Lib.$w$cget1
                             @ r
                             ww
                             ww1
                             (GHC.Prim.+# ww2 1#)
                             (GHC.Prim.-# ww3 1#)
                             lvl136 } } } }) -}
d2434dc127416df673fccc4dadac7334
  $w$cget4 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.PublishComand r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <S,U><L,U><S,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success Lib.PublishComand r) ->
                 Lib.$w$cget1
                   @ r
                   ww
                   ww1
                   ww2
                   ww3
                   (\ (i' :: Data.ByteString.Internal.ByteString)
                      (a1 :: Lib.Expression)[OneShot] ->
                    case i' of ww4 { Data.ByteString.Internal.PS ww5 ww6 ww7 ww8 ->
                    Lib.$w$cget1
                      @ r
                      ww5
                      ww6
                      ww7
                      ww8
                      (\ (i'1 :: Data.ByteString.Internal.ByteString)
                         (a2 :: Lib.Expression)[OneShot] ->
                       case i'1 of ww9 { Data.ByteString.Internal.PS ww10 ww11 ww12 ww13 ->
                       Data.Binary.Class.$w$cget3
                         @ r
                         ww10
                         ww11
                         ww12
                         ww13
                         (\ (i'2 :: Data.ByteString.Internal.ByteString)
                            (a3 :: GHC.Types.Int)[OneShot] ->
                          w i'2 (Lib.PublishComand a1 a2 a3)) }) })) -}
d2434dc127416df673fccc4dadac7334
  $w$cget5 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.IfThenElse r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <S,U><L,U><S,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success Lib.IfThenElse r) ->
                 Lib.$w$cget1
                   @ r
                   ww
                   ww1
                   ww2
                   ww3
                   (\ (i' :: Data.ByteString.Internal.ByteString)
                      (a1 :: Lib.Expression)[OneShot] ->
                    case i' of ww4 { Data.ByteString.Internal.PS ww5 ww6 ww7 ww8 ->
                    Lib.$w$cget1
                      @ r
                      ww5
                      ww6
                      ww7
                      ww8
                      (\ (i'1 :: Data.ByteString.Internal.ByteString)
                         (a2 :: Lib.Expression)[OneShot] ->
                       case i'1 of ww9 { Data.ByteString.Internal.PS ww10 ww11 ww12 ww13 ->
                       Lib.$w$cget1
                         @ r
                         ww10
                         ww11
                         ww12
                         ww13
                         (\ (i'2 :: Data.ByteString.Internal.ByteString)
                            (a3 :: Lib.Expression)[OneShot] ->
                          w i'2 (Lib.IfThenElse a1 a2 a3)) }) })) -}
d2434dc127416df673fccc4dadac7334
  $w$cget6 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.Invocation r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <S,U><L,U><S,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success Lib.Invocation r) ->
                 Data.Binary.Class.$w$s$cget2
                   @ r
                   ww
                   ww1
                   ww2
                   ww3
                   (\ (i' :: Data.ByteString.Internal.ByteString)
                      (a1 :: GHC.Base.String)[OneShot] ->
                    case i' of ww4 { Data.ByteString.Internal.PS ww5 ww6 ww7 ww8 ->
                    Data.Binary.Class.$w$cget11
                      @ Lib.Expression
                      Lib.$fBinaryExpression
                      @ r
                      ww5
                      ww6
                      ww7
                      ww8
                      (\ (i'1 :: Data.ByteString.Internal.ByteString)
                         (a2 :: [Lib.Expression])[OneShot] ->
                       w i'1 (Lib.Invocation a1 a2)) })) -}
d2434dc127416df673fccc4dadac7334
  $w$cget7 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.LambdaDef r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <S,U><L,U><S,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success Lib.LambdaDef r) ->
                 Data.Binary.Class.$w$cget11
                   @ [GHC.Types.Char]
                   Data.Binary.Class.$fBinaryVersion_$s$fBinary[]
                   @ r
                   ww
                   ww1
                   ww2
                   ww3
                   (\ (i' :: Data.ByteString.Internal.ByteString)
                      (a1 :: [GHC.Base.String])[OneShot] ->
                    case i' of ww4 { Data.ByteString.Internal.PS ww5 ww6 ww7 ww8 ->
                    Lib.$w$cget8
                      @ r
                      ww5
                      ww6
                      ww7
                      ww8
                      (\ (i'1 :: Data.ByteString.Internal.ByteString)
                         (a2 :: Lib.Program)[OneShot] ->
                       w i'1 (Lib.LambdaDef a1 a2)) })) -}
d2434dc127416df673fccc4dadac7334
  $w$cget8 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.Program r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <S,U><L,U><S,U><S,U><L,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ r
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.ForeignPtr.ForeignPtrContents)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: Data.Binary.Get.Internal.Success Lib.Program r) ->
                 Data.Binary.Class.$w$cget11
                   @ Lib.Statement
                   Lib.$fBinaryStatement
                   @ r
                   ww
                   ww1
                   ww2
                   ww3
                   (\ (i' :: Data.ByteString.Internal.ByteString)
                      (a1 :: [Lib.Statement])[OneShot] ->
                    case i' of ww4 { Data.ByteString.Internal.PS ww5 ww6 ww7 ww8 ->
                    Lib.$w$cget1
                      @ r
                      ww5
                      ww6
                      ww7
                      ww8
                      (\ (i'1 :: Data.ByteString.Internal.ByteString)
                         (a2 :: Lib.Expression)[OneShot] ->
                       w i'1 (Lib.Program a1 (Lib.ReturnStatement a2))) })) -}
d2434dc127416df673fccc4dadac7334
  $w$cget9 ::
    GHC.Prim.Addr#
    -> GHC.ForeignPtr.ForeignPtrContents
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Binary.Get.Internal.Success Lib.Statement r
    -> Data.Binary.Get.Internal.Decoder r
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><L,C(C1(U))>,
     Inline: [0] -}
d2434dc127416df673fccc4dadac7334
  $w$cput ::
    GHC.Base.String
    -> Lib.Expression
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String) (ww1 :: Lib.Expression) ->
                 let {
                   k6 :: Data.Binary.Put.PutM ()
                   = case Lib.$w$cput1 ww1 of ww2 { (#,#) ww3 ww4 ->
                     (Data.Binary.Put.PairS @ () ww3 ww4)
                       `cast`
                     (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }
                 } in
                 (# case k6
                           `cast`
                         (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS b1 w' ->
                    b1 },
                    (\ @ r ->
                     let {
                       f20 :: Data.ByteString.Builder.Internal.BuildStep r
                              -> Data.ByteString.Builder.Internal.BuildStep r
                       = case Data.Binary.Class.$w$cputList ww of ww2 { (#,#) ww3 ww4 ->
                         ww4 `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     \ (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                     f20
                       (case k6
                               `cast`
                             (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS b1 w' ->
                        w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r x }))
                      `cast`
                    (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)) -}
d2434dc127416df673fccc4dadac7334
  $w$cput1 ::
    Lib.Expression
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
d2434dc127416df673fccc4dadac7334
  $w$cput10 ::
    Lib.Statement -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
d2434dc127416df673fccc4dadac7334
  $w$cput11 ::
    Lib.Expression
    -> [Lib.Statement]
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 2, Strictness: <L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: Lib.Expression) (ww1 :: [Lib.Statement]) ->
                 (# GHC.Tuple.(),
                    (\ @ r ->
                     let {
                       f20 :: Data.ByteString.Builder.Internal.BuildStep r
                              -> Data.ByteString.Builder.Internal.BuildStep r
                       = case Lib.$w$cput1 ww of ww2 { (#,#) ww3 ww4 ->
                         ww4 `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     let {
                       x :: GHC.Int.Int64
                       = case GHC.List.$wlenAcc @ Lib.Statement ww1 0# of ww2 { DEFAULT ->
                         GHC.Int.I64# ww2 }
                     } in
                     let {
                       g :: Data.ByteString.Builder.Internal.BuildStep r
                            -> Data.ByteString.Builder.Internal.BuildStep r
                       = case (Lib.$fBinaryLoop_go ww1)
                                `cast`
                              (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                         w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     \ (x1 :: Data.ByteString.Builder.Internal.BuildStep r) ->
                     f20
                       (let {
                          x2 :: Data.ByteString.Builder.Internal.BuildStep r = g x1
                        } in
                        let {
                          lvl136 :: Data.ByteString.Builder.Internal.BufferRange
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.ByteString.Builder.Internal.BuildSignal r #)
                            {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S,U> -}
                          = \ (ds :: Data.ByteString.Builder.Internal.BufferRange)
                              (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                            case ds of wild { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                            case x of wild1 { GHC.Int.I64# x# ->
                            let {
                              w1 :: GHC.Prim.Word# = GHC.Prim.int2Word# x#
                            } in
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   dt11
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 56#))
                                   eta of s2 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 1#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 48#))
                                   s2 of s1 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 2#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 40#))
                                   s1 of s3 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 3#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 32#))
                                   s3 of s4 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 4#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 24#))
                                   s4 of s5 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 5#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 16#))
                                   s5 of s6 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 6#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 8#))
                                   s6 of s7 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 7#)
                                   0#
                                   (GHC.Prim.narrow8Word# w1)
                                   s7 of s8 { DEFAULT ->
                            (x2
                               (Data.ByteString.Builder.Internal.BufferRange
                                  (GHC.Prim.plusAddr# dt11 8#)
                                  dt12))
                              `cast`
                            (GHC.Types.N:IO[0]
                                 <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                              s8 } } } } } } } } } }
                        } in
                        (\ (eta :: Data.ByteString.Builder.Internal.BufferRange)
                           (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                         case eta of wild { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<# (GHC.Prim.minusAddr# dt12 dt11) 8#) of wild2 {
                           GHC.Types.False
                           -> case x of wild1 { GHC.Int.I64# x# ->
                              let {
                                w1 :: GHC.Prim.Word# = GHC.Prim.int2Word# x#
                              } in
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt11
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 56#))
                                     eta1 of s2 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 1#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 48#))
                                     s2 of s1 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 2#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 40#))
                                     s1 of s3 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 3#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 32#))
                                     s3 of s4 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 4#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 24#))
                                     s4 of s5 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 5#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 16#))
                                     s5 of s6 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 6#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 8#))
                                     s6 of s7 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 7#)
                                     0#
                                     (GHC.Prim.narrow8Word# w1)
                                     s7 of s8 { DEFAULT ->
                              (x2
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt11 8#)
                                    dt12))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s8 } } } } } } } } }
                           GHC.Types.True
                           -> (# eta1,
                                 Data.ByteString.Builder.Internal.BufferFull
                                   @ r
                                   8#
                                   dt11
                                   lvl136
                                     `cast`
                                   (<Data.ByteString.Builder.Internal.BufferRange>_R
                                    ->_R Sym (GHC.Types.N:IO[0]
                                                  <Data.ByteString.Builder.Internal.BuildSignal
                                                     r>_R)) #) } })
                          `cast`
                        (<Data.ByteString.Builder.Internal.BufferRange>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <Data.ByteString.Builder.Internal.BuildSignal r>_R))))
                      `cast`
                    (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)) -}
d2434dc127416df673fccc4dadac7334
  $w$cput12 ::
    Lib.Operator -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
134f098db942ee94766d361f69ca06a8
  $w$cput2 ::
    Lib.Constant -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: Lib.Constant) ->
                 case w of wild {
                   Lib.IntConstant i
                   -> let {
                        k6 :: Data.Binary.Put.PairS ()
                        = case Data.Binary.Class.$w$cput9 i of ww { (#,#) ww1 ww2 ->
                          Data.Binary.Put.PairS @ () ww1 ww2 }
                      } in
                      (# case k6 of wild1 { Data.Binary.Put.PairS b1 w' -> b1 },
                         (\ @ r (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                          let {
                            x1 :: Data.ByteString.Builder.Internal.BuildStep r
                            = case k6 of wild1 { Data.Binary.Put.PairS b1 w' ->
                              w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r x }
                          } in
                          let {
                            lvl136 :: Data.ByteString.Builder.Internal.BufferRange
                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                            Data.ByteString.Builder.Internal.BuildSignal r #)
                              {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S,U> -}
                            = \ (ds :: Data.ByteString.Builder.Internal.BufferRange)
                                (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                              case ds of wild1 { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt11
                                     0#
                                     0##
                                     eta of s2 { DEFAULT ->
                              (x1
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt11 1#)
                                    dt12))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s2 } }
                          } in
                          (\ (eta :: Data.ByteString.Builder.Internal.BufferRange)
                             (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                           case eta of wild1 { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# (GHC.Prim.minusAddr# dt12 dt11) 1#) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.writeWord8OffAddr#
                                       @ GHC.Prim.RealWorld
                                       dt11
                                       0#
                                       0##
                                       eta1 of s2 { DEFAULT ->
                                (x1
                                   (Data.ByteString.Builder.Internal.BufferRange
                                      (GHC.Prim.plusAddr# dt11 1#)
                                      dt12))
                                  `cast`
                                (GHC.Types.N:IO[0]
                                     <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                  s2 }
                             GHC.Types.True
                             -> (# eta1,
                                   Data.ByteString.Builder.Internal.BufferFull
                                     @ r
                                     1#
                                     dt11
                                     lvl136
                                       `cast`
                                     (<Data.ByteString.Builder.Internal.BufferRange>_R
                                      ->_R Sym (GHC.Types.N:IO[0]
                                                    <Data.ByteString.Builder.Internal.BuildSignal
                                                       r>_R)) #) } })
                            `cast`
                          (<Data.ByteString.Builder.Internal.BufferRange>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <Data.ByteString.Builder.Internal.BuildSignal r>_R)))
                           `cast`
                         (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)
                   Lib.StringConstant s
                   -> let {
                        k6 :: Data.Binary.Put.PairS ()
                        = case Data.Binary.Class.$w$cputList s of ww { (#,#) ww1 ww2 ->
                          Data.Binary.Put.PairS @ () ww1 ww2 }
                      } in
                      (# case k6 of wild1 { Data.Binary.Put.PairS b1 w' -> b1 },
                         (\ @ r (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                          let {
                            x1 :: Data.ByteString.Builder.Internal.BuildStep r
                            = case k6 of wild1 { Data.Binary.Put.PairS b1 w' ->
                              w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r x }
                          } in
                          let {
                            lvl136 :: Data.ByteString.Builder.Internal.BufferRange
                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                            Data.ByteString.Builder.Internal.BuildSignal r #)
                              {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S,U> -}
                            = \ (ds :: Data.ByteString.Builder.Internal.BufferRange)
                                (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                              case ds of wild1 { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt11
                                     0#
                                     1##
                                     eta of s2 { DEFAULT ->
                              (x1
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt11 1#)
                                    dt12))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s2 } }
                          } in
                          (\ (eta :: Data.ByteString.Builder.Internal.BufferRange)
                             (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                           case eta of wild1 { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# (GHC.Prim.minusAddr# dt12 dt11) 1#) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.writeWord8OffAddr#
                                       @ GHC.Prim.RealWorld
                                       dt11
                                       0#
                                       1##
                                       eta1 of s2 { DEFAULT ->
                                (x1
                                   (Data.ByteString.Builder.Internal.BufferRange
                                      (GHC.Prim.plusAddr# dt11 1#)
                                      dt12))
                                  `cast`
                                (GHC.Types.N:IO[0]
                                     <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                  s2 }
                             GHC.Types.True
                             -> (# eta1,
                                   Data.ByteString.Builder.Internal.BufferFull
                                     @ r
                                     1#
                                     dt11
                                     lvl136
                                       `cast`
                                     (<Data.ByteString.Builder.Internal.BufferRange>_R
                                      ->_R Sym (GHC.Types.N:IO[0]
                                                    <Data.ByteString.Builder.Internal.BuildSignal
                                                       r>_R)) #) } })
                            `cast`
                          (<Data.ByteString.Builder.Internal.BufferRange>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <Data.ByteString.Builder.Internal.BuildSignal r>_R)))
                           `cast`
                         (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)
                   Lib.BoolConstant b
                   -> let {
                        k6 :: Data.Binary.Put.PairS ()
                        = case Data.Binary.Class.$w$cput b of ww { (#,#) ww1 ww2 ->
                          Data.Binary.Put.PairS @ () ww1 ww2 }
                      } in
                      (# case k6 of wild1 { Data.Binary.Put.PairS b1 w' -> b1 },
                         (\ @ r (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                          let {
                            x1 :: Data.ByteString.Builder.Internal.BuildStep r
                            = case k6 of wild1 { Data.Binary.Put.PairS b1 w' ->
                              w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r x }
                          } in
                          let {
                            lvl136 :: Data.ByteString.Builder.Internal.BufferRange
                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                            Data.ByteString.Builder.Internal.BuildSignal r #)
                              {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S,U> -}
                            = \ (ds :: Data.ByteString.Builder.Internal.BufferRange)
                                (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                              case ds of wild1 { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt11
                                     0#
                                     2##
                                     eta of s2 { DEFAULT ->
                              (x1
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt11 1#)
                                    dt12))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s2 } }
                          } in
                          (\ (eta :: Data.ByteString.Builder.Internal.BufferRange)
                             (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                           case eta of wild1 { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# (GHC.Prim.minusAddr# dt12 dt11) 1#) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.writeWord8OffAddr#
                                       @ GHC.Prim.RealWorld
                                       dt11
                                       0#
                                       2##
                                       eta1 of s2 { DEFAULT ->
                                (x1
                                   (Data.ByteString.Builder.Internal.BufferRange
                                      (GHC.Prim.plusAddr# dt11 1#)
                                      dt12))
                                  `cast`
                                (GHC.Types.N:IO[0]
                                     <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                  s2 }
                             GHC.Types.True
                             -> (# eta1,
                                   Data.ByteString.Builder.Internal.BufferFull
                                     @ r
                                     1#
                                     dt11
                                     lvl136
                                       `cast`
                                     (<Data.ByteString.Builder.Internal.BufferRange>_R
                                      ->_R Sym (GHC.Types.N:IO[0]
                                                    <Data.ByteString.Builder.Internal.BuildSignal
                                                       r>_R)) #) } })
                            `cast`
                          (<Data.ByteString.Builder.Internal.BufferRange>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <Data.ByteString.Builder.Internal.BuildSignal r>_R)))
                           `cast`
                         (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #) }) -}
d2434dc127416df673fccc4dadac7334
  $w$cput3 ::
    Lib.DBComand -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: Lib.DBComand) ->
                 case w of wild {
                   Lib.PublishDBComand pc
                   -> let {
                        k6 :: Data.Binary.Put.PutM ()
                        = case pc of ww { Lib.PublishComand ww1 ww2 ww3 ->
                          case Lib.$w$cput5 ww1 ww2 ww3 of ww4 { (#,#) ww5 ww6 ->
                          (Data.Binary.Put.PairS @ () ww5 ww6)
                            `cast`
                          (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }
                      } in
                      (# case k6
                                `cast`
                              (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                         b1 },
                         (\ @ r (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                          let {
                            x1 :: Data.ByteString.Builder.Internal.BuildStep r
                            = case k6
                                     `cast`
                                   (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                              w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r x }
                          } in
                          let {
                            lvl136 :: Data.ByteString.Builder.Internal.BufferRange
                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                            Data.ByteString.Builder.Internal.BuildSignal r #)
                              {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S,U> -}
                            = \ (ds :: Data.ByteString.Builder.Internal.BufferRange)
                                (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                              case ds of wild1 { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt11
                                     0#
                                     0##
                                     eta of s2 { DEFAULT ->
                              (x1
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt11 1#)
                                    dt12))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s2 } }
                          } in
                          (\ (eta :: Data.ByteString.Builder.Internal.BufferRange)
                             (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                           case eta of wild1 { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# (GHC.Prim.minusAddr# dt12 dt11) 1#) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.writeWord8OffAddr#
                                       @ GHC.Prim.RealWorld
                                       dt11
                                       0#
                                       0##
                                       eta1 of s2 { DEFAULT ->
                                (x1
                                   (Data.ByteString.Builder.Internal.BufferRange
                                      (GHC.Prim.plusAddr# dt11 1#)
                                      dt12))
                                  `cast`
                                (GHC.Types.N:IO[0]
                                     <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                  s2 }
                             GHC.Types.True
                             -> (# eta1,
                                   Data.ByteString.Builder.Internal.BufferFull
                                     @ r
                                     1#
                                     dt11
                                     lvl136
                                       `cast`
                                     (<Data.ByteString.Builder.Internal.BufferRange>_R
                                      ->_R Sym (GHC.Types.N:IO[0]
                                                    <Data.ByteString.Builder.Internal.BuildSignal
                                                       r>_R)) #) } })
                            `cast`
                          (<Data.ByteString.Builder.Internal.BufferRange>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <Data.ByteString.Builder.Internal.BuildSignal r>_R)))
                           `cast`
                         (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)
                   Lib.LoadDBComand lc
                   -> let {
                        k6 :: Data.Binary.Put.PutM ()
                        = case lc of ww { Lib.LoadComand ww1 ww2 ->
                          case Lib.$w$cput4 ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                          (Data.Binary.Put.PairS @ () ww4 ww5)
                            `cast`
                          (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }
                      } in
                      (# case k6
                                `cast`
                              (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                         b1 },
                         (\ @ r (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                          let {
                            x1 :: Data.ByteString.Builder.Internal.BuildStep r
                            = case k6
                                     `cast`
                                   (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                              w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r x }
                          } in
                          let {
                            lvl136 :: Data.ByteString.Builder.Internal.BufferRange
                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                            Data.ByteString.Builder.Internal.BuildSignal r #)
                              {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S,U> -}
                            = \ (ds :: Data.ByteString.Builder.Internal.BufferRange)
                                (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                              case ds of wild1 { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt11
                                     0#
                                     1##
                                     eta of s2 { DEFAULT ->
                              (x1
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt11 1#)
                                    dt12))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s2 } }
                          } in
                          (\ (eta :: Data.ByteString.Builder.Internal.BufferRange)
                             (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                           case eta of wild1 { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# (GHC.Prim.minusAddr# dt12 dt11) 1#) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.writeWord8OffAddr#
                                       @ GHC.Prim.RealWorld
                                       dt11
                                       0#
                                       1##
                                       eta1 of s2 { DEFAULT ->
                                (x1
                                   (Data.ByteString.Builder.Internal.BufferRange
                                      (GHC.Prim.plusAddr# dt11 1#)
                                      dt12))
                                  `cast`
                                (GHC.Types.N:IO[0]
                                     <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                  s2 }
                             GHC.Types.True
                             -> (# eta1,
                                   Data.ByteString.Builder.Internal.BufferFull
                                     @ r
                                     1#
                                     dt11
                                     lvl136
                                       `cast`
                                     (<Data.ByteString.Builder.Internal.BufferRange>_R
                                      ->_R Sym (GHC.Types.N:IO[0]
                                                    <Data.ByteString.Builder.Internal.BuildSignal
                                                       r>_R)) #) } })
                            `cast`
                          (<Data.ByteString.Builder.Internal.BufferRange>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <Data.ByteString.Builder.Internal.BuildSignal r>_R)))
                           `cast`
                         (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #) }) -}
d2434dc127416df673fccc4dadac7334
  $w$cput4 ::
    Lib.Expression
    -> GHC.Base.String
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 2, Strictness: <L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: Lib.Expression) (ww1 :: GHC.Base.String) ->
                 let {
                   k6 :: Data.Binary.Put.PairS ()
                   = case Data.Binary.Class.$w$cputList ww1 of ww2 { (#,#) ww3 ww4 ->
                     Data.Binary.Put.PairS @ () ww3 ww4 }
                 } in
                 (# case k6 of wild { Data.Binary.Put.PairS b1 w' -> b1 },
                    (\ @ r ->
                     let {
                       f20 :: Data.ByteString.Builder.Internal.BuildStep r
                              -> Data.ByteString.Builder.Internal.BuildStep r
                       = case Lib.$w$cput1 ww of ww2 { (#,#) ww3 ww4 ->
                         ww4 `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     \ (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                     f20
                       (case k6 of wild { Data.Binary.Put.PairS b1 w' ->
                        w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r x }))
                      `cast`
                    (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)) -}
d2434dc127416df673fccc4dadac7334
  $w$cput5 ::
    Lib.Expression
    -> Lib.Expression
    -> GHC.Types.Int
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 3, Strictness: <L,1*U><L,1*U><L,U(U)>, Inline: [0],
     Unfolding: (\ (ww :: Lib.Expression)
                   (ww1 :: Lib.Expression)
                   (ww2 :: GHC.Types.Int) ->
                 let {
                   k6 :: Data.Binary.Put.PairS ()
                   = case Data.Binary.Class.$w$cput9 ww2 of ww3 { (#,#) ww4 ww5 ->
                     Data.Binary.Put.PairS @ () ww4 ww5 }
                 } in
                 (# case k6 of wild { Data.Binary.Put.PairS b1 w' -> b1 },
                    (\ @ r ->
                     let {
                       f20 :: Data.ByteString.Builder.Internal.BuildStep r
                              -> Data.ByteString.Builder.Internal.BuildStep r
                       = case Lib.$w$cput1 ww of ww3 { (#,#) ww4 ww5 ->
                         ww5 `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     let {
                       f21 :: Data.ByteString.Builder.Internal.BuildStep r
                              -> Data.ByteString.Builder.Internal.BuildStep r
                       = case Lib.$w$cput1 ww1 of ww3 { (#,#) ww4 ww5 ->
                         ww5 `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     \ (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                     f20
                       (f21
                          (case k6 of wild { Data.Binary.Put.PairS b1 w' ->
                           w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0])
                             @ r
                             x })))
                      `cast`
                    (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)) -}
d2434dc127416df673fccc4dadac7334
  $w$cput6 ::
    Lib.Expression
    -> Lib.Expression
    -> Lib.Expression
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 3, Strictness: <L,1*U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Lib.Expression)
                   (ww1 :: Lib.Expression)
                   (ww2 :: Lib.Expression) ->
                 let {
                   k6 :: Data.Binary.Put.PutM ()
                   = case Lib.$w$cput1 ww2 of ww3 { (#,#) ww4 ww5 ->
                     (Data.Binary.Put.PairS @ () ww4 ww5)
                       `cast`
                     (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }
                 } in
                 (# case k6
                           `cast`
                         (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS b1 w' ->
                    b1 },
                    (\ @ r ->
                     let {
                       f20 :: Data.ByteString.Builder.Internal.BuildStep r
                              -> Data.ByteString.Builder.Internal.BuildStep r
                       = case Lib.$w$cput1 ww of ww3 { (#,#) ww4 ww5 ->
                         ww5 `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     let {
                       f21 :: Data.ByteString.Builder.Internal.BuildStep r
                              -> Data.ByteString.Builder.Internal.BuildStep r
                       = case Lib.$w$cput1 ww1 of ww3 { (#,#) ww4 ww5 ->
                         ww5 `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     \ (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                     f20
                       (f21
                          (case k6
                                  `cast`
                                (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS b1 w' ->
                           w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0])
                             @ r
                             x })))
                      `cast`
                    (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)) -}
d2434dc127416df673fccc4dadac7334
  $w$cput7 ::
    GHC.Base.String
    -> [Lib.Expression]
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String) (ww1 :: [Lib.Expression]) ->
                 (# GHC.Tuple.(),
                    (\ @ r ->
                     let {
                       f20 :: Data.ByteString.Builder.Internal.BuildStep r
                              -> Data.ByteString.Builder.Internal.BuildStep r
                       = case Data.Binary.Class.$w$cputList ww of ww2 { (#,#) ww3 ww4 ->
                         ww4 `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     let {
                       x :: GHC.Int.Int64
                       = case GHC.List.$wlenAcc
                                @ Lib.Expression
                                ww1
                                0# of ww2 { DEFAULT ->
                         GHC.Int.I64# ww2 }
                     } in
                     let {
                       g :: Data.ByteString.Builder.Internal.BuildStep r
                            -> Data.ByteString.Builder.Internal.BuildStep r
                       = case (Lib.$fBinaryInvocation_go ww1)
                                `cast`
                              (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                         w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     \ (x1 :: Data.ByteString.Builder.Internal.BuildStep r) ->
                     f20
                       (let {
                          x2 :: Data.ByteString.Builder.Internal.BuildStep r = g x1
                        } in
                        let {
                          lvl136 :: Data.ByteString.Builder.Internal.BufferRange
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.ByteString.Builder.Internal.BuildSignal r #)
                            {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S,U> -}
                          = \ (ds :: Data.ByteString.Builder.Internal.BufferRange)
                              (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                            case ds of wild { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                            case x of wild1 { GHC.Int.I64# x# ->
                            let {
                              w1 :: GHC.Prim.Word# = GHC.Prim.int2Word# x#
                            } in
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   dt11
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 56#))
                                   eta of s2 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 1#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 48#))
                                   s2 of s1 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 2#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 40#))
                                   s1 of s3 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 3#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 32#))
                                   s3 of s4 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 4#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 24#))
                                   s4 of s5 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 5#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 16#))
                                   s5 of s6 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 6#)
                                   0#
                                   (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 8#))
                                   s6 of s7 { DEFAULT ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   (GHC.Prim.plusAddr# dt11 7#)
                                   0#
                                   (GHC.Prim.narrow8Word# w1)
                                   s7 of s8 { DEFAULT ->
                            (x2
                               (Data.ByteString.Builder.Internal.BufferRange
                                  (GHC.Prim.plusAddr# dt11 8#)
                                  dt12))
                              `cast`
                            (GHC.Types.N:IO[0]
                                 <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                              s8 } } } } } } } } } }
                        } in
                        (\ (eta :: Data.ByteString.Builder.Internal.BufferRange)
                           (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                         case eta of wild { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<# (GHC.Prim.minusAddr# dt12 dt11) 8#) of wild2 {
                           GHC.Types.False
                           -> case x of wild1 { GHC.Int.I64# x# ->
                              let {
                                w1 :: GHC.Prim.Word# = GHC.Prim.int2Word# x#
                              } in
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt11
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 56#))
                                     eta1 of s2 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 1#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 48#))
                                     s2 of s1 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 2#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 40#))
                                     s1 of s3 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 3#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 32#))
                                     s3 of s4 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 4#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 24#))
                                     s4 of s5 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 5#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 16#))
                                     s5 of s6 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 6#)
                                     0#
                                     (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 8#))
                                     s6 of s7 { DEFAULT ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     (GHC.Prim.plusAddr# dt11 7#)
                                     0#
                                     (GHC.Prim.narrow8Word# w1)
                                     s7 of s8 { DEFAULT ->
                              (x2
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt11 8#)
                                    dt12))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s8 } } } } } } } } }
                           GHC.Types.True
                           -> (# eta1,
                                 Data.ByteString.Builder.Internal.BufferFull
                                   @ r
                                   8#
                                   dt11
                                   lvl136
                                     `cast`
                                   (<Data.ByteString.Builder.Internal.BufferRange>_R
                                    ->_R Sym (GHC.Types.N:IO[0]
                                                  <Data.ByteString.Builder.Internal.BuildSignal
                                                     r>_R)) #) } })
                          `cast`
                        (<Data.ByteString.Builder.Internal.BufferRange>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <Data.ByteString.Builder.Internal.BuildSignal r>_R))))
                      `cast`
                    (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)) -}
d2434dc127416df673fccc4dadac7334
  $w$cput8 ::
    [GHC.Base.String]
    -> Lib.Program
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 2, Strictness: <L,U><L,1*U(U,1*U(1*U))>, Inline: [0],
     Unfolding: (\ (ww :: [GHC.Base.String]) (ww1 :: Lib.Program) ->
                 let {
                   k6 :: Data.Binary.Put.PutM ()
                   = case ww1 of ww2 { Lib.Program ww3 ww4 ->
                     case Lib.$w$cput9 ww3 ww4 of ww5 { (#,#) ww6 ww7 ->
                     (Data.Binary.Put.PairS @ () ww6 ww7)
                       `cast`
                     (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }
                 } in
                 (# case k6
                           `cast`
                         (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS b1 w' ->
                    b1 },
                    (\ @ r ->
                     let {
                       f20 :: Data.ByteString.Builder.Internal.BuildStep r
                              -> Data.ByteString.Builder.Internal.BuildStep r
                       = case (Data.Binary.Class.$fBinaryVersion_$s$cputList ww)
                                `cast`
                              (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w ->
                         w `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     \ (x :: Data.ByteString.Builder.Internal.BuildStep r) ->
                     f20
                       (case k6
                               `cast`
                             (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS b1 w' ->
                        w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r x }))
                      `cast`
                    (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)) -}
d2434dc127416df673fccc4dadac7334
  $w$cput9 ::
    [Lib.Statement]
    -> Lib.ReturnStatement
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 2, Strictness: <L,U><L,1*U(1*U)>, Inline: [0],
     Unfolding: (\ (ww :: [Lib.Statement])
                   (ww1 :: Lib.ReturnStatement) ->
                 let {
                   k6 :: Data.Binary.Put.PutM ()
                   = case ww1 of wild { Lib.ReturnStatement e ->
                     case Lib.$w$cput1 e of ww2 { (#,#) ww3 ww4 ->
                     (Data.Binary.Put.PairS @ () ww3 ww4)
                       `cast`
                     (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) } }
                 } in
                 (# case k6
                           `cast`
                         (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS b1 w' ->
                    b1 },
                    (\ @ r ->
                     let {
                       x :: GHC.Int.Int64
                       = case GHC.List.$wlenAcc @ Lib.Statement ww 0# of ww2 { DEFAULT ->
                         GHC.Int.I64# ww2 }
                     } in
                     let {
                       g :: Data.ByteString.Builder.Internal.BuildStep r
                            -> Data.ByteString.Builder.Internal.BuildStep r
                       = case (Lib.$fBinaryLambdaDef_go ww)
                                `cast`
                              (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS ds w' ->
                         w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r }
                     } in
                     \ (x1 :: Data.ByteString.Builder.Internal.BuildStep r) ->
                     let {
                       x2 :: Data.ByteString.Builder.Internal.BuildStep r
                       = g (case k6
                                   `cast`
                                 (Data.Binary.Put.N:PutM[0] <()>_N) of wild { Data.Binary.Put.PairS b1 w' ->
                            w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r x1 })
                     } in
                     let {
                       lvl136 :: Data.ByteString.Builder.Internal.BufferRange
                                 -> GHC.Prim.State# GHC.Prim.RealWorld
                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                       Data.ByteString.Builder.Internal.BuildSignal r #)
                         {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S,U> -}
                       = \ (ds :: Data.ByteString.Builder.Internal.BufferRange)
                           (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                         case ds of wild { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                         case x of wild1 { GHC.Int.I64# x# ->
                         let {
                           w1 :: GHC.Prim.Word# = GHC.Prim.int2Word# x#
                         } in
                         case GHC.Prim.writeWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                dt11
                                0#
                                (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 56#))
                                eta of s2 { DEFAULT ->
                         case GHC.Prim.writeWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# dt11 1#)
                                0#
                                (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 48#))
                                s2 of s1 { DEFAULT ->
                         case GHC.Prim.writeWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# dt11 2#)
                                0#
                                (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 40#))
                                s1 of s3 { DEFAULT ->
                         case GHC.Prim.writeWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# dt11 3#)
                                0#
                                (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 32#))
                                s3 of s4 { DEFAULT ->
                         case GHC.Prim.writeWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# dt11 4#)
                                0#
                                (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 24#))
                                s4 of s5 { DEFAULT ->
                         case GHC.Prim.writeWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# dt11 5#)
                                0#
                                (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 16#))
                                s5 of s6 { DEFAULT ->
                         case GHC.Prim.writeWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# dt11 6#)
                                0#
                                (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 8#))
                                s6 of s7 { DEFAULT ->
                         case GHC.Prim.writeWord8OffAddr#
                                @ GHC.Prim.RealWorld
                                (GHC.Prim.plusAddr# dt11 7#)
                                0#
                                (GHC.Prim.narrow8Word# w1)
                                s7 of s8 { DEFAULT ->
                         (x2
                            (Data.ByteString.Builder.Internal.BufferRange
                               (GHC.Prim.plusAddr# dt11 8#)
                               dt12))
                           `cast`
                         (GHC.Types.N:IO[0]
                              <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                           s8 } } } } } } } } } }
                     } in
                     (\ (eta :: Data.ByteString.Builder.Internal.BufferRange)
                        (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                      case eta of wild { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<# (GHC.Prim.minusAddr# dt12 dt11) 8#) of wild2 {
                        GHC.Types.False
                        -> case x of wild1 { GHC.Int.I64# x# ->
                           let {
                             w1 :: GHC.Prim.Word# = GHC.Prim.int2Word# x#
                           } in
                           case GHC.Prim.writeWord8OffAddr#
                                  @ GHC.Prim.RealWorld
                                  dt11
                                  0#
                                  (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 56#))
                                  eta1 of s2 { DEFAULT ->
                           case GHC.Prim.writeWord8OffAddr#
                                  @ GHC.Prim.RealWorld
                                  (GHC.Prim.plusAddr# dt11 1#)
                                  0#
                                  (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 48#))
                                  s2 of s1 { DEFAULT ->
                           case GHC.Prim.writeWord8OffAddr#
                                  @ GHC.Prim.RealWorld
                                  (GHC.Prim.plusAddr# dt11 2#)
                                  0#
                                  (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 40#))
                                  s1 of s3 { DEFAULT ->
                           case GHC.Prim.writeWord8OffAddr#
                                  @ GHC.Prim.RealWorld
                                  (GHC.Prim.plusAddr# dt11 3#)
                                  0#
                                  (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 32#))
                                  s3 of s4 { DEFAULT ->
                           case GHC.Prim.writeWord8OffAddr#
                                  @ GHC.Prim.RealWorld
                                  (GHC.Prim.plusAddr# dt11 4#)
                                  0#
                                  (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 24#))
                                  s4 of s5 { DEFAULT ->
                           case GHC.Prim.writeWord8OffAddr#
                                  @ GHC.Prim.RealWorld
                                  (GHC.Prim.plusAddr# dt11 5#)
                                  0#
                                  (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 16#))
                                  s5 of s6 { DEFAULT ->
                           case GHC.Prim.writeWord8OffAddr#
                                  @ GHC.Prim.RealWorld
                                  (GHC.Prim.plusAddr# dt11 6#)
                                  0#
                                  (GHC.Prim.narrow8Word# (GHC.Prim.uncheckedShiftRL# w1 8#))
                                  s6 of s7 { DEFAULT ->
                           case GHC.Prim.writeWord8OffAddr#
                                  @ GHC.Prim.RealWorld
                                  (GHC.Prim.plusAddr# dt11 7#)
                                  0#
                                  (GHC.Prim.narrow8Word# w1)
                                  s7 of s8 { DEFAULT ->
                           (x2
                              (Data.ByteString.Builder.Internal.BufferRange
                                 (GHC.Prim.plusAddr# dt11 8#)
                                 dt12))
                             `cast`
                           (GHC.Types.N:IO[0]
                                <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                             s8 } } } } } } } } }
                        GHC.Types.True
                        -> (# eta1,
                              Data.ByteString.Builder.Internal.BufferFull
                                @ r
                                8#
                                dt11
                                lvl136
                                  `cast`
                                (<Data.ByteString.Builder.Internal.BufferRange>_R
                                 ->_R Sym (GHC.Types.N:IO[0]
                                               <Data.ByteString.Builder.Internal.BuildSignal
                                                  r>_R)) #) } })
                       `cast`
                     (<Data.ByteString.Builder.Internal.BufferRange>_R
                      ->_R Sym (GHC.Types.N:IO[0]
                                    <Data.ByteString.Builder.Internal.BuildSignal r>_R)))
                      `cast`
                    (Sym (Data.ByteString.Builder.Internal.N:Builder[0])) #)) -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Base.String -> Lib.Expression -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: Lib.Expression) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Lib.$w$cshowsPrec1 11# ww2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Lib.$fShowAssignment2
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.$fShow(,)3
                           (GHC.Show.showLitString
                              ww1
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.$fShow(,)3
                                 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))))
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Lib.$fShowAssignment2
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.$fShow(,)3
                              (GHC.Show.showLitString
                                 ww1
                                 (GHC.Types.:
                                    @ GHC.Types.Char
                                    GHC.Show.$fShow(,)3
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (g (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.$fShow(,)2
                                             x))))))) }) -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec1 :: GHC.Prim.Int# -> Lib.Expression -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0] -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec10 :: GHC.Prim.Int# -> Lib.Statement -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0] -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec11 ::
    GHC.Prim.Int# -> Lib.Expression -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: Lib.Expression) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Lib.$w$cshowsPrec1 11# ww1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++ @ GHC.Types.Char Lib.$fShowLambdaDef4 (g x)
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Lib.$fShowLambdaDef4
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }) -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec12 ::
    GHC.Prim.Int#
    -> Lib.Expression -> [Lib.Statement] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Lib.Expression)
                   (ww2 :: [Lib.Statement]) ->
                 let {
                   f20 :: GHC.Base.String -> GHC.Base.String
                   = Lib.$w$cshowsPrec1 11# ww1
                 } in
                 let {
                   p11 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.CString.unpackAppendCString#
                       Lib.$fShowLoop2
                       (f20
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (case ww2 of wild {
                                [] -> GHC.CString.unpackAppendCString# GHC.Show.showList__4 x
                                : x1 xs
                                -> GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.showList__3
                                     (Lib.$w$cshowsPrec10
                                        0#
                                        x1
                                        (let {
                                           lvl136 :: [GHC.Types.Char]
                                           = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__2 x
                                         } in
                                         letrec {
                                           showl :: [Lib.Statement] -> GHC.Base.String
                                             {- Arity: 1, Strictness: <S,1*U> -}
                                           = \ (ds2 :: [Lib.Statement]) ->
                                             case ds2 of wild1 {
                                               [] -> lvl136
                                               : y ys
                                               -> GHC.Types.:
                                                    @ GHC.Types.Char
                                                    GHC.Show.showList__1
                                                    (Lib.$w$cshowsPrec10 0# y (showl ys)) }
                                         } in
                                         showl xs)) })))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p11
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p11 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }) -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec13 :: GHC.Prim.Int# -> Lib.Operator -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: Lib.Operator) ->
                 case w of wild {
                   Lib.UnaryOperator b1 b2 b3
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String = Lib.$w$cshowsPrec1 11# b3
                      } in
                      let {
                        p11 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: GHC.Base.String) ->
                          GHC.CString.unpackAppendCString#
                            Lib.$fShowOperator9
                            (let {
                               eta :: GHC.Base.String
                               = GHC.Show.showLitString
                                   b2
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                             } in
                             case b1 of wild1 {
                               Lib.IntType
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    Lib.$fShowOperator7
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 eta))
                               Lib.StringType
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    Lib.$fShowOperator5
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 eta))
                               Lib.BoolType
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    Lib.$fShowOperator3
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 eta)) })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False -> p11
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (p11 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }
                   Lib.BinaryOperator b1 b2 b3 b4
                   -> let {
                        f20 :: GHC.Base.String -> GHC.Base.String
                        = Lib.$w$cshowsPrec1 11# b3
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String = Lib.$w$cshowsPrec1 11# b4
                      } in
                      let {
                        p11 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: GHC.Base.String) ->
                          GHC.CString.unpackAppendCString#
                            Lib.$fShowOperator2
                            (let {
                               eta :: GHC.Base.String
                               = GHC.Show.showLitString
                                   b2
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.showSpace1
                                         (f20
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               GHC.Show.showSpace1
                                               (g x)))))
                             } in
                             case b1 of wild1 {
                               Lib.IntType
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    Lib.$fShowOperator7
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 eta))
                               Lib.StringType
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    Lib.$fShowOperator5
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 eta))
                               Lib.BoolType
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    Lib.$fShowOperator3
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 eta)) })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False -> p11
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (p11 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) } }) -}
e9c0f629e94b1f09f2a96f8603ed9c1b
  $w$cshowsPrec14 ::
    Lib.OperatorType -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Lib.OperatorType) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Lib.IntType -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowOperator7 w1
                   Lib.StringType
                   -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowOperator5 w1
                   Lib.BoolType
                   -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowOperator3 w1 }) -}
134f098db942ee94766d361f69ca06a8
  $w$cshowsPrec2 ::
    GHC.Prim.Int# -> Lib.Constant -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Lib.Constant)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Lib.IntConstant b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> GHC.CString.unpackAppendCString#
                             Lib.$fShowConstant4
                             (case b1 of ww2 { GHC.Types.I# ww3 ->
                              case GHC.Show.$wshowSignedInt 11# ww3 w1 of ww4 { (#,#) ww5 ww6 ->
                              GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Lib.$fShowConstant4
                                (case b1 of ww2 { GHC.Types.I# ww3 ->
                                 case GHC.Show.$wshowSignedInt
                                        11#
                                        ww3
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.$fShow(,)2
                                           w1) of ww4 { (#,#) ww5 ww6 ->
                                 GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) }
                   Lib.StringConstant b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> GHC.CString.unpackAppendCString#
                             Lib.$fShowConstant3
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.$fShow(,)3
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 w1)))
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Lib.$fShowConstant3
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.$fShow(,)3
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1))))) }
                   Lib.BoolConstant b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> GHC.CString.unpackAppendCString#
                             Lib.$fShowConstant2
                             (case b1 of wild2 {
                                GHC.Types.False
                                -> GHC.Base.++ @ GHC.Types.Char GHC.Show.$fShowBool3 w1
                                GHC.Types.True
                                -> GHC.Base.++ @ GHC.Types.Char GHC.Show.$fShowBool1 w1 })
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Lib.$fShowConstant2
                                (case b1 of wild2 {
                                   GHC.Types.False
                                   -> GHC.Base.++
                                        @ GHC.Types.Char
                                        GHC.Show.$fShowBool3
                                        (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1)
                                   GHC.Types.True
                                   -> GHC.Base.++
                                        @ GHC.Types.Char
                                        GHC.Show.$fShowBool1
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.$fShow(,)2
                                           w1) })) } }) -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec3 :: GHC.Prim.Int# -> Lib.DBComand -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: Lib.DBComand) ->
                 case w of wild {
                   Lib.PublishDBComand b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = case b1 of ww1 { Lib.PublishComand ww2 ww3 ww4 ->
                          Lib.$w$cshowsPrec5 11# ww2 ww3 ww4 }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Lib.$fShowDBComand5 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Lib.$fShowDBComand5
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   Lib.LoadDBComand b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = case b1 of ww1 { Lib.LoadComand ww2 ww3 ->
                          Lib.$w$cshowsPrec4 11# ww2 ww3 }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11#) of wild1 {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Lib.$fShowDBComand2 (g x)
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Lib.$fShowDBComand2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> Lib.Expression -> GHC.Base.String -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Lib.Expression)
                   (ww2 :: GHC.Base.String) ->
                 let {
                   f20 :: GHC.Base.String -> GHC.Base.String
                   = Lib.$w$cshowsPrec1 11# ww1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Lib.$fShowDBComand4
                        (f20
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showSpace1
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.$fShow(,)3
                                 (GHC.Show.showLitString
                                    ww2
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 x)))))
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Lib.$fShowDBComand4
                           (f20
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (GHC.Types.:
                                    @ GHC.Types.Char
                                    GHC.Show.$fShow(,)3
                                    (GHC.Show.showLitString
                                       ww2
                                       (GHC.Types.:
                                          @ GHC.Types.Char
                                          GHC.Show.$fShow(,)3
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.$fShow(,)2
                                             x))))))) }) -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec5 ::
    GHC.Prim.Int#
    -> Lib.Expression
    -> Lib.Expression
    -> GHC.Types.Int
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <S,U><L,1*U><L,1*U><L,U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Lib.Expression)
                   (ww2 :: Lib.Expression)
                   (ww3 :: GHC.Types.Int) ->
                 let {
                   f20 :: GHC.Base.String -> GHC.Base.String
                   = Lib.$w$cshowsPrec1 11# ww1
                 } in
                 let {
                   f21 :: GHC.Base.String -> GHC.Base.String
                   = Lib.$w$cshowsPrec1 11# ww2
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     f20
                       (GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.showSpace1
                          (f21
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.showSpace1
                                (case ww3 of ww4 { GHC.Types.I# ww5 ->
                                 case GHC.Show.$wshowSignedInt 11# ww5 x of ww6 { (#,#) ww7 ww8 ->
                                 GHC.Types.: @ GHC.Types.Char ww7 ww8 } }))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++ @ GHC.Types.Char Lib.$fShowDBComand7 (g x)
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Lib.$fShowDBComand7
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }) -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec6 ::
    GHC.Prim.Int#
    -> Lib.Expression
    -> Lib.Expression
    -> Lib.Expression
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <S,U><L,1*U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Lib.Expression)
                   (ww2 :: Lib.Expression)
                   (ww3 :: Lib.Expression) ->
                 let {
                   f20 :: GHC.Base.String -> GHC.Base.String
                   = Lib.$w$cshowsPrec1 11# ww1
                 } in
                 let {
                   f21 :: GHC.Base.String -> GHC.Base.String
                   = Lib.$w$cshowsPrec1 11# ww2
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Lib.$w$cshowsPrec1 11# ww3
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Lib.$fShowIfThenElse2
                        (f20
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showSpace1
                              (f21 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))))
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Lib.$fShowIfThenElse2
                           (f20
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (f21
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (g (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.$fShow(,)2
                                             x))))))) }) -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec7 ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> [Lib.Expression]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: [Lib.Expression])
                   (w :: GHC.Base.String) ->
                 let {
                   p11 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.CString.unpackAppendCString#
                       Lib.$fShowInvocation2
                       (GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.$fShow(,)3
                          (GHC.Show.showLitString
                             ww1
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.$fShow(,)3
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (case ww2 of wild {
                                      [] -> GHC.CString.unpackAppendCString# GHC.Show.showList__4 x
                                      : x1 xs
                                      -> GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.showList__3
                                           (Lib.$w$cshowsPrec1
                                              0#
                                              x1
                                              (let {
                                                 lvl136 :: [GHC.Types.Char]
                                                 = GHC.Types.:
                                                     @ GHC.Types.Char
                                                     GHC.Show.showList__2
                                                     x
                                               } in
                                               letrec {
                                                 showl :: [Lib.Expression] -> GHC.Base.String
                                                   {- Arity: 1, Strictness: <S,1*U> -}
                                                 = \ (ds2 :: [Lib.Expression]) ->
                                                   case ds2 of wild1 {
                                                     [] -> lvl136
                                                     : y ys
                                                     -> GHC.Types.:
                                                          @ GHC.Types.Char
                                                          GHC.Show.showList__1
                                                          (Lib.$w$cshowsPrec1 0# y (showl ys)) }
                                               } in
                                               showl xs)) })))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p11 w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p11 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w)) }) -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec8 ::
    GHC.Prim.Int# -> [GHC.Base.String] -> Lib.Program -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,U><L,1*U(U,1*U(1*U))>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: [GHC.Base.String])
                   (ww2 :: Lib.Program) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = case ww2 of ww3 { Lib.Program ww4 ww5 ->
                     Lib.$w$cshowsPrec9 11# ww4 ww5 }
                 } in
                 let {
                   p11 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.CString.unpackAppendCString#
                       Lib.$fShowLambdaDef2
                       (let {
                          s :: GHC.Base.String = g x
                        } in
                        let {
                          s1 :: GHC.Base.String
                          = GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 s
                        } in
                        case ww1 of wild {
                          [] -> GHC.CString.unpackAppendCString# GHC.Show.showList__4 s1
                          : x1 xs
                          -> GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showList__3
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.$fShow(,)3
                                  (GHC.Show.showLitString
                                     x1
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.$fShow(,)3
                                        (let {
                                           lvl136 :: [GHC.Types.Char]
                                           = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__2 s1
                                         } in
                                         letrec {
                                           showl :: [[GHC.Types.Char]] -> GHC.Base.String
                                             {- Arity: 1, Strictness: <S,1*U> -}
                                           = \ (ds2 :: [[GHC.Types.Char]]) ->
                                             case ds2 of wild1 {
                                               [] -> lvl136
                                               : y ys
                                               -> GHC.Types.:
                                                    @ GHC.Types.Char
                                                    GHC.Show.showList__1
                                                    (GHC.Types.:
                                                       @ GHC.Types.Char
                                                       GHC.Show.$fShow(,)3
                                                       (GHC.Show.showLitString
                                                          y
                                                          (GHC.Types.:
                                                             @ GHC.Types.Char
                                                             GHC.Show.$fShow(,)3
                                                             (showl ys)))) }
                                         } in
                                         showl xs)))) })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p11
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p11 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }) -}
d2434dc127416df673fccc4dadac7334
  $w$cshowsPrec9 ::
    GHC.Prim.Int#
    -> [Lib.Statement] -> Lib.ReturnStatement -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,U><L,1*U(1*U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: [Lib.Statement])
                   (ww2 :: Lib.ReturnStatement) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = case ww2 of ww3 { Lib.ReturnStatement ww4 ->
                     Lib.$w$cshowsPrec11 11# ww4 }
                 } in
                 let {
                   p11 :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.CString.unpackAppendCString#
                       Lib.$fShowLambdaDef3
                       (let {
                          s :: GHC.Base.String = g x
                        } in
                        let {
                          s1 :: GHC.Base.String
                          = GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 s
                        } in
                        case ww1 of wild {
                          [] -> GHC.CString.unpackAppendCString# GHC.Show.showList__4 s1
                          : x1 xs
                          -> GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showList__3
                               (Lib.$w$cshowsPrec10
                                  0#
                                  x1
                                  (let {
                                     lvl136 :: [GHC.Types.Char]
                                     = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__2 s1
                                   } in
                                   letrec {
                                     showl :: [Lib.Statement] -> GHC.Base.String
                                       {- Arity: 1, Strictness: <S,1*U> -}
                                     = \ (ds2 :: [Lib.Statement]) ->
                                       case ds2 of wild1 {
                                         [] -> lvl136
                                         : y ys
                                         -> GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.showList__1
                                              (Lib.$w$cshowsPrec10 0# y (showl ys)) }
                                   } in
                                   showl xs)) })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p11
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p11 (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }) -}
ec01a24cb4afb0f4a699f78305aff291
  $w$sspace ::
    Text.Megaparsec.ParsecT
      Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> Text.Megaparsec.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> Text.Megaparsec.ParsecT
         Data.Void.Void GHC.Base.String Data.Functor.Identity.Identity ()
    -> forall b.
       Text.Megaparsec.State GHC.Base.String
       -> (()
           -> Text.Megaparsec.State GHC.Base.String
           -> Text.Megaparsec.Hints
                (Text.Megaparsec.Stream.Token GHC.Base.String)
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void
           -> Text.Megaparsec.State GHC.Base.String
           -> Data.Functor.Identity.Identity b)
       -> (()
           -> Text.Megaparsec.State GHC.Base.String
           -> Text.Megaparsec.Hints
                (Text.Megaparsec.Stream.Token GHC.Base.String)
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 7,
     Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,C(C1(C1(C1(C1(U)))))><L,U(U,U(U(U,U,U),U),U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [0] -}
bc1f20187b0575fc84e79f3b766b2e83
  $wdt ::
    Data.ByteString.Builder.Internal.BuildStep r
    -> GHC.Prim.Addr#
    -> GHC.Prim.Addr#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.ByteString.Builder.Internal.BuildSignal r #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(U(U,U)))><S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ r
                   (w :: Data.ByteString.Builder.Internal.BuildStep r)
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.Prim.Addr#)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# (GHC.Prim.minusAddr# ww1 ww) 1#) of wild2 {
                   GHC.Types.False
                   -> case GHC.Prim.writeWord8OffAddr#
                             @ GHC.Prim.RealWorld
                             ww
                             0#
                             2##
                             w1 of s2 { DEFAULT ->
                      (w (Data.ByteString.Builder.Internal.BufferRange
                            (GHC.Prim.plusAddr# ww 1#)
                            ww1))
                        `cast`
                      (GHC.Types.N:IO[0]
                           <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                        s2 }
                   GHC.Types.True
                   -> (# w1,
                         Data.ByteString.Builder.Internal.BufferFull
                           @ r
                           1#
                           ww
                           (\ (ds :: Data.ByteString.Builder.Internal.BufferRange)
                              (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                            case ds of wild { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   dt11
                                   0#
                                   2##
                                   eta of s2 { DEFAULT ->
                            (w (Data.ByteString.Builder.Internal.BufferRange
                                  (GHC.Prim.plusAddr# dt11 1#)
                                  dt12))
                              `cast`
                            (GHC.Types.N:IO[0]
                                 <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                              s2 } })
                             `cast`
                           (<Data.ByteString.Builder.Internal.BufferRange>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <Data.ByteString.Builder.Internal.BuildSignal
                                             r>_R)) #) }) -}
176cf17dd4c3e5b52a74643f789a7d2e
  $wdt1 ::
    Data.ByteString.Builder.Internal.BuildStep r
    -> GHC.Prim.Addr#
    -> GHC.Prim.Addr#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.ByteString.Builder.Internal.BuildSignal r #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(U(U,U)))><S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ r
                   (w :: Data.ByteString.Builder.Internal.BuildStep r)
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.Prim.Addr#)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# (GHC.Prim.minusAddr# ww1 ww) 1#) of wild2 {
                   GHC.Types.False
                   -> case GHC.Prim.writeWord8OffAddr#
                             @ GHC.Prim.RealWorld
                             ww
                             0#
                             1##
                             w1 of s2 { DEFAULT ->
                      (w (Data.ByteString.Builder.Internal.BufferRange
                            (GHC.Prim.plusAddr# ww 1#)
                            ww1))
                        `cast`
                      (GHC.Types.N:IO[0]
                           <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                        s2 }
                   GHC.Types.True
                   -> (# w1,
                         Data.ByteString.Builder.Internal.BufferFull
                           @ r
                           1#
                           ww
                           (\ (ds :: Data.ByteString.Builder.Internal.BufferRange)
                              (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                            case ds of wild { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   dt11
                                   0#
                                   1##
                                   eta of s2 { DEFAULT ->
                            (w (Data.ByteString.Builder.Internal.BufferRange
                                  (GHC.Prim.plusAddr# dt11 1#)
                                  dt12))
                              `cast`
                            (GHC.Types.N:IO[0]
                                 <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                              s2 } })
                             `cast`
                           (<Data.ByteString.Builder.Internal.BufferRange>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <Data.ByteString.Builder.Internal.BuildSignal
                                             r>_R)) #) }) -}
c181348e0a974eabfadbdf13104bced6
  $wdt2 ::
    Data.ByteString.Builder.Internal.BuildStep r
    -> GHC.Prim.Addr#
    -> GHC.Prim.Addr#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.ByteString.Builder.Internal.BuildSignal r #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(U(U,U)))><S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ @ r
                   (w :: Data.ByteString.Builder.Internal.BuildStep r)
                   (ww :: GHC.Prim.Addr#)
                   (ww1 :: GHC.Prim.Addr#)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# (GHC.Prim.minusAddr# ww1 ww) 1#) of wild2 {
                   GHC.Types.False
                   -> case GHC.Prim.writeWord8OffAddr#
                             @ GHC.Prim.RealWorld
                             ww
                             0#
                             0##
                             w1 of s2 { DEFAULT ->
                      (w (Data.ByteString.Builder.Internal.BufferRange
                            (GHC.Prim.plusAddr# ww 1#)
                            ww1))
                        `cast`
                      (GHC.Types.N:IO[0]
                           <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                        s2 }
                   GHC.Types.True
                   -> (# w1,
                         Data.ByteString.Builder.Internal.BufferFull
                           @ r
                           1#
                           ww
                           (\ (ds :: Data.ByteString.Builder.Internal.BufferRange)
                              (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                            case ds of wild { Data.ByteString.Builder.Internal.BufferRange dt11 dt12 ->
                            case GHC.Prim.writeWord8OffAddr#
                                   @ GHC.Prim.RealWorld
                                   dt11
                                   0#
                                   0##
                                   eta of s2 { DEFAULT ->
                            (w (Data.ByteString.Builder.Internal.BufferRange
                                  (GHC.Prim.plusAddr# dt11 1#)
                                  dt12))
                              `cast`
                            (GHC.Types.N:IO[0]
                                 <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                              s2 } })
                             `cast`
                           (<Data.ByteString.Builder.Internal.BufferRange>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <Data.ByteString.Builder.Internal.BuildSignal
                                             r>_R)) #) }) -}
11a82e45ddced73f485f980dd0f97190
  $wgo ::
    ([Lib.Statement] -> [Lib.Statement])
    -> forall b.
       Text.Megaparsec.State [GHC.Types.Char]
       -> (([Lib.Statement] -> [Lib.Statement])
           -> Text.Megaparsec.State [GHC.Types.Char]
           -> Text.Megaparsec.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> (([Lib.Statement] -> [Lib.Statement])
           -> Text.Megaparsec.State [GHC.Types.Char]
           -> Text.Megaparsec.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 5,
     Strictness: <L,U><L,U(U,U(U(U,U,U),U),U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
     Inline: [0] -}
d2434dc127416df673fccc4dadac7334
  data Assignment = Assignment GHC.Base.String Lib.Expression
134f098db942ee94766d361f69ca06a8
  data Constant
    = IntConstant GHC.Types.Int
    | StringConstant GHC.Base.String
    | BoolConstant GHC.Types.Bool
d2434dc127416df673fccc4dadac7334
  data DBComand
    = PublishDBComand Lib.PublishComand | LoadDBComand Lib.LoadComand
d2434dc127416df673fccc4dadac7334
  data Expression
    = InvocationExpression Lib.Invocation
    | ConstantExpression Lib.Constant
    | OperatorExpression Lib.Operator
    | IfThenElseExpression Lib.IfThenElse
    | LambdaDefExpression Lib.LambdaDef
    | BracesExpression Lib.Expression
    | VariableExpression GHC.Base.String
d2434dc127416df673fccc4dadac7334
  data IfThenElse
    = IfThenElse Lib.Expression Lib.Expression Lib.Expression
d2434dc127416df673fccc4dadac7334
  data Invocation = Invocation GHC.Base.String [Lib.Expression]
d2434dc127416df673fccc4dadac7334
  data LambdaDef = LambdaDef [GHC.Base.String] Lib.Program
d2434dc127416df673fccc4dadac7334
  data LoadComand = LoadComand Lib.Expression GHC.Base.String
d2434dc127416df673fccc4dadac7334
  data Loop = While Lib.Expression [Lib.Statement]
d2434dc127416df673fccc4dadac7334
  data Operator
    = UnaryOperator Lib.OperatorType GHC.Base.String Lib.Expression
    | BinaryOperator Lib.OperatorType
                     GHC.Base.String
                     Lib.Expression
                     Lib.Expression
e9c0f629e94b1f09f2a96f8603ed9c1b
  data OperatorType = IntType | StringType | BoolType
ad6c4fc61ed16a2302616cd5dbe6cdd7
  type Parser =
    Text.Megaparsec.Parsec Data.Void.Void GHC.Base.String :: * -> *
d2434dc127416df673fccc4dadac7334
  data Program = Program [Lib.Statement] Lib.ReturnStatement
d2434dc127416df673fccc4dadac7334
  data PublishComand
    = PublishComand Lib.Expression Lib.Expression GHC.Types.Int
d2434dc127416df673fccc4dadac7334
  data ReturnStatement = ReturnStatement Lib.Expression
d2434dc127416df673fccc4dadac7334
  data Statement
    = AssignmentStatement Lib.Assignment
    | LoopStatement Lib.Loop
    | InvocationStatement Lib.Invocation
    | DBComandStatement Lib.DBComand
0491f8ad3ac2420298a6d2f56dabf8f3
  type VariableMap =
    Data.Map.Internal.Map GHC.Base.String GHC.Base.String
bfa68c46cd94d72e14e82b6705a3a55f
  runScript :: GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.runScript1
                  `cast`
                (<GHC.IO.FilePath>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
caa2c3f1d2b05de5dcce5115fed3c684
  runScript1 ::
    GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (file :: GHC.IO.FilePath)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Handle.FD.openFile1
                        file
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case (Lib.runScript11
                         @ (Text.Megaparsec.Reply
                              Data.Void.Void GHC.Base.String Lib.Program)
                         (Text.Megaparsec.State
                            @ GHC.Base.String
                            ipv3
                            Lib.runScript9
                            0#
                            Text.Megaparsec.Pos.defaultTabWidth_a
                              `cast`
                            (Sym (Text.Megaparsec.Pos.N:Pos[0])))
                         (Text.Megaparsec.$fMonadContParsecT5
                            @ Data.Void.Void
                            @ GHC.Base.String
                            @ Lib.Program)
                           `cast`
                         (<Lib.Program>_R
                          ->_R <Text.Megaparsec.State GHC.Base.String>_R
                          ->_R <Text.Megaparsec.Hints
                                  (Text.Megaparsec.Stream.Token GHC.Base.String)>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Reply
                                           Data.Void.Void GHC.Base.String Lib.Program>_R))
                         (Text.Megaparsec.$fMonadContParsecT4
                            @ GHC.Base.String
                            @ Data.Void.Void
                            @ Lib.Program)
                           `cast`
                         (<Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void>_R
                          ->_R <Text.Megaparsec.State GHC.Base.String>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Reply
                                           Data.Void.Void GHC.Base.String Lib.Program>_R))
                         (Text.Megaparsec.$fMonadContParsecT3
                            @ Data.Void.Void
                            @ GHC.Base.String
                            @ Lib.Program)
                           `cast`
                         (<Lib.Program>_R
                          ->_R <Text.Megaparsec.State GHC.Base.String>_R
                          ->_R <Text.Megaparsec.Hints
                                  (Text.Megaparsec.Stream.Token GHC.Base.String)>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Reply
                                           Data.Void.Void GHC.Base.String Lib.Program>_R))
                         (Text.Megaparsec.$fMonadContParsecT2
                            @ GHC.Base.String
                            @ Data.Void.Void
                            @ Lib.Program)
                           `cast`
                         (<Text.Megaparsec.Error.ParseError
                             (Text.Megaparsec.Stream.Token GHC.Base.String) Data.Void.Void>_R
                          ->_R <Text.Megaparsec.State GHC.Base.String>_R
                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                        <Text.Megaparsec.Reply
                                           Data.Void.Void GHC.Base.String Lib.Program>_R)))
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <Text.Megaparsec.Reply
                              Data.Void.Void
                              GHC.Base.String
                              Lib.Program>_R) of wild { Text.Megaparsec.Reply s' ds result ->
                 case result of wild1 {
                   Text.Megaparsec.OK x
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             Lib.runScript7
                             GHC.Types.True
                             ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                      case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             (case Data.Binary.Get.runGet3
                                     @ Lib.Program
                                     Lib.runScript3
                                     (Data.ByteString.Builder.toLazyByteString
                                        (case x of ww { Lib.Program ww1 ww2 ->
                                         case Lib.$w$cput9 ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                                         ww5 } })) of ww { Lib.Program ww1 ww2 ->
                              Lib.$w$cshowsPrec9 0# ww1 ww2 (GHC.Types.[] @ GHC.Types.Char) })
                             GHC.Types.False
                             ipv4 of ds4 { (#,#) ipv6 ipv7 ->
                      GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Lib.runScript7
                        GHC.Types.True
                        ipv6 } }
                   Text.Megaparsec.Error e1
                   -> GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (Lib.runScript2
                           Text.Megaparsec.Error.$fDataErrorItem3
                           e1
                             `cast`
                           (Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.D:R:Token[][0]) <Data.Void.Void>_N)_R
                           (GHC.Types.[] @ GHC.Types.Char))
                        GHC.Types.True
                        ipv2 } } } }) -}
d9a1a329c4561bc47d5406ad6c005d0e
  runScript10 :: Text.Megaparsec.Pos.SourcePos
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Text.Megaparsec.Pos.SourcePos
                   (GHC.Types.[] @ GHC.Types.Char)
                   1#
                   1#) -}
40bbed9eb5bc82276eede687e767274c
  runScript11 ::
    Text.Megaparsec.State [GHC.Types.Char]
    -> (Lib.Program
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Text.Megaparsec.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (Lib.Program
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Text.Megaparsec.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Arity: 5,
     Strictness: <L,U(U,U(U(U,U,U),U),U,U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
     Unfolding: (\ @ b1
                   (s1 :: Text.Megaparsec.State [GHC.Types.Char])
                   (cok :: Lib.Program
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> Data.Functor.Identity.Identity b1)
                   (cerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State [GHC.Types.Char]
                            -> Data.Functor.Identity.Identity b1)
                   (eok :: Lib.Program
                           -> Text.Megaparsec.State [GHC.Types.Char]
                           -> Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                           -> Data.Functor.Identity.Identity b1)
                   (eerr :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State [GHC.Types.Char]
                            -> Data.Functor.Identity.Identity b1) ->
                 Lib.$wgo
                   (GHC.Base.id @ [Lib.Statement])
                   @ b1
                   s1
                   (\ (x :: [Lib.Statement] -> [Lib.Statement])
                      (s' :: Text.Megaparsec.State [GHC.Types.Char])[OneShot]
                      (hs :: Text.Megaparsec.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    Lib.runScript12
                      (x (GHC.Types.[] @ Lib.Statement))
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ Lib.Program
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         cok)
                      (Lib.$s$fAlternativeParsecT_$swithHints
                         @ Data.Void.Void
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         cerr))
                   cerr
                   (\ (x :: [Lib.Statement] -> [Lib.Statement])
                      (s' :: Text.Megaparsec.State [GHC.Types.Char])[OneShot]
                      (hs :: Text.Megaparsec.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))[OneShot] ->
                    Lib.runScript12
                      (x (GHC.Types.[] @ Lib.Statement))
                      @ b1
                      s'
                      cok
                      cerr
                      (Text.Megaparsec.accHints
                         @ (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                         @ Lib.Program
                         @ [GHC.Types.Char]
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         eok)
                      (Lib.$s$fAlternativeParsecT_$swithHints
                         @ Data.Void.Void
                         @ Data.Functor.Identity.Identity
                         @ b1
                         hs
                         eerr))) -}
edcc2ece1522a1433427c911c10f309e
  runScript12 ::
    [Lib.Statement]
    -> forall b.
       Text.Megaparsec.State [GHC.Types.Char]
       -> (Lib.Program
           -> Text.Megaparsec.State [GHC.Types.Char]
           -> Text.Megaparsec.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> (Lib.Program
           -> Text.Megaparsec.State [GHC.Types.Char]
           -> Text.Megaparsec.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b)
       -> Data.Functor.Identity.Identity b
  {- Arity: 6,
     Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
     Unfolding: (\ (statement :: [Lib.Statement])
                   @ b
                   (eta :: Text.Megaparsec.State [GHC.Types.Char])
                   (eta1 :: Lib.Program
                            -> Text.Megaparsec.State [GHC.Types.Char]
                            -> Text.Megaparsec.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> Data.Functor.Identity.Identity b)
                   (eta2 :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State [GHC.Types.Char]
                            -> Data.Functor.Identity.Identity b)
                   (eta3 :: Lib.Program
                            -> Text.Megaparsec.State [GHC.Types.Char]
                            -> Text.Megaparsec.Hints
                                 (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                            -> Data.Functor.Identity.Identity b)
                   (eta4 :: Text.Megaparsec.Error.ParseError
                              (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
                            -> Text.Megaparsec.State [GHC.Types.Char]
                            -> Data.Functor.Identity.Identity b) ->
                 let {
                   lvl136 :: Lib.Expression
                             -> Text.Megaparsec.State [GHC.Types.Char]
                             -> Text.Megaparsec.Hints
                                  (Text.Megaparsec.Stream.Token [GHC.Types.Char])
                             -> Data.Functor.Identity.Identity b
                     {- Arity: 3, Strictness: <L,U><L,U><L,U> -}
                   = \ (x :: Lib.Expression)
                       (s' :: Text.Megaparsec.State [GHC.Types.Char])
                       (hs :: Text.Megaparsec.Hints
                                (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                     eta1 (Lib.Program statement (Lib.ReturnStatement x)) s' hs
                 } in
                 Lib.runScript14
                   @ b
                   eta
                   (\ (x :: ())
                      (s' :: Text.Megaparsec.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    Lib.runScript13
                      @ b
                      s'
                      lvl136
                      eta2
                      (\ (x1 :: Lib.Expression)
                         (s'1 :: Text.Megaparsec.State [GHC.Types.Char])
                         (hs1 :: Text.Megaparsec.Hints
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       eta1
                         (Lib.Program statement (Lib.ReturnStatement x1))
                         s'1
                         (GHC.Base.++
                            @ (Data.Set.Internal.Set
                                 (Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                            hs
                              `cast`
                            (Text.Megaparsec.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)
                            hs1
                              `cast`
                            (Text.Megaparsec.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           `cast`
                         (Sym (Text.Megaparsec.N:Hints[0]
                                   <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                      (Lib.$s$fAlternativeParsecT_$swithHints
                         @ Data.Void.Void
                         @ Data.Functor.Identity.Identity
                         @ b
                         hs
                         eta2))
                   eta2
                   (\ (x :: ())
                      (s' :: Text.Megaparsec.State [GHC.Types.Char])
                      (hs :: Text.Megaparsec.Hints
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                    Lib.runScript13
                      @ b
                      s'
                      lvl136
                      eta2
                      (\ (x1 :: Lib.Expression)
                         (s'1 :: Text.Megaparsec.State [GHC.Types.Char])
                         (hs1 :: Text.Megaparsec.Hints
                                   (Text.Megaparsec.Stream.Token [GHC.Types.Char])) ->
                       eta3
                         (Lib.Program statement (Lib.ReturnStatement x1))
                         s'1
                         (GHC.Base.++
                            @ (Data.Set.Internal.Set
                                 (Text.Megaparsec.Error.ErrorItem
                                    (Text.Megaparsec.Stream.Token [GHC.Types.Char])))
                            hs
                              `cast`
                            (Text.Megaparsec.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)
                            hs1
                              `cast`
                            (Text.Megaparsec.N:Hints[0]
                                 <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N))
                           `cast`
                         (Sym (Text.Megaparsec.N:Hints[0]
                                   <Text.Megaparsec.Stream.Token [GHC.Types.Char]>_N)))
                      (Lib.$s$fAlternativeParsecT_$swithHints
                         @ Data.Void.Void
                         @ Data.Functor.Identity.Identity
                         @ b
                         hs
                         eta4))
                   eta4) -}
04b2d09d63fcde7ac9553fa4340bc80f
  runScript13 ::
    Text.Megaparsec.State [GHC.Types.Char]
    -> (Lib.Expression
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Text.Megaparsec.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> (Lib.Expression
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Text.Megaparsec.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b)
    -> Data.Functor.Identity.Identity b
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,C(U)><L,C(C1(U))> -}
47bef1c85d44fa020a2b68f1c10fb902
  runScript14 ::
    Text.Megaparsec.State [GHC.Types.Char]
    -> (()
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Text.Megaparsec.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> (()
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Text.Megaparsec.Hints
             (Text.Megaparsec.Stream.Token [GHC.Types.Char])
        -> Data.Functor.Identity.Identity b1)
    -> (Text.Megaparsec.Error.ParseError
          (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
        -> Text.Megaparsec.State [GHC.Types.Char]
        -> Data.Functor.Identity.Identity b1)
    -> Data.Functor.Identity.Identity b1
  {- Unfolding: (Lib.runScript17 Lib.runScript15) -}
39f7a260e2567cc1cc5996e371dc3bc9
  runScript15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.runScript16) -}
c51e9af3ef37625aa91ea91e51ab02ce
  runScript16 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("return"#) -}
4cf510d56ad1dc070020494f6b891116
  runScript17 ::
    GHC.Base.String
    -> forall b1.
       Text.Megaparsec.State [GHC.Types.Char]
       -> (()
           -> Text.Megaparsec.State [GHC.Types.Char]
           -> Text.Megaparsec.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b1)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b1)
       -> (()
           -> Text.Megaparsec.State [GHC.Types.Char]
           -> Text.Megaparsec.Hints
                (Text.Megaparsec.Stream.Token [GHC.Types.Char])
           -> Data.Functor.Identity.Identity b1)
       -> (Text.Megaparsec.Error.ParseError
             (Text.Megaparsec.Stream.Token [GHC.Types.Char]) Data.Void.Void
           -> Text.Megaparsec.State [GHC.Types.Char]
           -> Data.Functor.Identity.Identity b1)
       -> Data.Functor.Identity.Identity b1
  {- Arity: 1, Strictness: <L,U> -}
98bfb63f5752649b1383f3ee3148c977
  runScript2 ::
    GHC.Types.Int
    -> Text.Megaparsec.Error.ParseError GHC.Types.Char Data.Void.Void
    -> GHC.Show.ShowS
  {- Unfolding: (Text.Megaparsec.Error.$fShowParseError_$cshowsPrec
                   @ GHC.Types.Char
                   @ Data.Void.Void
                   Data.Void.$fShowVoid
                   GHC.Show.$fShowChar) -}
84c7ec5cee81d44b544e03670b8c79fe
  runScript3 :: Data.Binary.Get.Decoder Lib.Program
  {- Unfolding: (Data.Binary.Get.$wpoly_go
                   @ Lib.Program
                   Lib.runScript4
                   0#) -}
8ad97805cd8eaf9761bd89296dee94b7
  runScript4 :: Data.Binary.Get.Internal.Decoder Lib.Program
  {- Unfolding: (Data.Binary.Get.Internal.runGetIncremental1
                   @ Lib.Program
                   Lib.runScript5) -}
63d9e4507911d974eedeb5e60c639690
  runScript5 :: Data.Binary.Get.Internal.Decoder Lib.Program
  {- Unfolding: (Data.Binary.Class.$w$cget11
                   @ Lib.Statement
                   Lib.$fBinaryStatement
                   @ Lib.Program
                   __NULL
                   Data.ByteString.Internal.$fMonoidByteString1
                   0#
                   0#
                   Lib.runScript6) -}
8d57f0d53b1a2fca3546f88c8517d429
  runScript6 ::
    Data.ByteString.Internal.ByteString
    -> [Lib.Statement] -> Data.Binary.Get.Internal.Decoder Lib.Program
  {- Arity: 2, Strictness: <S(SLSS),1*U(U,U,U,U)><L,U>,
     Unfolding: (\ (i' :: Data.ByteString.Internal.ByteString)
                   (a1 :: [Lib.Statement])[OneShot] ->
                 case i' of ww { Data.ByteString.Internal.PS ww1 ww2 ww3 ww4 ->
                 Lib.$w$cget1
                   @ Lib.Program
                   ww1
                   ww2
                   ww3
                   ww4
                   (\ (i'1 :: Data.ByteString.Internal.ByteString)
                      (a2 :: Lib.Expression)[OneShot] ->
                    case i'1 of dt11 { Data.ByteString.Internal.PS ipv ipv1 ipv2 ipv3 ->
                    Data.Binary.Get.Internal.Done
                      @ Lib.Program
                      dt11
                      (Lib.Program a1 (Lib.ReturnStatement a2)) }) }) -}
ab7582165e4c7b18b54a08e77a478adf
  runScript7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Lib.runScript8) -}
3bba3fc2612660d0f36f133ae5099438
  runScript8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("---------------------"#) -}
76ca8af7d2e3155fc1feeebe4a89ec98
  runScript9 ::
    Data.List.NonEmpty.NonEmpty Text.Megaparsec.Pos.SourcePos
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Data.List.NonEmpty.:|
                   @ Text.Megaparsec.Pos.SourcePos
                   Lib.runScript10
                   (GHC.Types.[] @ Text.Megaparsec.Pos.SourcePos)) -}
instance Data.Binary.Class.Binary [Lib.Assignment]
  = Lib.$fBinaryAssignment
instance Data.Binary.Class.Binary [Lib.Constant]
  = Lib.$fBinaryConstant
instance Data.Binary.Class.Binary [Lib.DBComand]
  = Lib.$fBinaryDBComand
instance Data.Binary.Class.Binary [Lib.Expression]
  = Lib.$fBinaryExpression
instance Data.Binary.Class.Binary [Lib.IfThenElse]
  = Lib.$fBinaryIfThenElse
instance Data.Binary.Class.Binary [Lib.Invocation]
  = Lib.$fBinaryInvocation
instance Data.Binary.Class.Binary [Lib.LambdaDef]
  = Lib.$fBinaryLambdaDef
instance Data.Binary.Class.Binary [Lib.LoadComand]
  = Lib.$fBinaryLoadComand
instance Data.Binary.Class.Binary [Lib.Loop] = Lib.$fBinaryLoop
instance Data.Binary.Class.Binary [Lib.Operator]
  = Lib.$fBinaryOperator
instance Data.Binary.Class.Binary [Lib.OperatorType]
  = Lib.$fBinaryOperatorType
instance Data.Binary.Class.Binary [Lib.Program]
  = Lib.$fBinaryProgram
instance Data.Binary.Class.Binary [Lib.PublishComand]
  = Lib.$fBinaryPublishComand
instance Data.Binary.Class.Binary [Lib.ReturnStatement]
  = Lib.$fBinaryReturnStatement
instance Data.Binary.Class.Binary [Lib.Statement]
  = Lib.$fBinaryStatement
instance GHC.Show.Show [Lib.Assignment] = Lib.$fShowAssignment
instance GHC.Show.Show [Lib.Constant] = Lib.$fShowConstant
instance GHC.Show.Show [Lib.DBComand] = Lib.$fShowDBComand
instance GHC.Show.Show [Lib.Expression] = Lib.$fShowExpression
instance GHC.Show.Show [Lib.IfThenElse] = Lib.$fShowIfThenElse
instance GHC.Show.Show [Lib.Invocation] = Lib.$fShowInvocation
instance GHC.Show.Show [Lib.LambdaDef] = Lib.$fShowLambdaDef
instance GHC.Show.Show [Lib.LoadComand] = Lib.$fShowLoadComand
instance GHC.Show.Show [Lib.Loop] = Lib.$fShowLoop
instance GHC.Show.Show [Lib.Operator] = Lib.$fShowOperator
instance GHC.Show.Show [Lib.OperatorType] = Lib.$fShowOperatorType
instance GHC.Show.Show [Lib.Program] = Lib.$fShowProgram
instance GHC.Show.Show [Lib.PublishComand]
  = Lib.$fShowPublishComand
instance GHC.Show.Show [Lib.ReturnStatement]
  = Lib.$fShowReturnStatement
instance GHC.Show.Show [Lib.Statement] = Lib.$fShowStatement
"SPEC/Lib $fAlternativeParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                         -> *
                                                                  (v1 :: Text.Megaparsec.Stream.Stream
                                                                           [GHC.Types.Char])
                                                                  (v :: GHC.Classes.Ord
                                                                          Data.Void.Void)
  Text.Megaparsec.$fAlternativeParsecT @ Data.Void.Void
                                       @ [GHC.Types.Char]
                                       @ m
                                       v
                                       v1
  = Lib.$s$fAlternativeParsecT @ m
"SPEC/Lib $fApplicativeParsecT @ [Char] _ _" [orphan] forall @ e
                                                             @ m :: * -> *
                                                             (v :: Text.Megaparsec.Stream.Stream
                                                                     [GHC.Types.Char])
  Text.Megaparsec.$fApplicativeParsecT @ [GHC.Types.Char] @ e @ m v
  = Lib.$s$fAlternativeParsecT_$s$fApplicativeParsecT @ e @ m
"SPEC/Lib $fEqErrorFancy @ Void" [orphan] forall (v :: GHC.Classes.Eq
                                                         Data.Void.Void)
  Text.Megaparsec.Error.$fEqErrorFancy @ Data.Void.Void v
  = Lib.$s$fEqErrorFancy
"SPEC/Lib $fEqErrorItem @ (Token [Char])" [orphan] forall (v :: GHC.Classes.Eq
                                                                  (Text.Megaparsec.Stream.Token
                                                                     [GHC.Types.Char]))
  Text.Megaparsec.Error.$fEqErrorItem @ (Text.Megaparsec.Stream.Token
                                           [GHC.Types.Char])
                                      v
  = Lib.$s$fEqErrorItem
"SPEC/Lib $fMonadParsecT @ [Char] _ _" [orphan] forall @ e
                                                       @ m :: * -> *
                                                       (v :: Text.Megaparsec.Stream.Stream
                                                               [GHC.Types.Char])
  Text.Megaparsec.$fMonadParsecT @ [GHC.Types.Char] @ e @ m v
  = Lib.$s$fMonadParsecT @ e @ m
"SPEC/Lib $fMonadParsecT_$c>> @ [Char] _ _" [orphan] forall @ e
                                                            @ m :: * -> *
                                                            ($dStream :: Text.Megaparsec.Stream.Stream
                                                                           [GHC.Types.Char])
  Text.Megaparsec.$fMonadParsecT_$c>> @ [GHC.Types.Char]
                                      @ e
                                      @ m
                                      $dStream
  = Lib.$s$fMonadParsecT_$s$fMonadParsecT_$c>> @ e @ m
"SPEC/Lib $fMonadParsecesParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                           -> *
                                                                    (v1 :: Text.Megaparsec.Stream.Stream
                                                                             [GHC.Types.Char])
                                                                    (v :: GHC.Classes.Ord
                                                                            Data.Void.Void)
  Text.Megaparsec.$fMonadParsecesParsecT @ Data.Void.Void
                                         @ [GHC.Types.Char]
                                         @ m
                                         v
                                         v1
  = Lib.$s$fMonadParsecesParsecT @ m
"SPEC/Lib $fMonadPlusParsecT @ Void @ [Char] _" [orphan] forall @ m :: *
                                                                       -> *
                                                                (v1 :: Text.Megaparsec.Stream.Stream
                                                                         [GHC.Types.Char])
                                                                (v :: GHC.Classes.Ord
                                                                        Data.Void.Void)
  Text.Megaparsec.$fMonadPlusParsecT @ Data.Void.Void
                                     @ [GHC.Types.Char]
                                     @ m
                                     v
                                     v1
  = Lib.$s$fMonadParsecesParsecT_$s$fMonadPlusParsecT @ m
"SPEC/Lib $fOrdErrorFancy @ Void" [orphan] forall (v :: GHC.Classes.Ord
                                                          Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy @ Data.Void.Void v
  = Lib.$s$fOrdErrorFancy
"SPEC/Lib $fOrdErrorFancy_$c<= @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                   Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$c<= @ Data.Void.Void $dOrd
  = Lib.$s$fOrdErrorFancy_$c<=
"SPEC/Lib $fOrdErrorFancy_$c>= @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                   Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$c>= @ Data.Void.Void $dOrd
  = Lib.$s$fOrdErrorFancy_$c>=
"SPEC/Lib $fOrdErrorFancy_$cmax @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                    Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$cmax @ Data.Void.Void $dOrd
  = Lib.$s$fOrdErrorFancy_$cmax
"SPEC/Lib $fOrdErrorFancy_$cmin @ Void" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                    Data.Void.Void)
  Text.Megaparsec.Error.$fOrdErrorFancy_$cmin @ Data.Void.Void $dOrd
  = Lib.$s$fOrdErrorFancy_$cmin
"SPEC/Lib $fOrdErrorItem @ (Token [Char])" [orphan] forall (v :: GHC.Classes.Ord
                                                                   (Text.Megaparsec.Stream.Token
                                                                      [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem @ (Text.Megaparsec.Stream.Token
                                            [GHC.Types.Char])
                                       v
  = Lib.$s$fOrdErrorItem
"SPEC/Lib $fOrdErrorItem_$c<= @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                            (Text.Megaparsec.Stream.Token
                                                                               [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$c<= @ (Text.Megaparsec.Stream.Token
                                                 [GHC.Types.Char])
                                            $dOrd
  = Lib.$s$fOrdErrorItem_$c<=
"SPEC/Lib $fOrdErrorItem_$c>= @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                            (Text.Megaparsec.Stream.Token
                                                                               [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$c>= @ (Text.Megaparsec.Stream.Token
                                                 [GHC.Types.Char])
                                            $dOrd
  = Lib.$s$fOrdErrorItem_$c>=
"SPEC/Lib $fOrdErrorItem_$cmax @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                             (Text.Megaparsec.Stream.Token
                                                                                [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$cmax @ (Text.Megaparsec.Stream.Token
                                                  [GHC.Types.Char])
                                             $dOrd
  = Lib.$s$fOrdErrorItem_$cmax
"SPEC/Lib $fOrdErrorItem_$cmin @ (Token [Char])" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                             (Text.Megaparsec.Stream.Token
                                                                                [GHC.Types.Char]))
  Text.Megaparsec.Error.$fOrdErrorItem_$cmin @ (Text.Megaparsec.Stream.Token
                                                  [GHC.Types.Char])
                                             $dOrd
  = Lib.$s$fOrdErrorItem_$cmin
"SPEC/Lib defaultPutList @ Assignment" forall ($dBinary :: Data.Binary.Class.Binary
                                                             Lib.Assignment)
  Data.Binary.Class.defaultPutList @ Lib.Assignment $dBinary
  = Lib.$fBinaryAssignment_$sdefaultPutList
"SPEC/Lib defaultPutList @ Constant" forall ($dBinary :: Data.Binary.Class.Binary
                                                           Lib.Constant)
  Data.Binary.Class.defaultPutList @ Lib.Constant $dBinary
  = Lib.$fBinaryConstant_$sdefaultPutList
"SPEC/Lib defaultPutList @ DBComand" forall ($dBinary :: Data.Binary.Class.Binary
                                                           Lib.DBComand)
  Data.Binary.Class.defaultPutList @ Lib.DBComand $dBinary
  = Lib.$fBinaryDBComand_$sdefaultPutList
"SPEC/Lib defaultPutList @ Expression" forall ($dBinary :: Data.Binary.Class.Binary
                                                             Lib.Expression)
  Data.Binary.Class.defaultPutList @ Lib.Expression $dBinary
  = Lib.$fBinaryExpression_$sdefaultPutList
"SPEC/Lib defaultPutList @ IfThenElse" forall ($dBinary :: Data.Binary.Class.Binary
                                                             Lib.IfThenElse)
  Data.Binary.Class.defaultPutList @ Lib.IfThenElse $dBinary
  = Lib.$fBinaryIfThenElse_$sdefaultPutList
"SPEC/Lib defaultPutList @ Invocation" forall ($dBinary :: Data.Binary.Class.Binary
                                                             Lib.Invocation)
  Data.Binary.Class.defaultPutList @ Lib.Invocation $dBinary
  = Lib.$fBinaryInvocation_$sdefaultPutList
"SPEC/Lib defaultPutList @ LambdaDef" forall ($dBinary :: Data.Binary.Class.Binary
                                                            Lib.LambdaDef)
  Data.Binary.Class.defaultPutList @ Lib.LambdaDef $dBinary
  = Lib.$fBinaryLambdaDef_$sdefaultPutList
"SPEC/Lib defaultPutList @ LoadComand" forall ($dBinary :: Data.Binary.Class.Binary
                                                             Lib.LoadComand)
  Data.Binary.Class.defaultPutList @ Lib.LoadComand $dBinary
  = Lib.$fBinaryLoadComand_$sdefaultPutList
"SPEC/Lib defaultPutList @ Loop" forall ($dBinary :: Data.Binary.Class.Binary
                                                       Lib.Loop)
  Data.Binary.Class.defaultPutList @ Lib.Loop $dBinary
  = Lib.$fBinaryLoop_$sdefaultPutList
"SPEC/Lib defaultPutList @ Operator" forall ($dBinary :: Data.Binary.Class.Binary
                                                           Lib.Operator)
  Data.Binary.Class.defaultPutList @ Lib.Operator $dBinary
  = Lib.$fBinaryOperator_$sdefaultPutList
"SPEC/Lib defaultPutList @ OperatorType" forall ($dBinary :: Data.Binary.Class.Binary
                                                               Lib.OperatorType)
  Data.Binary.Class.defaultPutList @ Lib.OperatorType $dBinary
  = Lib.$fBinaryOperatorType_$sdefaultPutList
"SPEC/Lib defaultPutList @ Program" forall ($dBinary :: Data.Binary.Class.Binary
                                                          Lib.Program)
  Data.Binary.Class.defaultPutList @ Lib.Program $dBinary
  = Lib.$fBinaryProgram_$sdefaultPutList
"SPEC/Lib defaultPutList @ PublishComand" forall ($dBinary :: Data.Binary.Class.Binary
                                                                Lib.PublishComand)
  Data.Binary.Class.defaultPutList @ Lib.PublishComand $dBinary
  = Lib.$fBinaryPublishComand_$sdefaultPutList
"SPEC/Lib defaultPutList @ ReturnStatement" forall ($dBinary :: Data.Binary.Class.Binary
                                                                  Lib.ReturnStatement)
  Data.Binary.Class.defaultPutList @ Lib.ReturnStatement $dBinary
  = Lib.$fBinaryReturnStatement_$sdefaultPutList
"SPEC/Lib defaultPutList @ Statement" forall ($dBinary :: Data.Binary.Class.Binary
                                                            Lib.Statement)
  Data.Binary.Class.defaultPutList @ Lib.Statement $dBinary
  = Lib.$fBinaryStatement_$sdefaultPutList
"SPEC/Lib pAp @ [Char] _ _ _ _" [orphan] forall @ e
                                                @ m :: * -> *
                                                @ a
                                                @ b
                                                ($dStream :: Text.Megaparsec.Stream.Stream
                                                               [GHC.Types.Char])
  Text.Megaparsec.pAp @ [GHC.Types.Char] @ e @ m @ a @ b $dStream
  = Lib.$s$fAlternativeParsecT_$spAp @ e @ m @ a @ b
"SPEC/Lib pBind @ [Char] _ _ _ _" [orphan] forall @ e
                                                  @ m :: * -> *
                                                  @ a
                                                  @ b
                                                  ($dStream :: Text.Megaparsec.Stream.Stream
                                                                 [GHC.Types.Char])
  Text.Megaparsec.pBind @ [GHC.Types.Char] @ e @ m @ a @ b $dStream
  = Lib.$s$fMonadParsecT_$spBind @ e @ m @ a @ b
"SPEC/Lib pNotFollowedBy @ [Char] _ _ _" [orphan] forall @ e
                                                         @ m :: * -> *
                                                         @ a
                                                         ($dStream :: Text.Megaparsec.Stream.Stream
                                                                        [GHC.Types.Char])
  Text.Megaparsec.pNotFollowedBy @ [GHC.Types.Char]
                                 @ e
                                 @ m
                                 @ a
                                 $dStream
  = Lib.$s$fMonadParsecesParsecT_$spNotFollowedBy @ e @ m @ a
"SPEC/Lib pPlus @ Void @ [Char] _ _" [orphan] forall @ m :: * -> *
                                                     @ a
                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                    [GHC.Types.Char])
                                                     ($dOrd :: GHC.Classes.Ord Data.Void.Void)
  Text.Megaparsec.pPlus @ Data.Void.Void
                        @ [GHC.Types.Char]
                        @ m
                        @ a
                        $dOrd
                        $dStream
  = Lib.$s$fAlternativeParsecT_$spPlus @ m @ a
"SPEC/Lib pTakeP _ @ [Char] _" [orphan] forall @ e
                                               @ m :: * -> *
                                               ($dStream :: Text.Megaparsec.Stream.Stream
                                                              [GHC.Types.Char])
  Text.Megaparsec.pTakeP @ e @ [GHC.Types.Char] @ m $dStream
  = Lib.$s$fMonadParsecesParsecT_$spTakeP @ e @ m
"SPEC/Lib pTakeWhile1P _ @ [Char] _" [orphan] forall @ e
                                                     @ m :: * -> *
                                                     ($dStream :: Text.Megaparsec.Stream.Stream
                                                                    [GHC.Types.Char])
  Text.Megaparsec.pTakeWhile1P @ e @ [GHC.Types.Char] @ m $dStream
  = Lib.$s$fMonadParsecesParsecT_$spTakeWhile1P @ e @ m
"SPEC/Lib pTakeWhileP _ @ [Char] _" [orphan] forall @ e
                                                    @ m :: * -> *
                                                    ($dStream :: Text.Megaparsec.Stream.Stream
                                                                   [GHC.Types.Char])
  Text.Megaparsec.pTakeWhileP @ e @ [GHC.Types.Char] @ m $dStream
  = Lib.$s$fMonadParsecesParsecT_$spTakeWhileP @ e @ m
"SPEC/Lib pToken _ @ [Char] _ _" [orphan] forall @ e
                                                 @ m :: * -> *
                                                 @ a
                                                 ($dStream :: Text.Megaparsec.Stream.Stream
                                                                [GHC.Types.Char])
  Text.Megaparsec.pToken @ e @ [GHC.Types.Char] @ m @ a $dStream
  = Lib.$s$fMonadParsecesParsecT_$spToken @ e @ m @ a
"SPEC/Lib pTokens _ @ [Char] _" [orphan] forall @ e
                                                @ m :: * -> *
                                                ($dStream :: Text.Megaparsec.Stream.Stream
                                                               [GHC.Types.Char])
  Text.Megaparsec.pTokens @ e @ [GHC.Types.Char] @ m $dStream
  = Lib.$s$fMonadParsecesParsecT_$spTokens @ e @ m
"SPEC/Lib union @ (ErrorFancy Void)" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                 (Text.Megaparsec.Error.ErrorFancy
                                                                    Data.Void.Void))
  Data.Set.Internal.union @ (Text.Megaparsec.Error.ErrorFancy
                               Data.Void.Void)
                          $dOrd
  = Lib.$s$fAlternativeParsecT_$sunion
"SPEC/Lib union @ (ErrorItem (Token [Char]))" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                          (Text.Megaparsec.Error.ErrorItem
                                                                             (Text.Megaparsec.Stream.Token
                                                                                [GHC.Types.Char])))
  Data.Set.Internal.union @ (Text.Megaparsec.Error.ErrorItem
                               (Text.Megaparsec.Stream.Token [GHC.Types.Char]))
                          $dOrd
  = Lib.$s$fAlternativeParsecT_$sunion1
"SPEC/Lib withHints @ [Char] _ _ _" [orphan] forall @ e
                                                    @ m :: * -> *
                                                    @ b
                                                    ($dOrd :: GHC.Classes.Ord
                                                                (Text.Megaparsec.Stream.Token
                                                                   [GHC.Types.Char]))
  Text.Megaparsec.withHints @ [GHC.Types.Char] @ e @ m @ b $dOrd
  = Lib.$s$fAlternativeParsecT_$swithHints @ e @ m @ b
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

